# sleigh specification file for GameCube DSP

# untested with this disabled, probably incorrect currently
@define TEAK_LITE_2

# Directly mutate the sr register instead of a set of fake registers
# The fake registers provide better decompilation
#@define USE_REAL_SR_REGISTER

@define NOCASH_SYNTAX

# Opening/closing brackets
@ifdef NOCASH_SYNTAX
@define OB "["
@define CB "]"
@else
@define OB "("
@define CB ")"
@endif

define endian=little;
define alignment=2;

define space code     type=ram_space      size=2 wordsize=2;
define space data     type=ram_space      size=2 wordsize=2 default;
define space register type=register_space size=1 wordsize=2;

# http://problemkaputt.de/gbatek.htm#dsiteakcpuregisters

define register offset=0x00 size=2 [ r0 r1 r2 r3 r4 r5 ];
@ifdef TEAK_LITE_2
define register offset=0x0c size=2 [ r6 ];
@endif
define register offset=0x0e size=2 [ r7 ]; # AKA rb

define register offset=0x10 size=2 [ x0 y0 ];
@ifdef TEAK_LITE_2
define register offset=0x14 size=2 [ x1 y1 ];
@endif

# Swapped by banke
define register offset=0x18 size=2 [ r0b r1b r4b ];
@ifdef TEAK_LITE_2
define register offset=0x1e size=2 [ r7b ];
@endif

# 33 bits?
# p1 is Teak Lite 2?
define register offset=0x20 size=5 [ p0full p1full ];
# This isn't clarified in the Operand Encoding section
define register offset=0x22 size=2 [ p0 ];
define register offset=0x27 size=2 [ p1 ];
# Is this the same as p0?
define register offset=0x2a size=2 [ p0h ];

# 18-bit PC, not encoding this directly
define register offset=0x2c size=3 [ pc_full ];
define register offset=0x2d size=2 [ pc ];

define register offset=0x30 size=2 [ sp sv mixp lc repc dvm ];
@ifdef TEAK_LITE_2
define register offset=0x3c size=2 [ vtr0 vtr1 ];
# 4 bits; not meaningful on the DSi
define register offset=0x40 size=2 [ prpage ];
@endif

# custom hardware extensions (e.g. I/O ports, not used here?)
define register offset=0x42 size=2 [ ext0 ext1 ext2 ext3 ];

define register offset=0x4a size=2 [ st0 st1 st2 ];
define register offset=0x50 size=2 [ icr ];
@ifdef TEAK_LITE_2
define register offset=0x52 size=2 [ stt0 stt1 stt2 ];
define register offset=0x58 size=2 [ mod0 mod1 mod2 mod3 ];
define register offset=0x60 size=2 [ ar0 ar1 arp0 arp1 arp2 arp3 ];
@endif
define register offset=0x6c size=2 [ cfgi cfgj ];
@ifdef TEAK_LITE_2
define register offset=0x70 size=2 [ stepi stepj cfgib cfgjb stepi0 stepj0 ];
@endif

# a0e and a1e are 4-bit instead of 8-bit on teak lite 1, and b0e and b1e don't exist
define register offset=0x80 size=2 [ a0e a0h a0l ];
define register offset=0x81 size=1 [ a0ereal ];
define register offset=0x81 size=5 [ a0 ];
define register offset=0x90 size=2 [ a1e a1h a1l ];
define register offset=0x91 size=1 [ a1ereal ];
define register offset=0x91 size=5 [ a1 ];
define register offset=0xa0 size=2 [ b0e b0h b0l ];
define register offset=0xa1 size=1 [ b0ereal ];
define register offset=0xa1 size=5 [ b0 ];
define register offset=0xb0 size=2 [ b1e b1h b1l ];
define register offset=0xb1 size=1 [ b1ereal ];
define register offset=0xb1 size=5 [ b1 ];

# Fake register for extra-fake purposes; hardware uses some of the stacks for this
define register offset=0xF0 size=8 [ loopcontext ];

# Magic to make loops work
define context loopcontext
	loopstackdepth = (16,19)
	loopjumpbackaddr = (32,47) noflow
	hasloopjumpback = (48,48) noflow
;

# Loop stack for the current loop counter. We don't currently have lc directly reflect this value,
# because doing so would be a bit difficult.
# Real hardware has a depth of 4, but more is used here to avoid emulating bkrepsto and to
# allow rep to use the same registers as bkrep.
define register offset=0xD0 size=2 [ lc_0 lc_1 lc_2 lc_3 lc_4 lc_5 lc_6 lc_7 ];
# Note: The outermost loop increments loopstackdepth and then uses CurSt3, so index 1 is the first.
# Although we could reset loopstackdepth for the loop instruction, it needs to be changed for
# the next instruction for flowing to work, and that instruction might need to check looping.
CurLC: is loopstackdepth=1 { export lc_0; }
CurLC: is loopstackdepth=2 { export lc_1; }
CurLC: is loopstackdepth=3 { export lc_2; }
CurLC: is loopstackdepth=4 { export lc_3; }
CurLC: is loopstackdepth=5 { export lc_4; }
CurLC: is loopstackdepth=6 { export lc_5; }
CurLC: is loopstackdepth=7 { export lc_6; }
CurLC: is loopstackdepth=8 { export lc_7; }

# Regular and hacky implementation of status register
@ifdef USE_REAL_SR_REGISTER
@define SR_CARRY            "sr[0,1]"
@define SR_OVERFLOW         "sr[1,1]"
@define SR_ARITH_ZERO       "sr[2,1]"
@define SR_SIGN             "sr[3,1]"
@define SR_OVER_32          "sr[4,1]"
@define SR_TOP2BITS         "sr[5,1]"
@define SR_LOGIC_ZERO       "sr[6,1]"
@define SR_OVERFLOW_STICKY  "sr[7,1]"
@define SR_100              "sr[8,1]"
@define SR_INT_ENABLE       "sr[9,1]"
@define SR_400              "sr[10,1]"
@define SR_EXT_INT_ENABLE   "sr[11,1]"
@define SR_1000             "sr[12,1]"
@define SR_MUL_MODIFY       "sr[13,1]"
@define SR_40_MODE          "sr[14,1]"
@define SR_MUL_UNSIGNED     "sr[15,1]"
@else
define space hack_register type=ram_space size=1;
define hack_register offset=0 size=1 [ SR_CARRY_ SR_OVERFLOW_ SR_ARITH_ZERO_ SR_SIGN_ SR_OVER_32_ SR_TOP2BITS_ SR_LOGIC_ZERO_ SR_OVERFLOW_STICKY_ SR_100_ SR_INT_ENABLE_ SR_400_ SR_EXT_INT_ENABLE_ SR_1000_ SR_MUL_MODIFY_ SR_40_MODE_ SR_MUL_UNSIGNED_ ];
# Note: forcing to only a single bit.  Also, we need to use macros in both cases for consistent syntax.
@define SR_CARRY "SR_CARRY_[0,1]"
@define SR_OVERFLOW "SR_OVERFLOW_[0,1]"
@define SR_ARITH_ZERO "SR_ARITH_ZERO_[0,1]"
@define SR_SIGN "SR_SIGN_[0,1]"
@define SR_OVER_32 "SR_OVER_32_[0,1]"
@define SR_TOP2BITS "SR_TOP2BITS_[0,1]"
@define SR_LOGIC_ZERO "SR_LOGIC_ZERO_[0,1]"
@define SR_OVERFLOW_STICKY "SR_OVERFLOW_STICKY_[0,1]"
@define SR_100 "SR_100_[0,1]"
@define SR_INT_ENABLE "SR_INT_ENABLE_[0,1]"
@define SR_400 "SR_400_[0,1]"
@define SR_EXT_INT_ENABLE "SR_EXT_INT_ENABLE_[0,1]"
@define SR_1000 "SR_1000_[0,1]"
@define SR_MUL_MODIFY "SR_MUL_MODIFY_[0,1]"
@define SR_40_MODE "SR_40_MODE_[0,1]"
@define SR_MUL_UNSIGNED "SR_MUL_UNSIGNED_[0,1]"
@endif

define token opcode (16)
	opcode_0_0   = (0, 0)
	opcode_0_1   = (0, 1)
	opcode_0_2   = (0, 2)
	opcode_0_3   = (0, 3)
	opcode_0_4   = (0, 4)
	opcode_0_7   = (0, 7)
	opcode_0_9   = (0, 9)
	opcode_0_15  = (0, 15)
	opcode_1_1   = (1, 1)
	opcode_1_4   = (1, 4)
	opcode_1_5   = (1, 5)
	opcode_1_7   = (1, 7)
	opcode_1_9   = (1, 9)
	opcode_1_15  = (1, 15)
	opcode_2_2   = (2, 2)
	opcode_2_3   = (2, 3)
	opcode_2_4   = (2, 4)
	opcode_2_5   = (2, 5)
	opcode_2_7   = (2, 7)
	opcode_2_9   = (2, 9)
	opcode_2_15  = (2, 15)
	opcode_3_3   = (3, 3)
	opcode_3_4   = (3, 4)
	opcode_3_7   = (3, 7)
	opcode_3_9   = (3, 9)
	opcode_3_15  = (3, 15)
	opcode_4_4   = (4, 4)
	opcode_4_7   = (4, 7)
	opcode_4_11  = (4, 11)
	opcode_4_15  = (4, 15)
	opcode_5_5   = (5, 5)
	opcode_5_7   = (5, 7)
	opcode_5_10  = (5, 10)
	opcode_5_15  = (5, 15)
	opcode_6_6   = (6, 6)
	opcode_6_10  = (6, 10)
	opcode_6_15  = (6, 15)
	opcode_6_7   = (6, 7)
	opcode_7_7   = (7, 7)
	opcode_7_8   = (7, 8)
	opcode_7_9   = (7, 9)
	opcode_7_10  = (7, 10)
	opcode_7_15  = (7, 15)
	opcode_8_8   = (8, 8)
	opcode_8_9   = (8, 9)
	opcode_8_10  = (8, 10)
	opcode_8_11  = (8, 11)
	opcode_8_15  = (8, 15)
	opcode_9_9   = (9, 9)
	opcode_9_15  = (9, 15)
	opcode_10_15 = (10, 15)
	opcode_11_15 = (11, 15)
	opcode_12_15 = (12, 15)
	opcode_13_15 = (13, 15)

	# Nocash documentation indicates these explicitly (as otherwise you can't tell just looking at
	# the hex). Sleigh simply requires that no constraint act on those bits. So, these unused fields
	# aren't strictly needed, but are included in instruction constructors for completeness and to
	# make it easier to compare with nocash.
	unused_0_0   = (0, 0)
	unused_0_1   = (0, 1)
	unused_0_2   = (0, 2)
	unused_5_5   = (5, 5)
	unused_10_10 = (10, 10)

	imm2u_0 = (0, 1)
	imm2u_1 = (1, 2)
	imm4u_0 = (0, 3)
	imm4_8  = (8, 11)
	imm5u_0 = (0, 4)
	imm5s_0 = (0, 4) signed
	imm6s_0 = (0, 5) signed
	imm7s_0 = (0, 6) signed
	imm7_4  = (4, 10)
	imm8_0  = (0, 7)
	imm8s_0 = (0, 7) signed
	imm8u_0 = (0, 7)
	imm9u_0 = (0, 8)

	Register_0 = (0, 4)
	Register_5 = (5, 9)
	Register_P_0 = (0, 4)

	Ax_0  = (0, 0)
	Ax_1  = (1, 1)
	Ax_3  = (3, 3)
	Ax_4  = (4, 4)
	Ax_5  = (5, 5)
	Ax_6  = (6, 6)
	Ax_8  = (8, 8)
	Ax_10 = (10, 10)
	Ax_11 = (11, 11)
	Ax_12 = (12, 12)
	Ax_Not8  = (8, 8)
	Ax_Not12 = (12, 12)

	Axl_0  = (0, 0)
	Axl_1  = (1, 1)
	Axl_3  = (3, 3)
	Axl_4  = (4, 4)
	Axl_5  = (5, 5)
	Axl_6  = (6, 6)
	Axl_8  = (8, 8)
	Axl_11 = (11, 11)
	Axl_12 = (12, 12)
	Axl_Not0  = (0, 0)
	Axl_Not3  = (3, 3)
	Axl_Not4  = (4, 4)
	Axl_Not6  = (6, 6)
	Axl_Not11 = (11, 11)

	Axh_0  = (0, 0)
	Axh_1  = (1, 1)
	Axh_3  = (3, 3)
	Axh_4  = (4, 4)
	Axh_6  = (6, 6)
	Axh_8  = (8, 8)
	Axh_9  = (9, 9)
	Axh_11 = (11, 11)
	Axh_12 = (12, 12)
	Axh_Not0  = (0, 0)
	Axh_Not3  = (3, 3)
	Axh_Not4  = (4, 4)
	Axh_Not6  = (6, 6)
	Axh_Not11 = (11, 11)

	Px_0 = (0, 0)
	Px_1 = (1, 1)
	Px_4 = (4, 4)

	Bx_0 = (0, 0)
	Bx_1 = (1, 1)
	Bx_2 = (2, 2)
	Bx_3 = (3, 3)
	Bx_4 = (4, 4)
	Bx_5 = (5, 5)
	Bx_8 = (8, 8)
	Bx_10 = (10, 10)
	Bx_12 = (12, 12)

	Bxl_0 = (0, 0)
	Bxl_3 = (3, 3)
	Bxl_4 = (4, 4)
	Bxl_5 = (5, 5)
	Bxl_10 = (10, 10)
	Bxl_Not4 = (4, 4)

	Bxh_0 = (0, 0)
	Bxh_2 = (3, 3)
	Bxh_3 = (3, 3)
	Bxh_4 = (4, 4)
	Bxh_5 = (5, 5)
	Bxh_8 = (5, 5)
	Bxh_10 = (10, 10)
	Bxh_Not4 = (4, 4)

	Ab_0  = (0, 1)
	Ab_2  = (2, 3)
	Ab_3  = (3, 4)
	Ab_4  = (4, 5)
	Ab_5  = (5, 6)
	Ab_6  = (6, 7)
	Ab_7  = (7, 8)
	Ab_8  = (8, 9)
	Ab_10 = (10, 11)
	Ab_11 = (11, 12)

	Abl_0  = (0, 1)
	Abl_2  = (2, 3)
	Abl_3  = (3, 4)
	Abl_4  = (4, 5)
	Abl_10 = (10, 11)

	Abh_2  = (2, 3)
	Abh_3  = (3, 4)
	Abh_4  = (4, 5)
	Abh_8  = (8, 9)
	Abh_10 = (10, 11)

	Abe_0  = (0, 1)
	Abe_1  = (1, 2)

	Ablh_9  = (9, 11)
	Ablh_10 = (10, 12)

	cond_0 = (0, 3)

	R0123457y0_9  = (9, 11)
	R0123457y0_10 = (10, 12)

	Rn_0 = (0, 2)

	R01_0 = (0, 0)
	R01_2 = (2, 2)
	R01_3 = (3, 3)
	R01_4 = (4, 4)
	R01_5 = (5, 5)
	R01_8 = (8, 8)
	R01_9 = (9, 9)

	R04_1 = (1, 1)
	R04_3 = (3, 3)
	R04_4 = (4, 4)
	R04_8 = (8, 8)

	R45_0 = (0, 0)
	R45_2 = (2, 2)
	R45_3 = (3, 3)
	R45_4 = (4, 4)
	R45_5 = (5, 5)
	R45_8 = (8, 8)
	R45_9 = (9, 9)

	R0123_0  = (0, 1)
	R0123_4  = (4, 5)
	R0123_5  = (5, 6)
	R0123_8  = (8, 9)
	R0123_10 = (10, 11)

	R0425_0  = (0, 1)
	R0425_2  = (2, 3)
	R0425_3  = (3, 4)
	R0425_4  = (4, 5)
	R0425_7  = (7, 8)
	R0425_8  = (8, 9)
	R0425_10 = (10, 11)

	R4567_4  = (4, 5)
	R4567_5  = (5, 6)
	R4567_8  = (8, 9)
	R4567_10 = (10, 11)

	ArArpSttMod_0 = (0, 3)
	ArArpSttMod_8 = (8, 11)

	ArArp_0 = (0, 2)
	ArArp_8 = (8, 10)
	SttMod_0 = (0, 2)
	SttMod_8 = (8, 10)

	Ar_0 = (0, 0)
	Ar_2 = (2, 2)

	Arp_0 = (0, 1)

	BankFlags_cfgi = (0, 0)
	BankFlags_r4 = (1, 1)
	BankFlags_r1 = (2, 2)
	BankFlags_r0 = (3, 3)
	BankFlags_r7 = (4, 4)
	BankFlags_cfgj = (5, 5)

	SwapTypes_0 = (0, 3)

	address18_2bits_0 = (0, 1)
	address18_2bits_4 = (4, 5)
	address18_2bits_5 = (5, 6)

	stepZIDS_0 = (0, 1)
	stepZIDS_3 = (3, 4)
	stepZIDS_5 = (5, 6)
	stepZIDS_7 = (7, 8)

	stepII2_0 = (0, 0)
	stepII2_1 = (1, 1)
	stepII2_2 = (2, 2)
	stepII2_3 = (3, 3)
	stepII2_4 = (4, 4)
	stepII2_5 = (5, 5)
	stepII2_6 = (6, 6)
	stepII2_8 = (8, 8)
	stepII2_9 = (9, 9)

	modrstepII2D2S0_0 = (0, 1)
	modrstepII2D2S0_1 = (1, 2)
	modrstepII2D2S0_3 = (3, 4)
	modrstepII2D2S0_5 = (5, 6)

	offsZI_0 = (0, 0)
	offsZI_1 = (1, 1)
	offsZI_2 = (2, 2)
	offsZI_3 = (3, 3)
	offsZI_4 = (4, 4)
	offsZI_6 = (6, 6)
	offsZI_8 = (8, 8)
	offsZI_9 = (9, 9)

	offsZIDZ_0 = (0, 1)
	offsZIDZ_2 = (2, 3)
	offsZIDZ_5 = (5, 6)

	stepII2D2S_0 = (0, 1)
	stepII2D2S_2 = (2, 3)
	stepII2D2S_5 = (5, 6)
	stepII2D2S_8 = (8, 9)

	stepD2S_3 = (3, 3)

	step_Rn_0 = (2, 2)
;

# http://problemkaputt.de/gbatek.htm#dsiteakliteiioperandencoding

# TODO: the original info says a0 and a1 and also p0, but those aren't 16 bits?
attach variables [ Register_0 Register_5 ] [
	r0 r1 r2 r3
	r4 r5 r7 y0 # NOTE: no r6
	# 08
	st0 st1 st2 p0h # NOTE: p0h
	pc sp cfgi cfgj
	# 10
	b0h b1h b0l b1l
	ext0 ext1 ext2 ext3
	# 18
	a0e a1e a0l a1l
	a0h a1h lc sv
];

attach variables [ Register_P_0 ] [
	r0 r1 r2 r3
	r4 r5 r7 y0 # NOTE: no r6
	# 08
	st0 st1 st2 p0 # NOTE: p0
	pc sp cfgi cfgj
	# 10
	b0h b1h b0l b1l
	ext0 ext1 ext2 ext3
	# 18
	a0e a1e a0l a1l
	a0h a1h lc sv
];

define token expanded (16)
	expanded_imm = (0, 15)
	expanded_imm4_16 = (0, 3)
	expanded_unused_20_31 = (4, 15)
;

attach variables [ Ax_0 Ax_1 Ax_3 Ax_4 Ax_5 Ax_6 Ax_8 Ax_10 Ax_11 Ax_12 ] [ a0 a1 ];
attach variables [ Ax_Not8 Ax_Not12 ] [ a1 a0 ];

attach variables [ Axl_0 Axl_1 Axl_3 Axl_4 Axl_5 Axl_6 Axl_8 Axl_11 Axl_12 ] [ a0l a1l ];
attach variables [ Axl_Not0 Axl_Not3 Axl_Not4 Axl_Not6 Axl_Not11 ] [ a1l a0l ];

attach variables [ Axh_0 Axh_1 Axh_3 Axh_4 Axh_6 Axh_8 Axh_9 Axh_11 Axh_12 ] [ a0h a1h ];
attach variables [ Axh_Not0 Axh_Not3 Axh_Not4 Axh_Not6 Axh_Not11 ] [ a1h a0h ];

attach variables [ Px_0 Px_1 Px_4 ] [ p0 p1 ];

attach variables [ Bx_0 Bx_1 Bx_2 Bx_3 Bx_4 Bx_5 Bx_8 Bx_10 Bx_12 ] [ b0 b1 ];

attach variables [ Bxl_0 Bxl_3 Bxl_4 Bxl_5 Bxl_10 ] [ b0l b1l ];
attach variables [ Bxl_Not4 ] [ b1l b0l ];

attach variables [ Bxh_0 Bxh_2 Bxh_3 Bxh_4 Bxh_5 Bxh_8 Bxh_10 ] [ b0h b1h ];
attach variables [ Bxh_Not4 ] [ b1h b0h ];

attach variables [ Ab_0 Ab_2 Ab_3 Ab_4 Ab_5 Ab_6 Ab_7 Ab_8 Ab_10 Ab_11 ] [ b0 b1 a0 a1 ];
attach variables [ Abl_0 Abl_2 Abl_3 Abl_4 Abl_10 ] [ b0l b1l a0l a1l ];
attach variables [ Abh_2 Abh_3 Abh_4 Abh_8 Abh_10 ] [ b0h b1h a0h a1h ];
attach variables [ Abe_0 Abe_1 ] [ b0e b1e a0e a1e ];
attach variables [ Ablh_9 Ablh_10 ] [ b0l b0h b1l b1h a0l a0h a1l a1h ];

attach variables [ R0123457y0_9 R0123457y0_10 ] [ r0 r1 r2 r3 r4 r5 r7 y0 ];
attach variables [ Rn_0 ] [ r0 r1 r2 r3 r4 r5 r6 r7 ];

attach variables [ R01_0 R01_2 R01_3 R01_4 R01_5 R01_8 R01_9 ] [ r0 r1 ];
attach variables [ R04_1 R04_3 R04_4 R04_8 ] [ r0 r4 ];
attach variables [ R45_0 R45_2 R45_3 R45_4 R45_5 R45_8 R45_9 ] [ r4 r5 ];
attach variables [ R0123_0 R0123_4 R0123_5 R0123_8 R0123_10 ] [ r0 r1 r2 r3 ];
attach variables [ R0425_0 R0425_2 R0425_3 R0425_4 R0425_7 R0425_8 R0425_10 ] [ r0 r4 r2 r5 ];
attach variables [ R4567_4 R4567_5 R4567_8 R4567_10 ] [ r4 r5 r6 r7 ];

@ifdef TEAK_LITE_2
attach variables [ ArArpSttMod_0 ArArpSttMod_8 ] [
	ar0 ar1
	arp0 arp1 arp2 arp3
	_ _
	stt0 stt1 stt2 _
	mod0 mod1 mod2 mod3
];
@endif

attach variables [ ArArp_0 ArArp_8 ] [ ar0 ar1 arp0 arp1 arp2 arp3 _ _ ];
attach variables [ SttMod_0 SttMod_8 ] [ stt0 stt1 stt2 _ mod0 mod1 mod2 mod3 ];
attach variables [ Ar_0 Ar_2 ] [ ar0 ar1 ];
attach variables [ Arp_0 ] [ arp0 arp1 arp2 arp3 ];

# TODO: Nocash explicitly says it's unclear whether opcodes that use Rn_0 use
# stepi or stepj in all cases, or if they use stepi for r0-r3 and stepj for r4-r7.
# So unlike the others, there's a chance that this actually is implemented like this:
# attach variables [ step_Rn_0 ] [ stepi stepj ];
# For now I've just used stepi in both cases though.
# See http://problemkaputt.de/gbatek-dsi-teaklite-ii-operand-encoding.htm
attach variables [ step_Rn_0 ] [ stepi stepi ];

attach values [ stepII2_0 stepII2_1 stepII2_2 stepII2_3 stepII2_4 stepII2_5 stepII2_6 stepII2_8 stepII2_9 ] [ 1 2 ]; # Increment either once or twice

# Operands can only appear in the display section once, or else the errors
# "Duplicate symbol name" and "Redefining operand" will appear. Unfortunately,
# we have actual duplicate symbols because many instructions are horrible messes.
# This can be worked around either by providing copies of the operands in the token
# section, or by creating tables for those copies. Tables are nicer because then
# there's no need to worry about forgetting to attach variables to the copy.
# These should not appear in the semantic section.
Abl_2_copy:Abl_2 is Abl_2 {}
Abh_4_copy:Abh_4 is Abh_4 {}
sv_copy:sv is sv {}
sv_copy_2:sv is sv {}
Axh_4_copy:Axh_4 is Axh_4 {}
Axh_6_copy:Axh_6 is Axh_6 {}

# Always
# Excluded because this makes analysis messy - instead specialze every instruction that uses conditions
#Cond_0:"true" is cond_0=0x0 { local always:1 = 1; export always; }
# Equal to zero             (Z=1)
define pcodeop tmp_maybe; # TODO; using unimpl for all of these gives errors due to no exports
Cond_0:"eq"   is cond_0=0x1 { local maybe:1 = tmp_maybe(); export maybe; }
# Not equal to zero         (Z=0)
Cond_0:"neq"  is cond_0=0x2 { local maybe:1 = tmp_maybe(); export maybe; }
# Greater than zero         (M=0 and Z=0)
Cond_0:"gt"   is cond_0=0x3 { local maybe:1 = tmp_maybe(); export maybe; }
# Greater or equal to zero  (M=0)
Cond_0:"ge"   is cond_0=0x4 { local maybe:1 = tmp_maybe(); export maybe; }
# Less than zero            (M=1)
Cond_0:"lt"   is cond_0=0x5 { local maybe:1 = tmp_maybe(); export maybe; }
# Less or equal to zero     (M=1 or Z=1)
Cond_0:"le"   is cond_0=0x6 { local maybe:1 = tmp_maybe(); export maybe; }
# Normalize flag is cleared (N=0)
Cond_0:"nn"   is cond_0=0x7 { local maybe:1 = tmp_maybe(); export maybe; }
# Carry flag is set         (C=1)
Cond_0:"c"    is cond_0=0x8 { local maybe:1 = tmp_maybe(); export maybe; }
# Overflow flag is set      (V=1)
Cond_0:"v"    is cond_0=0x9 { local maybe:1 = tmp_maybe(); export maybe; }
# Extension flag is set     (E=1)
Cond_0:"e"    is cond_0=0xa { local maybe:1 = tmp_maybe(); export maybe; }
# Limit flag is set         (L=1)
Cond_0:"l"    is cond_0=0xb { local maybe:1 = tmp_maybe(); export maybe; }
# R flag is cleared         (R=0)
Cond_0:"nr"   is cond_0=0xc { local maybe:1 = tmp_maybe(); export maybe; }
# Input user pin 0 cleared  (IUSER0=0)
Cond_0:"niu0" is cond_0=0xd { local maybe:1 = tmp_maybe(); export maybe; }
# Input user pin 0 set      (IUSER0=1)
Cond_0:"iu0"  is cond_0=0xe { local maybe:1 = tmp_maybe(); export maybe; }
# Input user pin 1 set      (IUSER1=1)
Cond_0:"iu1"  is cond_0=0xf { local maybe:1 = tmp_maybe(); export maybe; }

MemRn_0:$(OB)Rn_0$(CB) is Rn_0 { export *[data]:2 Rn_0; }
MemSp:$(OB)sp$(CB) is sp { export *[data]:2 sp; }

@ifdef NOCASH_SYNTAX
ProgMemRn_0:[^"code:movpd":Rn_0] is Rn_0
@else
ProgMemRn_0:(Rn_0) is Rn_0
@endif
{
	export *[code]:2 Rn_0;
}

@ifdef NOCASH_SYNTAX
ProgMemAxl_5:[^"code:movpd":Axl_5] is Axl_5
@else
ProgMemAxl_5:(Axl_5) is Axl_5
@endif
{
	export *[code]:2 Axl_5;
}

@ifdef NOCASH_SYNTAX
ProgMemAx_5:[^"code:movpd":Ax_5] is Ax_5
@else
ProgMemAx_5:(Ax_5) is Ax_5
@endif
{
	export *[code]:2 Ax_5;
}

@ifdef NOCASH_SYNTAX
ProgMemAx_8:[^"code:movpd":Ax_8] is Ax_8
@else
ProgMemAx_8:(Ax_8) is Ax_8
@endif
{
	export *[code]:2 Ax_8;
}

# offsI doesn't seem to be configurable
@ifdef NOCASH_SYNTAX
ProgMemAx_8_offsI:[^"code:movpd":Ax_8+] is Ax_8
@else
ProgMemAx_8_offsI:(Ax_8+) is Ax_8
@endif
{
	addr = Ax_8 + 1;
	export *[code]:2 addr;
}

@ifdef NOCASH_SYNTAX
ProgMemR45_2:[^"code:movpd":R45_2] is R45_2
@else
ProgMemR45_2:(R45_2) is R45_2
@endif
{
	export *[code]:2 R45_2;
}


@ifdef NOCASH_SYNTAX
MemImm8_0:[^"page":imm8_0] is imm8_0
@else
MemImm8_0:imm8_0 is imm8_0
@endif
{
	# TODO: handle page
	addr:2 = imm8_0;
	export *[data]:2 addr;
}

@ifdef NOCASH_SYNTAX
MemImm16:[expanded_imm] is expanded_imm
@else
MemImm16:[##expanded_imm] is expanded_imm
@endif
{
	export *[data]:2 expanded_imm;
}

@ifdef NOCASH_SYNTAX
MemR7Imm7s_0:[r7+imm7s_0] is r7 & imm7s_0
@else
MemR7Imm7s_0:(r7+#imm7s_0) is r7 & imm7s_0
@endif
{
	addr:2 = r7 + imm7s_0;
	export *[data]:2 addr;
}

@ifdef NOCASH_SYNTAX
MemR7Imm16:[r7+expanded_imm] is expanded_imm & r7
@else
MemR7Imm16:(r7+##expanded_imm) is expanded_imm & r7
@endif
{
	addr:2 = r7 + expanded_imm;
	export *[data]:2 addr;
}

# TODO: is this the intended way for this to be displayed?
Imm4bitno_8:shifted_bit is imm4_8 [ shifted_bit = 1 << imm4_8; ] { export *[data]:2 shifted_bit; }
Imm4bitno_16:shifted_bit is expanded_imm4_16 [ shifted_bit = 1 << expanded_imm4_16; ] { export *[data]:2 shifted_bit; }

Address18_16and0:full_addr is address18_2bits_0; expanded_imm
[ full_addr = (address18_2bits_0 << 16) + expanded_imm; ]
{
	export *[code]:2 full_addr;
}
Address18_16and4:full_addr is address18_2bits_4; expanded_imm
[ full_addr = (address18_2bits_4 << 16) + expanded_imm; ]
{
	export *[code]:2 full_addr;
}
Address18_16and5:full_addr is address18_2bits_5; expanded_imm
[ full_addr = (address18_2bits_5 << 16) + expanded_imm; ]
{
	export *[code]:2 full_addr;
}

Address18_16and0After:full_addr is address18_2bits_0; expanded_imm
[ full_addr = (address18_2bits_0 << 16) + expanded_imm + 1; ]
{
	export *[code]:2 full_addr;
}

Address18_16and5After:full_addr is address18_2bits_5; expanded_imm
[ full_addr = (address18_2bits_5 << 16) + expanded_imm + 1; ]
{
	export *[code]:2 full_addr;
}

Address16:expanded_imm is expanded_imm
{
	export *[data]:2 expanded_imm;
}

Address16After:new_imm is expanded_imm [ new_imm = expanded_imm + 1; ]
{
	export *[data]:2 expanded_imm;
}

RelAddr7_4:full_addr is imm7_4
[ full_addr = inst_next + imm7_4; ]  # TODO: inst_next or inst_start?
{
	export *[code]:2 full_addr;  # TODO: do we want to dereference this?
}

MemR0:$(OB)r0$(CB) is r0 { export *[data]:2 r0; }

# Notepad++ regexes for these:
# ^MemR(\d+)@(\d+)$
# MemR\1_\2:        $\(OB\)R\1_\2$\(CB\)  is R\1_\2              { export *[data]:2 R\1_\2; }
# ^MemR(\d+)@(\d+)offsZI@(\d+)$
# MemR\1_\2_offsZI_\3:$\(OB\)R\1_\2$\(CB\)  is R\1_\2 & offsZI_\3=0 { export *[data]:2 R\1_\2; }\r\nMemR\1_\2_offsZI_\3:$\(OB\)R\1_\2+$\(CB\) is R\1_\2 & offsZI_\3=1 { addr = R\1_\2 + 1; export *[data]:2 addr; }

MemR01_0:         $(OB)R01_0$(CB)  is R01_0              { export *[data]:2 R01_0; }
MemR01_0_offsZI_8:$(OB)R01_0$(CB)  is R01_0 & offsZI_8=0 { export *[data]:2 R01_0; }
MemR01_0_offsZI_8:$(OB)R01_0+$(CB) is R01_0 & offsZI_8=1 { addr = R01_0 + 1; export *[data]:2 addr; }
MemR01_2:         $(OB)R01_2$(CB)  is R01_2              { export *[data]:2 R01_2; }
MemR01_2_offsZI_0:$(OB)R01_2$(CB)  is R01_2 & offsZI_0=0 { export *[data]:2 R01_2; }
MemR01_2_offsZI_0:$(OB)R01_2+$(CB) is R01_2 & offsZI_0=1 { addr = R01_2 + 1; export *[data]:2 addr; }
MemR01_3:         $(OB)R01_3$(CB)  is R01_3              { export *[data]:2 R01_3; }
MemR01_3_offsZI_1:$(OB)R01_3$(CB)  is R01_3 & offsZI_1=0 { export *[data]:2 R01_3; }
MemR01_3_offsZI_1:$(OB)R01_3+$(CB) is R01_3 & offsZI_1=1 { addr = R01_3 + 1; export *[data]:2 addr; }
MemR01_4:         $(OB)R01_4$(CB)  is R01_4              { export *[data]:2 R01_4; }
MemR01_4_offsZI_2:$(OB)R01_4$(CB)  is R01_4 & offsZI_2=0 { export *[data]:2 R01_4; }
MemR01_4_offsZI_2:$(OB)R01_4+$(CB) is R01_4 & offsZI_2=1 { addr = R01_4 + 1; export *[data]:2 addr; }
MemR01_5:         $(OB)R01_5$(CB)  is R01_5              { export *[data]:2 R01_5; }
MemR01_5_offsZI_3:$(OB)R01_5$(CB)  is R01_5 & offsZI_3=0 { export *[data]:2 R01_5; }
MemR01_5_offsZI_3:$(OB)R01_5+$(CB) is R01_5 & offsZI_3=1 { addr = R01_5 + 1; export *[data]:2 addr; }
MemR01_8:         $(OB)R01_8$(CB)  is R01_8              { export *[data]:2 R01_8; }
MemR01_8_offsZI_0:$(OB)R01_8$(CB)  is R01_8 & offsZI_0=0 { export *[data]:2 R01_8; }
MemR01_8_offsZI_0:$(OB)R01_8+$(CB) is R01_8 & offsZI_0=1 { addr = R01_8 + 1; export *[data]:2 addr; }
MemR01_9:         $(OB)R01_9$(CB)  is R01_9              { export *[data]:2 R01_9; }
# no offsZI variant exists for MemR01_9

MemR45_0:         $(OB)R45_0$(CB)  is R45_0              { export *[data]:2 R45_0; }
MemR45_0_offsZI_9:$(OB)R45_0$(CB)  is R45_0 & offsZI_9=0 { export *[data]:2 R45_0; }
MemR45_0_offsZI_9:$(OB)R45_0+$(CB) is R45_0 & offsZI_9=1 { addr = R45_0 + 1; export *[data]:2 addr; }
MemR45_2:         $(OB)R45_2$(CB)  is R45_2              { export *[data]:2 R45_2; }
MemR45_2_offsZI_1:$(OB)R45_2$(CB)  is R45_2 & offsZI_1=0 { export *[data]:2 R45_2; }
MemR45_2_offsZI_1:$(OB)R45_2+$(CB) is R45_2 & offsZI_1=1 { addr = R45_2 + 1; export *[data]:2 addr; }
MemR45_3:         $(OB)R45_3$(CB)  is R45_3              { export *[data]:2 R45_3; }
MemR45_3_offsZI_2:$(OB)R45_3$(CB)  is R45_3 & offsZI_2=0 { export *[data]:2 R45_3; }
MemR45_3_offsZI_2:$(OB)R45_3+$(CB) is R45_3 & offsZI_2=1 { addr = R45_3 + 1; export *[data]:2 addr; }
MemR45_4:         $(OB)R45_4$(CB)  is R45_4              { export *[data]:2 R45_4; }
MemR45_4_offsZI_3:$(OB)R45_4$(CB)  is R45_4 & offsZI_3=0 { export *[data]:2 R45_4; }
MemR45_4_offsZI_3:$(OB)R45_4+$(CB) is R45_4 & offsZI_3=1 { addr = R45_4 + 1; export *[data]:2 addr; }
MemR45_5:         $(OB)R45_5$(CB)  is R45_5              { export *[data]:2 R45_5; }
MemR45_5_offsZI_4:$(OB)R45_5$(CB)  is R45_5 & offsZI_4=0 { export *[data]:2 R45_5; }
MemR45_5_offsZI_4:$(OB)R45_5+$(CB) is R45_5 & offsZI_4=1 { addr = R45_5 + 1; export *[data]:2 addr; }
MemR45_8:         $(OB)R45_8$(CB)  is R45_8              { export *[data]:2 R45_8; }
MemR45_8_offsZI_1:$(OB)R45_8$(CB)  is R45_8 & offsZI_1=0 { export *[data]:2 R45_8; }
MemR45_8_offsZI_1:$(OB)R45_8+$(CB) is R45_8 & offsZI_1=1 { addr = R45_8 + 1; export *[data]:2 addr; }
MemR45_9:         $(OB)R45_9$(CB)  is R45_9              { export *[data]:2 R45_9; }
# no offsZI variant exists for MemR45_9

MemR04_1:         $(OB)R04_1$(CB)  is R04_1              { export *[data]:2 R04_1; }
MemR04_1_copy:    $(OB)R04_1$(CB)  is R04_1              { export *[data]:2 R04_1; }
MemR04_1_offsZI_0:$(OB)R04_1$(CB)  is R04_1 & offsZI_0=0 { export *[data]:2 R04_1; }
MemR04_1_offsZI_0:$(OB)R04_1+$(CB) is R04_1 & offsZI_0=1 { addr = R04_1 + 1; export *[data]:2 addr; }
MemR04_3:         $(OB)R04_3$(CB)  is R04_3              { export *[data]:2 R04_3; }
MemR04_3_copy:    $(OB)R04_3$(CB)  is R04_3              { export *[data]:2 R04_3; }
MemR04_3_offsZI_2:$(OB)R04_3$(CB)  is R04_3 & offsZI_2=0 { export *[data]:2 R04_3; }
MemR04_3_offsZI_2:$(OB)R04_3+$(CB) is R04_3 & offsZI_2=1 { addr = R04_3 + 1; export *[data]:2 addr; }
MemR04_4:         $(OB)R04_4$(CB)  is R04_4              { export *[data]:2 R04_4; }
MemR04_4_copy:    $(OB)R04_4$(CB)  is R04_4              { export *[data]:2 R04_4; }
MemR04_4_offsZI_3:$(OB)R04_4$(CB)  is R04_4 & offsZI_3=0 { export *[data]:2 R04_4; }
MemR04_4_offsZI_3:$(OB)R04_4+$(CB) is R04_4 & offsZI_3=1 { addr = R04_4 + 1; export *[data]:2 addr; }
MemR04_8:         $(OB)R04_8$(CB)  is R04_8              { export *[data]:2 R04_8; }
MemR04_8_copy:    $(OB)R04_8$(CB)  is R04_8              { export *[data]:2 R04_8; }
# no offsZI variant exists for MemR04_8

MemR0123_0:  $(OB)R0123_0$(CB)  is R0123_0  { export *[data]:2 R0123_0; }
MemR0123_4:  $(OB)R0123_4$(CB)  is R0123_4  { export *[data]:2 R0123_4; }
MemR0123_5:  $(OB)R0123_5$(CB)  is R0123_5  { export *[data]:2 R0123_5; }
MemR0123_8:  $(OB)R0123_8$(CB)  is R0123_8  { export *[data]:2 R0123_8; }
MemR0123_10: $(OB)R0123_10$(CB) is R0123_10 { export *[data]:2 R0123_10; }  # Only used by MemR0123_10_modrstepII2D2S0_1

# TODO: do we want to do something special with the brackets here? Right now it'd be [r0]+2 and maybe [r0+2] or just r0+2 would make more sense
# TODO: stepi0 or stepj0?
MemR0123_5_modrstepII2D2S0_1:MemR0123_5+       is MemR0123_5 & modrstepII2D2S0_1=0 & R0123_5          { R0123_5 = R0123_5 + 1; }
MemR0123_5_modrstepII2D2S0_1:MemR0123_5+2      is MemR0123_5 & modrstepII2D2S0_1=1 & R0123_5          { R0123_5 = R0123_5 + 2; }
MemR0123_5_modrstepII2D2S0_1:MemR0123_5-2      is MemR0123_5 & modrstepII2D2S0_1=2 & R0123_5          { R0123_5 = R0123_5 - 2; }
MemR0123_5_modrstepII2D2S0_1:MemR0123_5+stepi0 is MemR0123_5 & modrstepII2D2S0_1=3 & R0123_5 & stepi0 { R0123_5 = R0123_5 + stepi0; }

MemR0123_8_modrstepII2D2S0_0:MemR0123_8+       is MemR0123_8 & modrstepII2D2S0_0=0 & R0123_8          { R0123_8 = R0123_8 + 1; }
MemR0123_8_modrstepII2D2S0_0:MemR0123_8+2      is MemR0123_8 & modrstepII2D2S0_0=1 & R0123_8          { R0123_8 = R0123_8 + 2; }
MemR0123_8_modrstepII2D2S0_0:MemR0123_8-2      is MemR0123_8 & modrstepII2D2S0_0=2 & R0123_8          { R0123_8 = R0123_8 - 2; }
MemR0123_8_modrstepII2D2S0_0:MemR0123_8+stepi0 is MemR0123_8 & modrstepII2D2S0_0=3 & R0123_8 & stepi0 { R0123_8 = R0123_8 + stepi0; }

MemR0123_10_modrstepII2D2S0_0:MemR0123_10+       is MemR0123_10 & modrstepII2D2S0_0=0 & R0123_10          { R0123_10 = R0123_10 + 1; }
MemR0123_10_modrstepII2D2S0_0:MemR0123_10+2      is MemR0123_10 & modrstepII2D2S0_0=1 & R0123_10          { R0123_10 = R0123_10 + 2; }
MemR0123_10_modrstepII2D2S0_0:MemR0123_10-2      is MemR0123_10 & modrstepII2D2S0_0=2 & R0123_10          { R0123_10 = R0123_10 - 2; }
MemR0123_10_modrstepII2D2S0_0:MemR0123_10+stepi0 is MemR0123_10 & modrstepII2D2S0_0=3 & R0123_10 & stepi0 { R0123_10 = R0123_10 + stepi0; }

# Note: offsZIDZ has two instances of zero, but they are always paired with a stepII2D2S using the same bits which disambiguates
MemR0123_4_offsZIDZ_0:$(OB)R0123_4$(CB)  is R0123_4 & offsZIDZ_0=0 { export *[data]:2 R0123_4; }
MemR0123_4_offsZIDZ_0:$(OB)R0123_4+$(CB) is R0123_4 & offsZIDZ_0=1 { addr = R0123_4 + 1; export *[data]:2 addr; }
MemR0123_4_offsZIDZ_0:$(OB)R0123_4-$(CB) is R0123_4 & offsZIDZ_0=2 { addr = R0123_4 - 1; export *[data]:2 addr; }
MemR0123_4_offsZIDZ_0:$(OB)R0123_4$(CB)  is R0123_4 & offsZIDZ_0=3 { export *[data]:2 R0123_4; }

# TODO: stepi/stepj?
R0123_4_stepII2D2S_0:R0123_4+1      is R0123_4 & stepII2D2S_0=0          { R0123_4 = R0123_4 + 1; }
R0123_4_stepII2D2S_0:R0123_4+2      is R0123_4 & stepII2D2S_0=1          { R0123_4 = R0123_4 + 2; }
R0123_4_stepII2D2S_0:R0123_4-2      is R0123_4 & stepII2D2S_0=2          { R0123_4 = R0123_4 - 2; }
R0123_4_stepII2D2S_0:R0123_4+stepi0 is R0123_4 & stepII2D2S_0=3 & stepi0 { R0123_4 = R0123_4 + stepi0; }

R0123_8_stepII2D2S_0:R0123_8+1      is R0123_8 & stepII2D2S_0=0          { R0123_8 = R0123_8 + 1; }
R0123_8_stepII2D2S_0:R0123_8+2      is R0123_8 & stepII2D2S_0=1          { R0123_8 = R0123_8 + 2; }
R0123_8_stepII2D2S_0:R0123_8-2      is R0123_8 & stepII2D2S_0=2          { R0123_8 = R0123_8 - 2; }
R0123_8_stepII2D2S_0:R0123_8+stepi0 is R0123_8 & stepII2D2S_0=3 & stepi0 { R0123_8 = R0123_8 + stepi0; }

MemR0425_0:  $(OB)R0425_0$(CB)  is R0425_0  { export *[data]:2 R0425_0; }
MemR0425_2:  $(OB)R0425_2$(CB)  is R0425_2  { export *[data]:2 R0425_2; }
MemR0425_3:  $(OB)R0425_3$(CB)  is R0425_3  { export *[data]:2 R0425_3; }
MemR0425_4:  $(OB)R0425_4$(CB)  is R0425_4  { export *[data]:2 R0425_4; }
MemR0425_7:  $(OB)R0425_7$(CB)  is R0425_7  { export *[data]:2 R0425_7; }
MemR0425_8:  $(OB)R0425_8$(CB)  is R0425_8  { export *[data]:2 R0425_8; }
MemR0425_10: $(OB)R0425_10$(CB) is R0425_10 { export *[data]:2 R0425_10; }

# Note: offsZIDZ has two instances of zero, but they are always paired with a stepII2D2S using the same bits which disambiguates
MemR0425_2_offsZIDZ_0: $(OB)R0425_2$(CB)  is R0425_2 & offsZIDZ_0=0 { export *[data]:2 R0425_2; }
MemR0425_2_offsZIDZ_0: $(OB)R0425_2+$(CB) is R0425_2 & offsZIDZ_0=1 { addr = R0425_2 + 1; export *[data]:2 addr; }
MemR0425_2_offsZIDZ_0: $(OB)R0425_2-$(CB) is R0425_2 & offsZIDZ_0=2 { addr = R0425_2 - 1; export *[data]:2 addr; }
MemR0425_2_offsZIDZ_0: $(OB)R0425_2$(CB)  is R0425_2 & offsZIDZ_0=3 { export *[data]:2 R0425_2; }

MemR0425_4_offsZIDZ_2: $(OB)R0425_4$(CB)  is R0425_4 & offsZIDZ_2=0 { export *[data]:2 R0425_4; }
MemR0425_4_offsZIDZ_2: $(OB)R0425_4+$(CB) is R0425_4 & offsZIDZ_2=1 { addr = R0425_4 + 1; export *[data]:2 addr; }
MemR0425_4_offsZIDZ_2: $(OB)R0425_4-$(CB) is R0425_4 & offsZIDZ_2=2 { addr = R0425_4 - 1; export *[data]:2 addr; }
MemR0425_4_offsZIDZ_2: $(OB)R0425_4$(CB)  is R0425_4 & offsZIDZ_2=3 { export *[data]:2 R0425_4; }

MemR0425_8_offsZIDZ_2: $(OB)R0425_8$(CB)  is R0425_8 & offsZIDZ_2=0 { export *[data]:2 R0425_8; }
MemR0425_8_offsZIDZ_2: $(OB)R0425_8+$(CB) is R0425_8 & offsZIDZ_2=1 { addr = R0425_8 + 1; export *[data]:2 addr; }
MemR0425_8_offsZIDZ_2: $(OB)R0425_8-$(CB) is R0425_8 & offsZIDZ_2=2 { addr = R0425_8 - 1; export *[data]:2 addr; }
MemR0425_8_offsZIDZ_2: $(OB)R0425_8$(CB)  is R0425_8 & offsZIDZ_2=3 { export *[data]:2 R0425_8; }

MemR0425_10_offsZIDZ_5: $(OB)R0425_10$(CB)  is R0425_10 & offsZIDZ_5=0 { export *[data]:2 R0425_10; }
MemR0425_10_offsZIDZ_5: $(OB)R0425_10+$(CB) is R0425_10 & offsZIDZ_5=1 { addr = R0425_10 + 1; export *[data]:2 addr; }
MemR0425_10_offsZIDZ_5: $(OB)R0425_10-$(CB) is R0425_10 & offsZIDZ_5=2 { addr = R0425_10 - 1; export *[data]:2 addr; }
MemR0425_10_offsZIDZ_5: $(OB)R0425_10$(CB)  is R0425_10 & offsZIDZ_5=3 { export *[data]:2 R0425_10; }

# TODO: stepi/stepj?
R0425_2_stepII2D2S_0:R0425_2+1      is R0425_2 & stepII2D2S_0=0          { R0425_2 = R0425_2 + 1; }
R0425_2_stepII2D2S_0:R0425_2+2      is R0425_2 & stepII2D2S_0=1          { R0425_2 = R0425_2 + 2; }
R0425_2_stepII2D2S_0:R0425_2-2      is R0425_2 & stepII2D2S_0=2          { R0425_2 = R0425_2 - 2; }
R0425_2_stepII2D2S_0:R0425_2+stepi0 is R0425_2 & stepII2D2S_0=3 & stepi0 { R0425_2 = R0425_2 + stepi0; }

R0425_3_stepII2D2S_0:R0425_3+1      is R0425_3 & stepII2D2S_0=0          { R0425_3 = R0425_3 + 1; }
R0425_3_stepII2D2S_0:R0425_3+2      is R0425_3 & stepII2D2S_0=1          { R0425_3 = R0425_3 + 2; }
R0425_3_stepII2D2S_0:R0425_3-2      is R0425_3 & stepII2D2S_0=2          { R0425_3 = R0425_3 - 2; }
R0425_3_stepII2D2S_0:R0425_3+stepi0 is R0425_3 & stepII2D2S_0=3 & stepi0 { R0425_3 = R0425_3 + stepi0; }

R0425_4_stepII2D2S_2:R0425_4+1      is R0425_4 & stepII2D2S_2=0          { R0425_4 = R0425_4 + 1; }
R0425_4_stepII2D2S_2:R0425_4+2      is R0425_4 & stepII2D2S_2=1          { R0425_4 = R0425_4 + 2; }
R0425_4_stepII2D2S_2:R0425_4-2      is R0425_4 & stepII2D2S_2=2          { R0425_4 = R0425_4 - 2; }
R0425_4_stepII2D2S_2:R0425_4+stepi0 is R0425_4 & stepII2D2S_2=3 & stepi0 { R0425_4 = R0425_4 + stepi0; }

R0425_8_stepII2D2S_2:R0425_8+1      is R0425_8 & stepII2D2S_2=0          { R0425_8 = R0425_8 + 1; }
R0425_8_stepII2D2S_2:R0425_8+2      is R0425_8 & stepII2D2S_2=1          { R0425_8 = R0425_8 + 2; }
R0425_8_stepII2D2S_2:R0425_8-2      is R0425_8 & stepII2D2S_2=2          { R0425_8 = R0425_8 - 2; }
R0425_8_stepII2D2S_2:R0425_8+stepi0 is R0425_8 & stepII2D2S_2=3 & stepi0 { R0425_8 = R0425_8 + stepi0; }

R0425_10_stepII2D2S_5:R0425_10+1      is R0425_10 & stepII2D2S_5=0          { R0425_10 = R0425_10 + 1; }
R0425_10_stepII2D2S_5:R0425_10+2      is R0425_10 & stepII2D2S_5=1          { R0425_10 = R0425_10 + 2; }
R0425_10_stepII2D2S_5:R0425_10-2      is R0425_10 & stepII2D2S_5=2          { R0425_10 = R0425_10 - 2; }
R0425_10_stepII2D2S_5:R0425_10+stepi0 is R0425_10 & stepII2D2S_5=3 & stepi0 { R0425_10 = R0425_10 + stepi0; }

R0425_10_stepII2D2S_8:R0425_10+1      is R0425_10 & stepII2D2S_8=0          { R0425_10 = R0425_10 + 1; }
R0425_10_stepII2D2S_8:R0425_10+2      is R0425_10 & stepII2D2S_8=1          { R0425_10 = R0425_10 + 2; }
R0425_10_stepII2D2S_8:R0425_10-2      is R0425_10 & stepII2D2S_8=2          { R0425_10 = R0425_10 - 2; }
R0425_10_stepII2D2S_8:R0425_10+stepi0 is R0425_10 & stepII2D2S_8=3 & stepi0 { R0425_10 = R0425_10 + stepi0; }

MemR4567_4:  $(OB)MemR4567_4$(CB)  is MemR4567_4  { export *[data]:2 MemR4567_4; }
MemR4567_5:  $(OB)MemR4567_5$(CB)  is MemR4567_5  { export *[data]:2 MemR4567_5; }
MemR4567_8:  $(OB)MemR4567_8$(CB)  is MemR4567_8  { export *[data]:2 MemR4567_8; }
MemR4567_10: $(OB)MemR4567_10$(CB) is MemR4567_10 { export *[data]:2 MemR4567_10; }

# TODO: brackets; stepi0 or stepj0?
MemR4567_5_modrstepII2D2S0_3:MemR4567_5+       is MemR4567_5 & modrstepII2D2S0_3=0 & R4567_5          { R4567_5 = R4567_5 + 1; }
MemR4567_5_modrstepII2D2S0_3:MemR4567_5+2      is MemR4567_5 & modrstepII2D2S0_3=1 & R4567_5          { R4567_5 = R4567_5 + 2; }
MemR4567_5_modrstepII2D2S0_3:MemR4567_5-2      is MemR4567_5 & modrstepII2D2S0_3=2 & R4567_5          { R4567_5 = R4567_5 - 2; }
MemR4567_5_modrstepII2D2S0_3:MemR4567_5+stepj0 is MemR4567_5 & modrstepII2D2S0_3=3 & R4567_5 & stepj0 { R4567_5 = R4567_5 + stepj0; }

MemR4567_8_modrstepII2D2S0_3:MemR4567_8+       is MemR4567_8 & modrstepII2D2S0_3=0 & R4567_8          { R4567_8 = R4567_8 + 1; }
MemR4567_8_modrstepII2D2S0_3:MemR4567_8+2      is MemR4567_8 & modrstepII2D2S0_3=1 & R4567_8          { R4567_8 = R4567_8 + 2; }
MemR4567_8_modrstepII2D2S0_3:MemR4567_8-2      is MemR4567_8 & modrstepII2D2S0_3=2 & R4567_8          { R4567_8 = R4567_8 - 2; }
MemR4567_8_modrstepII2D2S0_3:MemR4567_8+stepj0 is MemR4567_8 & modrstepII2D2S0_3=3 & R4567_8 & stepj0 { R4567_8 = R4567_8 + stepj0; }

MemR4567_10_modrstepII2D2S0_5:MemR4567_10+       is MemR4567_10 & modrstepII2D2S0_5=0 & R4567_10          { R4567_10 = R4567_10 + 1; }
MemR4567_10_modrstepII2D2S0_5:MemR4567_10+2      is MemR4567_10 & modrstepII2D2S0_5=1 & R4567_10          { R4567_10 = R4567_10 + 2; }
MemR4567_10_modrstepII2D2S0_5:MemR4567_10-2      is MemR4567_10 & modrstepII2D2S0_5=2 & R4567_10          { R4567_10 = R4567_10 - 2; }
MemR4567_10_modrstepII2D2S0_5:MemR4567_10+stepj0 is MemR4567_10 & modrstepII2D2S0_5=3 & R4567_10 & stepj0 { R4567_10 = R4567_10 + stepj0; }

# Note: offsZIDZ has two instances of zero, but they are always paired with a stepII2D2S using the same bits which disambiguates
MemR4567_4_offsZIDZ_2:$(OB)R4567_4$(CB)  is R4567_4 & offsZIDZ_2=0 { export *[data]:2 R4567_4; }
MemR4567_4_offsZIDZ_2:$(OB)R4567_4+$(CB) is R4567_4 & offsZIDZ_2=1 { addr = R4567_4 + 1; export *[data]:2 addr; }
MemR4567_4_offsZIDZ_2:$(OB)R4567_4-$(CB) is R4567_4 & offsZIDZ_2=2 { addr = R4567_4 + 1; export *[data]:2 addr; }
MemR4567_4_offsZIDZ_2:$(OB)R4567_4$(CB)  is R4567_4 & offsZIDZ_2=3 { export *[data]:2 R4567_4; }

# TODO: stepi/stepj?
R4567_4_stepII2D2S_2:R4567_4+1      is R4567_4 & stepII2D2S_2=0          { R4567_4 = R4567_4 + 1; }
R4567_4_stepII2D2S_2:R4567_4+2      is R4567_4 & stepII2D2S_2=1          { R4567_4 = R4567_4 + 2; }
R4567_4_stepII2D2S_2:R4567_4-2      is R4567_4 & stepII2D2S_2=2          { R4567_4 = R4567_4 - 2; }
R4567_4_stepII2D2S_2:R4567_4+stepj0 is R4567_4 & stepII2D2S_2=3 & stepj0 { R4567_4 = R4567_4 + stepj0; }

R4567_8_stepII2D2S_2:R4567_8+1      is R4567_8 & stepII2D2S_2=0          { R4567_8 = R4567_8 + 1; }
R4567_8_stepII2D2S_2:R4567_8+2      is R4567_8 & stepII2D2S_2=1          { R4567_8 = R4567_8 + 2; }
R4567_8_stepII2D2S_2:R4567_8-2      is R4567_8 & stepII2D2S_2=2          { R4567_8 = R4567_8 - 2; }
R4567_8_stepII2D2S_2:R4567_8+stepj0 is R4567_8 & stepII2D2S_2=3 & stepj0 { R4567_8 = R4567_8 + stepj0; }

# Note: original formatting for these uses +s for stepZIDS=3;
# I've replaced it with +stepi (or +stepj when applicable).
# Also, when stepZIDS=0, these can be omitted, but doing that is difficult since
# there are cases where there are two of them (for instance,
# movd MemR0123@0,ProgMemR45@2 || R0123@0stepZIDS@3, R45@2stepZIDS@5),
# in which case the comma would need to be handled intelligently. It's easier to
# just always show it.

R0_stepZIDS_0:r0       is stepZIDS_0=0 & r0         {}
R0_stepZIDS_0:r0+1     is stepZIDS_0=1 & r0         { r0 = r0 + 1; }
R0_stepZIDS_0:r0-1     is stepZIDS_0=2 & r0         { r0 = r0 - 1; }
R0_stepZIDS_0:r0+stepi is stepZIDS_0=3 & r0 & stepi { r0 = r0 + stepi; }

R0_stepZIDS_3:r0       is stepZIDS_3=0 & r0         {}
R0_stepZIDS_3:r0+1     is stepZIDS_3=1 & r0         { r0 = r0 + 1; }
R0_stepZIDS_3:r0-1     is stepZIDS_3=2 & r0         { r0 = r0 - 1; }
R0_stepZIDS_3:r0+stepi is stepZIDS_3=3 & r0 & stepi { r0 = r0 + stepi; }

# Note: R0123@0stepZIDS@3 is always combined with R45@2stepZIDS@5, so bits 0-6 are always used (there's no gap).
R0123_0_stepZIDS_3:R0123_0       is stepZIDS_3=0 & R0123_0         {}
R0123_0_stepZIDS_3:R0123_0+1     is stepZIDS_3=1 & R0123_0         { R0123_0 = R0123_0 + 1; }
R0123_0_stepZIDS_3:R0123_0-1     is stepZIDS_3=2 & R0123_0         { R0123_0 = R0123_0 - 1; }
R0123_0_stepZIDS_3:R0123_0+stepi is stepZIDS_3=3 & R0123_0 & stepi { R0123_0 = R0123_0 + stepi; }

R0123_5_stepZIDS_7:R0123_5       is stepZIDS_7=0 & R0123_5         {}
R0123_5_stepZIDS_7:R0123_5+1     is stepZIDS_7=1 & R0123_5         { R0123_5 = R0123_5 + 1; }
R0123_5_stepZIDS_7:R0123_5-1     is stepZIDS_7=2 & R0123_5         { R0123_5 = R0123_5 - 1; }
R0123_5_stepZIDS_7:R0123_5+stepi is stepZIDS_7=3 & R0123_5 & stepi { R0123_5 = R0123_5 + stepi; }

R45_2_stepZIDS_5:R45_2       is stepZIDS_5=0 & R45_2         {}
R45_2_stepZIDS_5:R45_2+1     is stepZIDS_5=1 & R45_2         { R45_2 = R45_2 + 1; }
R45_2_stepZIDS_5:R45_2-1     is stepZIDS_5=2 & R45_2         { R45_2 = R45_2 - 1; }
R45_2_stepZIDS_5:R45_2+stepi is stepZIDS_5=3 & R45_2 & stepi { R45_2 = R45_2 + stepi; }

Rn_0_stepZIDS_3:Rn_0           is stepZIDS_3=0 & Rn_0             {}
Rn_0_stepZIDS_3:Rn_0+1         is stepZIDS_3=1 & Rn_0             { Rn_0 = Rn_0 + 1; }
Rn_0_stepZIDS_3:Rn_0-1         is stepZIDS_3=2 & Rn_0             { Rn_0 = Rn_0 - 1; }
# See note on step_Rn_0
Rn_0_stepZIDS_3:Rn_0+step_Rn_0 is stepZIDS_3=3 & Rn_0 & step_Rn_0 { Rn_0 = Rn_0 + step_Rn_0; }

# Nocash says modr seems to be just increment/decrement with optional modulo,
# though the official documentation has syntax as if they are memory accesses.
# http://problemkaputt.de/gbatek-dsi-teaklite-ii-operand-encoding.htm
MemRn_0_stepZIDS_3:$(OB)Rn_0$(CB)   is stepZIDS_3=0 & Rn_0 {}
MemRn_0_stepZIDS_3:$(OB)Rn_0+1$(CB) is stepZIDS_3=1 & Rn_0 { Rn_0 = Rn_0 + 1; }
MemRn_0_stepZIDS_3:$(OB)Rn_0-1$(CB) is stepZIDS_3=2 & Rn_0 { Rn_0 = Rn_0 - 1; }
MemRn_0_stepZIDS_3:$(OB)Rn_0+step_Rn_0$(CB) is stepZIDS_3=3 & Rn_0 & step_Rn_0 { Rn_0 = Rn_0 + step_Rn_0; }

# Note: we attach values 1 and 2 to stepII2 above

# ^R(\d+)@(\d+)stepII2@(\d+)$
# R\1_\2_stepII2_\3:R\1_\2+stepII2_\3 is R\1_\2 & stepII2_\3 { R\1_\2 = R\1_\2 + stepII2_\3; }
R01_2_stepII2_0:R01_2+stepII2_0 is R01_2 & stepII2_0 { R01_2 = R01_2 + stepII2_0; }
R01_5_stepII2_0:R01_5+stepII2_0 is R01_5 & stepII2_0 { R01_5 = R01_5 + stepII2_0; }
R01_8_stepII2_0:R01_8+stepII2_0 is R01_8 & stepII2_0 { R01_8 = R01_8 + stepII2_0; }
R01_9_stepII2_0:R01_9+stepII2_0 is R01_9 & stepII2_0 { R01_9 = R01_9 + stepII2_0; }
R01_3_stepII2_1:R01_3+stepII2_1 is R01_3 & stepII2_1 { R01_3 = R01_3 + stepII2_1; }
R01_4_stepII2_2:R01_4+stepII2_2 is R01_4 & stepII2_2 { R01_4 = R01_4 + stepII2_2; }
R01_5_stepII2_3:R01_5+stepII2_3 is R01_5 & stepII2_3 { R01_5 = R01_5 + stepII2_3; }
R01_0_stepII2_8:R01_0+stepII2_8 is R01_0 & stepII2_8 { R01_0 = R01_0 + stepII2_8; }

R45_2_stepII2_1:R45_2+stepII2_1 is R45_2 & stepII2_1 { R45_2 = R45_2 + stepII2_1; }
R45_5_stepII2_1:R45_5+stepII2_1 is R45_5 & stepII2_1 { R45_5 = R45_5 + stepII2_1; }
R45_8_stepII2_1:R45_8+stepII2_1 is R45_8 & stepII2_1 { R45_8 = R45_8 + stepII2_1; }
R45_3_stepII2_2:R45_3+stepII2_2 is R45_3 & stepII2_2 { R45_3 = R45_3 + stepII2_2; }
R45_4_stepII2_3:R45_4+stepII2_3 is R45_4 & stepII2_3 { R45_4 = R45_4 + stepII2_3; }
R45_5_stepII2_4:R45_5+stepII2_4 is R45_5 & stepII2_4 { R45_5 = R45_5 + stepII2_4; }
R45_9_stepII2_8:R45_9+stepII2_8 is R45_9 & stepII2_8 { R45_9 = R45_9 + stepII2_8; }
R45_0_stepII2_9:R45_0+stepII2_9 is R45_0 & stepII2_9 { R45_0 = R45_0 + stepII2_9; }

R04_1_stepII2_0:R04_1+stepII2_0 is R04_1 & stepII2_0 { R04_1 = R04_1 + stepII2_0; }
R04_3_stepII2_2:R04_3+stepII2_2 is R04_3 & stepII2_2 { R04_3 = R04_3 + stepII2_2; }
R04_4_stepII2_3:R04_4+stepII2_3 is R04_4 & stepII2_3 { R04_4 = R04_4 + stepII2_3; }
R04_8_stepII2_3:R04_8+stepII2_3 is R04_8 & stepII2_3 { R04_8 = R04_8 + stepII2_3; }
R04_8_stepII2_5:R04_8+stepII2_5 is R04_8 & stepII2_5 { R04_8 = R04_8 + stepII2_5; }

# TODO: stepi/stepj? Also nocash doc has a stray quote here
R04_4_stepD2S_3:R04_3-2     is R04_3 & stepD2S_3=0         { R04_3 = R04_3 - 2; }
R04_4_stepD2S_3:R04_3+stepi is R04_3 & stepD2S_3=1 & stepi { R04_3 = R04_3 + stepi; }

MemR0425_7_offsZI_6: $(OB)R0425_7$(CB)  is R0425_7 & offsZI_6=0 { export *[data]:2 R0425_7; }
MemR0425_7_offsZI_6: $(OB)R0425_7+$(CB) is R0425_7 & offsZI_6=1 { addr = R0425_7; export *[data]:2 addr; }

R0425_7_stepII2_6:R0425_7+stepII2_6 is R0425_7 & stepII2_6 { R0425_7 = R0425_7 + stepII2_6; }

Imm2u_0:imm2u_0 is imm2u_0 { local tmp:2 = imm2u_0; export tmp; }
Imm2u_1:imm2u_1 is imm2u_1 { local tmp:2 = imm2u_1; export tmp; }
Imm4u_0:imm4u_0 is imm4u_0 { local tmp:2 = imm4u_0; export tmp; }
Imm5u_0:imm5u_0 is imm5u_0 { local tmp:2 = imm5u_0; export tmp; }
Imm5s_0:imm5s_0 is imm5s_0 { local tmp:2 = imm5s_0; export tmp; }
Imm6s_0:imm6s_0 is imm6s_0 { local tmp:2 = imm6s_0; export tmp; }
Imm7s_0:imm7s_0 is imm7s_0 { local tmp:2 = imm7s_0; export tmp; }
Imm8s_0:imm8s_0 is imm8s_0 { local tmp:2 = imm8s_0; export tmp; }
Imm8u_0:imm8u_0 is imm8u_0 { local tmp:2 = imm8u_0; export tmp; }
Imm9u_0:imm9u_0 is imm9u_0 { local tmp:2 = imm9u_0; export tmp; }
Imm16:expanded_imm is expanded_imm { local tmp:2 = expanded_imm; export tmp; }

# Comments are from http://problemkaputt.de/gbatek.htm#dsiteakliteiiinstructionsetencoding
# Note that "add  MemRn@0, Ax@8 || Rn@0stepZIDS@3" means two actions are performed by the instruction:
# First, it adds; then it applies a step (which is optional). The || does NOT indicate a choice of
# one action or the other; for instance 6FA0 always adds the high parts and subtracts the low parts.

# Base  Ver Opcode (with parameter bits located at @bitnumber and up)

# D4FBh TL  add  MemImm16@16, Ax@8
op:"add" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xFB; MemImm16 { Ax_8 = Ax_8 + sext(MemImm16); }
# A600h TL  add  MemImm8@0, Ax@8
op:"add" MemImm8_0, Ax_8 is opcode_9_15=(0xA6>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 + sext(MemImm8_0); }
# 86C0h TL  add  Imm16@16, Ax@8
op:"add" Imm16, Ax_8 is opcode_9_15=(0x86>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 + sext(Imm16); }
# C600h TL  add  Imm8u@0, Ax@8
op:"add" Imm8u_0, Ax_8 is opcode_9_15=(0xC6>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 + zext(Imm8u_0); } # Assuming u is for unsigned
# D4DBh TL  add  MemR7Imm16@16, Ax@8
op:"add" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDB; MemR7Imm16 { Ax_8 = Ax_8 + sext(MemR7Imm16); }
# 4600h TL  add  MemR7Imm7s@0, Ax@8
op:"add" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x46>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 + sext(MemR7Imm7s_0); }
# 8680h TL  add  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"add" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x86>>1) & Ax_8 & opcode_5_7=(0x80>>5) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 + sext(MemRn_0); build Rn_0_stepZIDS_3; }
# 86A0h TL  add  RegisterP0@0, Ax@8
op:"add" Register_P_0, Ax_8 is opcode_9_15=(0x86>>1) & Ax_8 & opcode_5_7=(0xA0>>5) & Register_P_0 { Ax_8 = Ax_8 + sext(Register_P_0); }
@ifdef TEAK_LITE_2
# D2DAh TL2 add  Ab@10, Bx@0
op:"add" Ab_10, Bx_0 is opcode_12_15=0xD & Ab_10 & opcode_1_9=(0x2DA>>1) & Bx_0 { Bx_0 = Bx_0 + Ab_10; }
# 5DF0h TL2 add  Bx@1, Ax@0
op:"add" Bx_1, Ax_0 is opcode_2_15=(0x5DF0>>2) & Bx_1 & Ax_0 { Ax_0 = Ax_0 + Bx_1; }
# 9070h TL2 add  MemR01@8, sv, Abh@2 || sub MemR01@8offsZI@0, sv, Abl@2
#            || mov Abl@2, MemR45@8 || R01@8stepII2@0, R45@8stepII2@1
op:"add" MemR01_8, sv, Abh_2 || "sub" MemR01_8_offsZI_0, sv_copy, Abl_2 || "mov" Abl_2_copy, MemR45_8 || R01_8_stepII2_0, R45_8_stepII2_1
	is opcode_9_15=(0x90>>1) & MemR01_8 & opcode_3_7=(0x70>>3) & Abh_2 & R45_8_stepII2_1 & R01_8_stepII2_0
	& MemR45_8 & Abl_2 & MemR01_8_offsZI_0 & sv & sv_copy & Abl_2_copy
{
	Abh_2 = Abh_2 + MemR01_8; # TODO: sv?
	Abl_2 = Abl_2 - MemR01_8_offsZI_0; # TODO: sv?
	MemR45_8 = Abl_2;
	build R01_8_stepII2_0;
	build R45_8_stepII2_1;
}
# 5DB0h TL2 add  MemR04@1, sv, Abh@2 || sub MemR04@1offsZI@0, sv, Abl@2
#            || R04@1stepII2@0
op:"add" MemR04_1, sv, Abh_2 || "sub" MemR04_1_offsZI_0, sv_copy, Abl_2 || R04_1_stepII2_0
	is opcode_3_15=(0x5DB0>>3) & Abh_2 & MemR04_1 & MemR04_1_offsZI_0
	& Abl_2 & R04_1_stepII2_0 & sv & sv_copy
{
	Abh_2 = Abh_2 + MemR04_1; # TODO: sv?
	Abl_2 = Abl_2 - MemR04_1_offsZI_0; # TODO: sv?
	build R04_1_stepII2_0;
}
# 6F80h TL2 add  MemR45@2, MemR01@2, Abh@3
#            || add MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"add" MemR45_2, MemR01_2, Abh_3 || "add" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_4_15=0x6F8 & Abh_3 & MemR45_2 & MemR45_2_offsZI_1 & MemR01_2_offsZI_0
	& Abl_3 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0
{
	Abh_3 = MemR45_2 + MemR01_2;
	Abl_3 = MemR45_2_offsZI_1 + MemR01_2_offsZI_0;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 6FA0h TL2 add  MemR45@2, MemR01@2, Abh@3
#            || sub MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"add" MemR45_2, MemR01_2, Abh_3 || "sub" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_4_15=0x6FA & Abh_3 & MemR45_2 & MemR45_2_offsZI_1 & MemR01_2_offsZI_0
	& Abl_3 & MemR01_2 & R01_2_stepII2_0 & R45_2_stepII2_1
{
	Abh_3 = MemR45_2 + MemR01_2;
	Abl_3 = MemR45_2_offsZI_1 - MemR01_2_offsZI_0;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 5E30h TL2 add  MemR45@8, sv, Abh@2 || sub MemR45@8offsZI@1, sv, Abl@2
#            || mov Abl@2, MemR01@8 || R01@8stepII2@0, R45@8stepII2@1
op:"add" MemR45_8, sv, Abh_2 || "sub" MemR45_8_offsZI_1, sv_copy, Abl_2 || "mov" Abl_2_copy, MemR01_8 || R01_8_stepII2_0, R45_8_stepII2_1
	is opcode_9_15=(0x5E >> 1) & MemR45_8 & opcode_3_7=(0x30>>3) & Abh_2 & R01_8_stepII2_0 & R45_8_stepII2_1
	& MemR45_8_offsZI_1 & MemR01_8 & Abl_2 & Abl_2_copy & sv & sv_copy
{
	Abh_2 = Abh_2 + MemR45_8; # TODO: sv?
	Abl_2 = Abl_2 - MemR45_8_offsZI_1; # TODO: sv?
	MemR01_8 = Abl_2;
	build R01_8_stepII2_0;
	build R45_8_stepII2_1;
}
# 5DC0h TL2 add  p0, p1, Ab@2
op:"add" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=0 & p0 & p1 { Ab_2 = zext(p0 + p1); }  # TODO: truncation? and does this just add p0 and p1
# D782h TL2 add  p1, Ax@0
op:"add" p1, Ax_0 is opcode_1_15=(0xD782>>1) & Ax_0 & p1 { Ax_0 = Ax_0 + zext(p1); }
# 5DF8h TL2 add  Px@1, Bx@0
op:"add" Px_1, Bx_0 is opcode_2_15=(0x5DF8>>2) & Px_1 & Bx_0 { Bx_0 = Bx_0 + zext(Px_1); }
# D38Bh TL2 add  r6, Ax@4
op:"add" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xB & r6 { Ax_4 = Ax_4 + sext(r6); }
# 4590h TL2 add3 p0, p1, Ab@2
# TODO: what do these actually do?
op:"add3" p0, p1, Ab_2 is opcode_3_15=(0x4590>>3) & Ab_2 & opcode_0_1=0 & p0 & p1 unimpl
# 4592h TL2 add3a p0, p1, Ab@2
op:"add3a" p0, p1, Ab_2 is opcode_3_15=(0x4592>>3) & Ab_2 & opcode_0_1=2 & p0 & p1 unimpl
# 4593h TL2 add3aa p0, p1, Ab@2
op:"add3aa" p0, p1, Ab_2 is opcode_3_15=(0x4593>>3) & Ab_2 & opcode_0_1=3 & p0 & p1 unimpl
# 5DC1h TL2 adda p0, p1, Ab@2
op:"adda" p0, p1, Ab_2 is opcode_3_15=(0x5DC1>>3) & Ab_2 & opcode_0_1=1 & p0 & p1 unimpl
@endif
# TODO: how does addh differ from add? Does it target the high part of the accumulator?
# B200h TL  addh MemImm8@0, Ax@8
op:"addh" MemImm8_0, Ax_8 is opcode_9_15=(0xB2>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 + sext(MemImm8_0); }
# 9280h TL  addh MemRn@0, Ax@8 || Rn@0stepZIDS@3
# TODO
# 92A0h TL  addh Register@0, Ax@8
op:"addh" Register_0, Ax_8 is opcode_9_15=(0x92>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 { Ax_8 = Ax_8 + sext(Register_0); }
@ifdef TEAK_LITE_2
# 9464h TL2 addh r6, Ax@0
op:"addh" r6, Ax_0 is opcode_1_15=(0x9464>>1) & Ax_0 & r6 { Ax_0 = Ax_0 + sext(r6); }
# 90E0h TL2 addhp MemR0425@2, Px@4, Ax@8 || R0425@2stepII2D2S@0 ;p=ProgMem? Px?
# TODO
@endif
# TODO: how does addl differ from add? Does it target the low part of the accumulator?
# B400h TL  addl MemImm8@0, Ax@8
op:"addl" MemImm8_0, Ax_8 is opcode_9_15=(0xB4>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 + sext(MemImm8_0); }
# 9480h TL  addl MemRn@0, Ax@8 || Rn@0stepZIDS@3
# TODO
# 94A0h TL  addl Register@0, Ax@8
op:"addl" Register_0, Ax_8 is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 { Ax_8 = Ax_8 + sext(Register_0); }
@ifdef TEAK_LITE_2
# 9466h TL2 addl r6, Ax@0
op:"addl" r6, Ax_0 is opcode_1_15=(0x9466>>1) & Ax_0 & r6 { Ax_0 = Ax_0 + sext(r6); }
# 906Ch TL2 addsub  p0, p1, Ab@0
op:"addsub" p0, p1, Ab_0 is opcode_2_15=(0x906C>>2) & Ab_0 & p0 & p1 unimpl
# 49C2h TL2 addsub  p1, p0, Ab@4
op:"addsub" p1, p0, Ab_4 is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_0_3=2 & p1 & p0 unimpl
# 916Ch TL2 addsuba p0, p1, Ab@0
op:"addsuba" p0, p1, Ab_0 is opcode_2_15=(0x916C>>2) & Ab_0 & p0 & p1 unimpl
# 49C3h TL2 addsuba p1, p0, Ab@4
op:"addsub" p1, p0, Ab_4 is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_0_3=3 & p1 & p0 unimpl
@endif
# E700h TL  addv Imm16@16, MemImm8@0
op:"addv" Imm16, MemImm8_0 is opcode_8_15=0xE7 & MemImm8_0; Imm16 { MemImm8_0 = MemImm8_0 + Imm16; }
# 86E0h TL  addv Imm16@16, MemRn@0 || Rn@0stepZIDS@3
# TODO
# 87E0h TL  addv Imm16@16, Register@0
op:"addv" Imm16, Register_0 is opcode_5_15=(0x87E>>1) & Register_0; Imm16 { Register_0 = Register_0 + Imm16; }
@ifdef TEAK_LITE_2
# 47BBh TL2 addv Imm16@16, r6
op:"addv" Imm16, r6 is opcode_0_15=0x47BB & r6; Imm16 { r6 = r6 + Imm16; }
@endif
# D4F9h TL  and  MemImm16@16, Ax@8
# TODO: what parts are affected by the and? As-is this zeros most of the accumulator
op:"and" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xF9; MemImm16 { Ax_8 = Ax_8 & zext(MemImm16); }
# A200h TL  and  MemImm8@0, Ax@8
op:"and" MemImm8_0, Ax_8 is opcode_9_15=(0xA2>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 & zext(MemImm8_0); }
# 82C0h TL  and  Imm16@16, Ax@8
op:"and" Imm16, Ax_8 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 & zext(Imm16); }
# C200h TL  and  Imm8u@0, Ax@8
op:"and" Imm8u_0, Ax_8 is opcode_9_15=(0xC2>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 & zext(Imm8u_0); }
# D4D9h TL  and  MemR7Imm16@16, Ax@8
op:"and" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xD9; MemR7Imm16 { Ax_8 = Ax_8 & zext(MemR7Imm16); }
# 4200h TL  and  MemR7Imm7s@0, Ax@8
op:"and" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x42>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 & zext(MemR7Imm7s_0); }
# 8280h TL  and  MemRn@0, Ax@8 || Rn@0stepZIDS@3
# TODO
# 82A0h TL  and  RegisterP0@0, Ax@8
op:"and" Register_P_0, Ax_8 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_P_0 { Ax_8 = Ax_8 & zext(Register_P_0); }
@ifdef TEAK_LITE_2
# 6770h TL2 and  Ab@2, Ab@0, Ax@12                ;TL2 only
op:"and" Ab_2, Ab_0, Ax_12 is opcode_13_15=(0x6>>1) & Ax_12 & opcode_4_11=0x77 & Ab_2 & Ab_0 { Ax_12 = Ab_2 & Ab_0; }
# D389h TL2 and  r6, Ax@4
op:"and" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=9 & r6 { Ax_4 = Ax_4 & zext(r6); }
@endif
# 4B80h TL  banke BankFlags6@0  ;{r0}{,r1}{,r4}{,cfgi}{,r7}{,cfgj}
# Simplified to joining with spaces instead of commas, as that'd require extra checking.
# Perhaps we should show r0b etc here, but eh.
BankFlag_r0:   is BankFlags_r0=0 {}
BankFlag_r0:r0 is BankFlags_r0=1 & r0 { local tmp = r0; r0 = r0b; r0b = tmp; }
BankFlag_r1:   is BankFlags_r1=0 {}
BankFlag_r1:r1 is BankFlags_r1=1 & r1 { local tmp = r1; r1 = r1b; r1b = tmp; }
BankFlag_r4:   is BankFlags_r4=0 {}
BankFlag_r4:r4 is BankFlags_r4=1 & r4 { local tmp = r4; r4 = r4b; r4b = tmp; }
BankFlag_cfgi:     is BankFlags_cfgi=0 {}
BankFlag_cfgi:cfgi is BankFlags_cfgi=1 & cfgi { local tmp = cfgi; cfgi = cfgib; cfgib = tmp; }
BankFlag_r7:   is BankFlags_r7=0 {}
BankFlag_r7:r7 is BankFlags_r7=1 & r7 { local tmp = r7; r7 = r7b; r7b = tmp; }
BankFlag_cfgj:     is BankFlags_cfgj=0 {}
BankFlag_cfgj:cfgj is BankFlags_cfgj=1 & cfgj { local tmp = cfgj; cfgj = cfgjb; cfgjb = tmp; }
op:"banke" BankFlag_r0 BankFlag_r1 BankFlag_r4 BankFlag_cfgi BankFlag_r7 BankFlag_cfgj is opcode_6_15=(0x4B8>>2) & BankFlag_r0 & BankFlag_r1 & BankFlag_r4 & BankFlag_cfgi & BankFlag_r7 & BankFlag_cfgj {
	build BankFlag_r0;
	build BankFlag_r1;
	build BankFlag_r4;
	build BankFlag_cfgi;
	build BankFlag_r7;
	build BankFlag_cfgj;
}
@ifdef TEAK_LITE_2
# 8CDFh TL2 bankr       ;without operand ?
op:"bankr" is opcode_0_15=0x8CDF unimpl # Note: 8CDE is undefined
# 8CDCh TL2 bankr Ar@0
op:"bankr" Ar_0 is opcode_1_15=(0x8CDC>>1) & Ar_0 unimpl
# 8CD0h TL2 bankr Ar@2, Arp@0
op:"bankr" Ar_2, Arp_0 is opcode_3_15=(0x8CD0>>3) & Ar_2 & Arp_0 unimpl
# 8CD8h TL2 bankr Arp@0
op:"bankr" Arp_0 is opcode_2_15=(0x8CD8>>2) & Arp_0 unimpl
# 5EB8h TL2 bitrev Rn@0
op:"bitrev" Rn_0 is opcode_3_15=(0x5EB8>>3) & Rn_0 unimpl
# D7E8h TL2 bitrev Rn@0, dbrv
op:"bitrev" Rn_0, "dbrv" is opcode_3_15=(0xD7E8>>3) & Rn_0 unimpl
# D7E0h TL2 bitrev Rn@0, ebrv
op:"bitrev" Rn_0, "ebrv" is opcode_3_15=(0xD7E0>>3) & Rn_0 unimpl
@endif
# 5C00h TL  bkrep NoReverse, Imm8u@0, Address16@16
op:"bkrep" Imm8u_0, Address16 is opcode_8_15=0x5C & Imm8u_0; Address16 & Address16After & CurLC
[
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(Address16After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(Address16, hasloopjumpback);
	globalset(Address16, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Imm8u_0;
}
# 5D00h TL  bkrep NoReverse, Register@0, Address18@16and5
op:"bkrep" Register_0, Address18_16and5 is opcode_7_15=(0x5D0>>3) ... & Address18_16and5 & Address18_16and5After & Register_0 ... & CurLC
[
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(Address18_16and5After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(Address18_16and5, hasloopjumpback);
	globalset(Address18_16and5, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Register_0;
}
@ifdef TEAK_LITE_2
# 8FDCh TL2 bkrep NoReverse, r6, Address18@16and0
op:"bkrep" r6, Address18_16and0 is opcode_2_15=(0x8FDC>>2) ... & Address18_16and0 & Address18_16and0After & r6 & CurLC
[
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(Address18_16and0After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(Address18_16and0, hasloopjumpback);
	globalset(Address18_16and0, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = r6;
}
# DA9Ch TL2 bkreprst MemR0425@0
# https://github.com/wwylele/teakra/blob/01db7cdd00aabcce559a8dddce8798dabb71949b/src/interpreter.h#L993-L1027
# This pushes to the bottom of the block repeat stack, but the top of the stack (the current loop) remains the same.
# So we don't need to mess with context variables or anything here.
define pcodeop bkreprst;
op:"bkreprst" MemR0425_0 is opcode_2_15=(0xDA9C>>2) & MemR0425_0 & R0425_0 {
	local flag:2 = MemR0425_0;
	R0425_0 = R0425_0 + 1;
	local end:3 = zext(MemR0425_0) | (((zext(flag) >> 8) & 3) << 16);
	R0425_0 = R0425_0 + 1;
	local start:3 = zext(MemR0425_0) | ((zext(flag) & 3) << 16);
	R0425_0 = R0425_0 + 1;
	local counter:2 = MemR0425_0;
	R0425_0 = R0425_0 + 1;

	bkreprst(flag, end, start, counter);
}
# 5F48h TL2 bkreprst MemSp, Unused2@0
op:"bkreprst" MemSp is MemSp & opcode_2_15=(0x5F48>>2) & unused_0_1 {
	local flag:2 = MemSp;
	sp = sp + 1;
	local end:3 = zext(MemSp) | (((zext(flag) >> 8) & 3) << 16);
	sp = sp + 1;
	local start:3 = zext(MemSp) | ((zext(flag) & 3) << 16);
	sp = sp + 1;
	local counter:2 = MemSp;
	sp = sp + 1;

	bkreprst(flag, end, start, counter);
}
define pcodeop bkrepsto_lp;
define pcodeop bkrepsto_end;
define pcodeop bkrepsto_start;
define pcodeop bkrepsto_counter;
# DADCh TL2 bkrepsto MemR0425@0, Unused1@10
op:"bkrepsto" MemR0425_0 is opcode_11_15=(0xDA>>3) & unused_10_10 & opcode_2_9=(0x2DC>>2) & MemR0425_0 & R0425_0 {
	local counter:2 = bkrepsto_counter();
	local start:3 = bkrepsto_start();
	local end:3 = bkrepsto_end();
	local start_end_bits = ((start >> 16) & 3) | (((end >> 16) & 3) << 8);
	local flag:2 = (bkrepsto_lp() << 15) | start_end_bits:2;

	R0425_0 = R0425_0 - 1;
	MemR0425_0 = counter;
	R0425_0 = R0425_0 - 1;
	MemR0425_0 = start:2;
	R0425_0 = R0425_0 - 1;
	MemR0425_0 = end:2;
	R0425_0 = R0425_0 - 1;
	MemR0425_0 = flag;
}
# 9468h TL2 bkrepsto MemSp, Unused3@0
op:"bkrepsto" MemSp is opcode_3_15=(0x9468>>3) & unused_0_2 & MemSp {
	local counter:2 = bkrepsto_counter();
	local start:3 = bkrepsto_start();
	local end:3 = bkrepsto_end();
	local start_end_bits = ((start >> 16) & 3) | (((end >> 16) & 3) << 8);
	local flag:2 = (bkrepsto_lp() << 15) | start_end_bits:2;

	sp = sp - 1;
	MemSp = counter;
	sp = sp - 1;
	MemSp = start:2;
	sp = sp - 1;
	MemSp = end:2;
	sp = sp - 1;
	MemSp = flag;
}
@endif
# 4180h TL  br   Address18@16and4, Cond@0
op:"br" Address18_16and4, Cond_0 is opcode_6_15=(0x418>>2) ... & Cond_0 ... & Address18_16and4 {
	if (Cond_0) goto Address18_16and4;
}
op:"br" Address18_16and4 is opcode_6_15=(0x418>>2) ... & cond_0=0 ... & Address18_16and4 { goto Address18_16and4; }
# D3C0h TL  break               ;break
# Only changes the loop stack depth; no jumping
# https://github.com/wwylele/teakra/blob/01db7cdd00aabcce559a8dddce8798dabb71949b/src/interpreter.h#L1111-L1116
op:"break" is opcode_0_15=0xD3C0 [
	loopstackdepth = loopstackdepth - 1;
	globalset(inst_next, loopstackdepth);
] {}
# 5000h TL  brr  RelAddr7@4, Cond@0
op:"brr" RelAddr7_4, Cond_0 is opcode_11_15=(0x50>>3) & RelAddr7_4 & Cond_0 {
	if (Cond_0) goto RelAddr7_4;
}
op:"brr" RelAddr7_4 is opcode_11_15=(0x50>>3) & RelAddr7_4 & cond_0=0 { goto RelAddr7_4; }
# 41C0h TL  call Address18@16and4, Cond@0
op:"call" Address18_16and4, Cond_0 is opcode_6_15=(0x41C>>2) ... & Cond_0 ... & Address18_16and4 {
	if (!Cond_0) goto inst_next;
	call Address18_16and4;
}
op:"call" Address18_16and4 is opcode_6_15=(0x41C>>2) ... & cond_0=0 ... & Address18_16and4 { call Address18_16and4; }
# D480h TL  calla Axl@8
op:"calla" Axl_8 is opcode_9_15=(0xD4>>1) & Axl_8 & opcode_0_7=0x80 {
	call [Axl_8];
}
@ifdef TEAK_LITE_2
# D381h TL2 calla Ax@4
op:"calla" Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=1 {
	call [Ax_4];
}
@endif
# 1000h TL  callr RelAddr7@4, Cond@0
op:"brr" RelAddr7_4, Cond_0 is opcode_11_15=(0x10>>3) & RelAddr7_4 & Cond_0 {
	if (!Cond_0) goto inst_next;
	call RelAddr7_4;
}
op:"brr" RelAddr7_4 is opcode_11_15=(0x10>>3) & RelAddr7_4 & cond_0=0 { call RelAddr7_4; }
@ifdef TEAK_LITE_2
# 9068h TL2 cbs  Axh@0, Axh@not0, r0, ge
op:"cbs" Axh_0, Axh_Not0, r0, "ge" is opcode_1_15=(0x9068>>1) & Axh_0 & Axh_Not0 & r0 unimpl
# 9168h TL2 cbs  Axh@0, Axh@not0, r0, gt
op:"cbs" Axh_0, Axh_Not0, r0, "gt" is opcode_1_15=(0x9168>>1) & Axh_0 & Axh_Not0 & r0 unimpl
# D49Eh TL2 cbs  Axh@8, Bxh@5, r0, ge
op:"cbs" Axh_8, Bxh_5, r0, "ge" is opcode_9_15=(0xD4>>1) & Axh_8 & opcode_6_7=(0x9>>2) & Bxh_5 & opcode_0_4=(0x1E) & r0 unimpl
# D49Fh TL2 cbs  Axh@8, Bxh@5, r0, gt
op:"cbs" Axh_8, Bxh_5, r0, "gt" is opcode_9_15=(0xD4>>1) & Axh_8 & opcode_6_7=(0x9>>2) & Bxh_5 & opcode_0_4=(0x1F) & r0 unimpl
# D5C0h TL2 cbs  MemR01@2, MemR45@2, ge || R01@2stepII2@0, R45@2stepII2@1
op:"cbs" MemR01_2, MemR45_2, "ge" || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_3_15=(0xD5C0>>3) & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
# D5C8h TL2 cbs  MemR01@2, MemR45@2, gt || R01@2stepII2@0, R45@2stepII2@1
op:"cbs" MemR01_2, MemR45_2, "gt" || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_3_15=(0xD5C8>>3) & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
@endif
# E500h TL  chng Imm16@16, MemImm8@0
op:"chng" Imm16, MemImm8_0 is opcode_8_15=0xE5 & MemImm8_0; Imm16 unimpl
# 84E0h TL  chng Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"chng" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x84E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 85E0h TL  chng Imm16@16, Register@0
op:"chng" Imm16, Register_0 is opcode_5_15=(0x85E>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# 47BAh TL2 chng Imm16@16, r6
op:"chng" Imm16, r6 is opcode_0_15=0x47BA & r6; Imm16 unimpl
# 0038h TL2 chng Imm16@16, SttMod@0
op:"chng" Imm16, SttMod_0 is opcode_3_15=(0x0038>>3) & SttMod_0; Imm16 unimpl
@endif
# 6760h TL  clr  Implied ConstZero, Ax@12, Cond@0  ;aX=0
op:"clr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x76) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = 0;
}
op:"clr" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x76) & cond_0=0 { Ax_12 = 0; }
# 6F60h TL  clr  Implied ConstZero, Bx@12, Cond@0  ;bX=0
op:"clr" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF6) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = 0;
}
op:"clr" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF6) & cond_0=0 { Bx_12 = 0; }
@ifdef TEAK_LITE_2
# 8ED0h TL2 clr  Implied ConstZero, Ab@2, Ab@0
# TODO: What if Ab_2 == Ab_0? Is that something else?
op:"clr" Ab_2, Ab_0 is opcode_4_15=0x8ED & Ab_2 & Ab_0 {
	Ab_2 = 0;
	Ab_0 = 0;
}
# 5DFEh TL2 clrp p0
op:"clrp" p0 is opcode_0_15=0x5DFE & p0 {
	p0 = 0;
}
# 5DFFh TL2 clrp p0, p1
op:"clrp" p0, p1 is opcode_0_15=0x5DFF & p0 & p1 {
	p0 = 0;
	p1 = 0;
}
# 5DFDh TL2 clrp p1
op:"clrp" p1 is opcode_0_15=0x5DFD & p1 {
	p1 = 0;
}
@endif
# 67C0h TL  clrr Implied Const8000h, Ax@12, Cond@0 ;aX=8000h
op:"clrr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7C & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = 0x8000;
}
op:"clrr" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7C & cond_0=0 { Ax_12 = 0x8000; }
@ifdef TEAK_LITE_2
# 6F70h TL2 clrr Implied Const8000h, Bx@12, Cond@0 ;bX=8000h
op:"clrr" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF7 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = 0x8000;
}
op:"clrr" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF7 & cond_0=0 { Bx_12 = 0x8000; }
# 8DD0h TL2 clrr Implied Const8000h, Ab@2, Ab@0
op:"clrr" Ab_2, Ab_0 is opcode_4_15=0x8DD & Ab_2 & Ab_0 {
	Ab_2 = 0x8000;
	Ab_0 = 0x8000;
}
@endif
# D4FEh TL  cmp  MemImm16@16, Ax@8
op:"cmp" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xFE; MemImm16 unimpl
# AC00h TL  cmp  MemImm8@0, Ax@8
op:"cmp" MemImm8_0, Ax_8 is opcode_9_15=(0xAC>>1) & Ax_8 & MemImm8_0 unimpl
# 8CC0h TL  cmp  Imm16@16, Ax@8
op:"cmp" Imm16, Ax_8 is opcode_9_15=(0x8C>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 unimpl
# CC00h TL  cmp  Imm8u@0, Ax@8
op:"cmp" Imm8u_0, Ax_8 is opcode_9_15=(0xCC>>1) & Ax_8 & Imm8u_0 unimpl
# D4DEh TL  cmp  MemR7Imm16@16, Ax@8
op:"cmp" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDE; MemR7Imm16 unimpl
# 4C00h TL  cmp  MemR7Imm7s@0, Ax@8
op:"cmp" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x4C>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 unimpl
# 8C80h TL  cmp  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"cmp" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x8C>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 8CA0h TL  cmp  RegisterP0@0, Ax@8
op:"cmp" Register_P_0, Ax_8 is opcode_9_15=(0x8C)>>1 & Ax_8 & opcode_5_7=(0xA>>1) & Register_P_0 unimpl
@ifdef TEAK_LITE_2
# 4D8Ch TL2 cmp  Ax@1, Bx@0
op:"cmp" Ax_1, Bx_0 is opcode_2_15=(0x4D8C>>2) & Ax_1 & Bx_0 unimpl
# D483h TL2 cmp  b0, b1
op:"cmp" b0, b1 is opcode_0_15=0xD483 & b0 & b1 unimpl
# D583h TL2 cmp  b1, b0
op:"cmp" b1, b0 is opcode_0_15=0xD583 & b0 & b1 unimpl
# DA9Ah TL2 cmp  Bx@10, Ax@0
op:"cmp" Bx_10, Ax_0 is opcode_11_15=(0xDA>>3) & Bx_10 & opcode_1_9=(0x29A>>1) & Ax_0 unimpl
# 8B63h TL2 cmp  p1, Ax@4
op:"cmp" p1, Ax_4 is opcode_5_15=(0x8B6>>1) & Ax_4 & opcode_0_3=0x3 & p1 unimpl
# D38Eh TL2 cmp  r6, Ax@4
op:"cmp" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xE & r6 unimpl
@endif
# BE00h TL  cmpu MemImm8@0, Ax@8
op:"cmpu" MemImm8_0, Ax_8 is opcode_9_15=(0xBE>>1) & Ax_8 & MemImm8_0 unimpl
# 9E80h TL  cmpu MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"cmpu" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x9E>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9EA0h TL  cmpu Register@0, Ax@8
op:"cmpu" Register_0, Ax_8 is opcode_9_15=(0x9E>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 unimpl
@ifdef TEAK_LITE_2
# 8A63h TL2 cmpu r6, Ax@3
op:"cmpu" r6, Ax_3 is opcode_4_15=0x8A6 & Ax_3 & opcode_0_2=3 & r6 unimpl
@endif
# ED00h TL  cmpv Imm16@16, MemImm8@0
op:"cmpv" Imm16, MemImm8_0 is opcode_8_15=0xED & MemImm8_0; Imm16 unimpl
# 8CE0h TL  cmpv Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"cmpv" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x8CE>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8DE0h TL  cmpv Imm16@16, Register@0
op:"cmpv" Imm16, Register_0 is opcode_5_15=(0x8DE>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# 47BEh TL2 cmpv Imm16@16, r6
op:"cmpv" Imm16, r6 is opcode_0_15=0x47BE & r6; Imm16 unimpl
@endif
# D390h TL  cntx r  ;restore shadows
op:"cntx" "r" is opcode_0_15=0xD390 unimpl
# D380h TL  cntx s  ;store shadows
op:"cntx" "s" is opcode_0_15=0xD380 unimpl
# 67F0h TL  copy Implied Ax@not12,   Ax@12, Cond@0 ;aX=aY
op:"copy" Ax_Not12, Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & Ax_Not12 & opcode_4_11=0x7F & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_Not12 = Ax_12;
}
op:"copy" Ax_Not12, Ax_12 is opcode_13_15=(6>>1) & Ax_12 & Ax_Not12 & opcode_4_11=0x7F & cond_0=0 { Ax_Not12 = Ax_12; }
# 67E0h TL  dec  Implied Const1,     Ax@12, Cond@0 ;aX=aX-1
op:"dec" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7E & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_12 - 1;
}
op:"dec" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7E & cond_0=0 { Ax_12 = Ax_12 - 1; }
# 43C0h TL  dint        ;IE=0, interrupt disable
op:"dint" is opcode_0_15=0x43C0 unimpl
# 0E00h TL  divs MemImm8@0, Ax@8
op:"divs" MemImm8_0, Ax_8 is opcode_9_15=(0x0E>>1) & Ax_8 & MemImm8_0 unimpl
# 4380h TL  eint        ;IE=1, interrupt enable
op:"eint" is opcode_0_15=0x4380 unimpl
# 9460h TL  exp  Bx@0, Implied sv
op:"exp" Bx_0, sv is opcode_1_15=(0x9460>>1) & Bx_0 & sv unimpl
# 9060h TL  exp  Bx@0, Implied sv, Ax@8
op:"exp" Bx_0, sv, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_1_7=(0x60>>1) & Bx_0 & sv unimpl
# 9C40h TL  exp  MemRn@0, Implied sv || Rn@0stepZIDS@3
op:"exp" MemRn_0, sv || Rn_0_stepZIDS_3 is opcode_5_15=(0x9C4>>1) & Rn_0_stepZIDS_3 & MemRn_0 & sv unimpl
# 9840h TL  exp  MemRn@0, Implied sv, Ax@8 || Rn@0stepZIDS@3
op:"exp" MemRn_0, sv, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(4>>1) & Rn_0_stepZIDS_3 & MemRn_0 & sv unimpl
# 9040h TL  exp  RegisterP0@0, Implied sv, Ax@8
op:"exp" Register_P_0, sv, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(4>>1) & Register_P_0 & sv unimpl
# 9440h TL  exp  RegisterP0@0, Implied sv
op:"exp" Register_P_0, sv is opcode_5_15=(0x944>>1) & Register_P_0 & sv unimpl
@ifdef TEAK_LITE_2
# D7C1h TL2 exp  r6, Implied sv
op:"exp" r6, sv is opcode_0_15=0xD7C1 & r6 & sv unimpl
# D382h TL2 exp  r6, Implied sv, Ax@4
op:"exp" r6, sv, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=2 & r6 & sv unimpl
@endif
# 67D0h TL  inc  Implied Const1,     Ax@12, Cond@0 ;aX=aX+1
op:"inc" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7D & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_12 + 1;
}
op:"inc" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7D & cond_0=0 { Ax_12 = Ax_12 + 1; }
# 49C0h TL  lim  a0     ;aka a0,a0
# Probably related to the limit flag that is one of the condition codes (0xB)?
op:"lim" a0 is opcode_0_15=0x49C0 & a0 unimpl
# 49D0h TL  lim  a0, a1
op:"lim" a0, a1 is opcode_0_15=0x49D0 & a0 & a1 unimpl
# 49F0h TL  lim  a1     ;aka a1,a1
op:"lim" a1 is opcode_0_15=0x49F0 & a1 unimpl
# 49E0h TL  lim  a1, a0
op:"lim" a1, a0 is opcode_0_15=0x49E0 & a0 & a1 unimpl
# 4D80h TL  load Imm2u@0, ps               ;st1.bit11-10=imm2
op:"load" Imm2u_0, "ps" is opcode_2_15=(0x4D80>>2) & Imm2u_0 unimpl
# DB80h TL  load Imm7s@0, stepi            ;cfgi.LSB=imm7
op:"load" Imm7s_0, stepi is opcode_7_15=(0xDB8>>3) & Imm7s_0 & stepi unimpl
# DF80h TL  load Imm7s@0, stepj            ;cfgj.LSB=imm7
op:"load" Imm7s_0, stepj is opcode_7_15=(0xDF8>>3) & Imm7s_0 & stepj unimpl
# 0400h TL  load Imm8u@0, page             ;st1.LSBs=imm8 ;aka "lpg"
op:"load" Imm8u_0, "page" is opcode_8_15=0x04 & Imm8u_0 unimpl
# 0200h TL  load Imm9u@0, modi             ;cfgi.MSB=imm9
op:"load" Imm9u_0, "modi" is opcode_9_15=(0x02>>1) & Imm9u_0 unimpl
# 0A00h TL  load Imm9u@0, modj             ;cfgj.MSB=imm9
op:"load" Imm9u_0, "modi" is opcode_9_15=(0x0A>>1) & Imm9u_0 unimpl
@ifdef TEAK_LITE_2
# D7D8h TL2 load Imm2u@1, movpd, Unused1@0 ;stt2.bit6.7 (page for ProgMem)
op:"load" Imm2u_1, "movpd", unused_0_0 is opcode_3_15=(0xD7D8>>3) & Imm2u_1 & unused_0_0 unimpl
# 0010h TL2 load Imm4u@0, ps01             ;mod0.bit10-11,13-14 and st1.10-11 ?
op:"load" Imm4u_0, "ps01" is opcode_4_15=0x001 & Imm4u_0 unimpl
@endif
# D400h TL  maa  MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"maa" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x40>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8400h TL  maa  MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"maa" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x40>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8420h TL  maa  y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"maa" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x42>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8440h TL  maa  y0, Register@0, Ax@11
op:"maa" y0, Register_0, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x44>>2) & Register_0 & y0 unimpl
# E400h TL  maa  y0, MemImm8@0, Ax@11
op:"maa" y0, MemImm8_0, Ax_11 is opcode_12_15=0xE & Ax_11 & opcode_8_10=0x4 & MemImm8_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EA8h TL2 maa  y0, r6, Ax@0
op:"maa" y0, r6, Ax_0 is opcode_1_15=(0x5EA8>>1) & Ax_0 & y0 & r6 unimpl
@endif
# D700h TL  maasu MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"maasu" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x70>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8700h TL  maasu MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"maasu" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x70>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8720h TL  maasu y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"maasu" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x72>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8740h TL  maasu y0, Register@0, Ax@11
op:"maasu" y0, Register_0, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x74>>2) & Register_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EAEh TL2 maasu y0, r6, Ax@0
op:"maasu" y0, r6, Ax_0 is opcode_1_15=(0x5EAE>>1) & Ax_0 & y0 & r6 unimpl
@endif
# D200h TL  mac  MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"mac" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x20>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8200h TL  mac  MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"mac" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x20>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8220h TL  mac  y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"mac" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x22>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8240h TL  mac  y0, Register@0, Ax@11
op:"mac" y0, Register_0, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x24>>2) & Register_0 & y0 unimpl
# E200h TL  mac  y0, MemImm8@0, Ax@11
op:"mac" y0, MemImm8_0, Ax_11 is opcode_12_15=0xE & Ax_11 & opcode_8_10=0x2 & MemImm8_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EA4h TL2 mac  y0, r6, Ax@0
op:"mac" y0, r6, Ax_0 is opcode_1_15=(0x5EA4>>1) & Ax_0 & y0 & r6 unimpl
# 4D84h TL2 mac  y0, x1, Ax@1, Unused1@0
op:"mac" y0, x1, Ax_1, unused_0_0 is opcode_2_15=(0x4D84>>2) & Ax_1 & unused_0_0 & y0 & x1 unimpl
# 5E28h TL2 mac1 MemR45@2, MemR01@2, Ax@8 || R01@2stepII2@0, R45@2stepII2@1
op:"mac1" MemR45_2, MemR01_2, Ax_8 || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_9_15=(0x5E>>1) & Ax_8 & opcode_3_7=(0x28>>3) & MemR45_2 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
@endif
# D600h TL  macsu MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"macsu" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x60>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8600h TL  macsu MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"macsu" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x60>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8620h TL  macsu y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"macsu" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x62>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8640h TL  macsu y0, Register@0, Ax@11
op:"macsu" y0, Register_0, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x64>>2) & Register_0 & y0 unimpl
# E600h TL  macsu y0, MemImm8@0, Ax@11
# NOTE: was listed between 8600h and 8620h in nocash docs, unlike the other variants
op:"macsu" y0, MemImm8_0, Ax_11 is opcode_12_15=0xE & Ax_11 & opcode_8_10=0x6 & MemImm8_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EACh TL2 macsu y0, r6, Ax@0
op:"macsu" y0, r6, Ax_0 is opcode_1_15=(0x5EAC>>1) & Ax_0 & y0 & r6 unimpl
@endif
# D300h TL  macus MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"macus" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x30>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8300h TL  macus MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"macus" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x30>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8320h TL  macus y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"macus" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x32>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8340h TL  macus y0, Register@0, Ax@11
op:"macus" y0, Register_0, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x34>>2) & Register_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EA6h TL2 macus y0, r6, Ax@0
op:"macus" y0, r6, Ax_0 is opcode_1_15=(0x5EA6>>1) & Ax_0 & y0 & r6 unimpl
@endif
# D500h TL  macuu MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"macuu" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x50>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8500h TL  macuu MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"macuu" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x50>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8520h TL  macuu y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"macuu" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x52>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8540h TL  macuu y0, Register@0, Ax@11
op:"macuu" y0, Register_0, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x54>>2) & Register_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EAAh TL2 macuu y0, r6, Ax@0
op:"macuu" y0, r6, Ax_0 is opcode_1_15=(0x5EAA>>1) & Ax_0 & y0 & r6 unimpl
@endif
# 8460h TL  max  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, ge,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY >= aX
op:"max" Ax_8, Ax_Not8, r0, "ge", mixp || R0_stepZIDS_3 is opcode_9_15=(0x84>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp unimpl
# 8660h TL  max  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, gt,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY > aX
op:"max" Ax_8, Ax_Not8, r0, "gt", mixp || R0_stepZIDS_3 is opcode_9_15=(0x86>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp unimpl
@ifdef TEAK_LITE_2
# 5E21h TL2 max  a0h, a1h || max a0l, a1l || vtrshr
op:"max" a0h, a1h || "max" a0l, a1l || "vtrshr" is opcode_0_15=0x5E21 & a0h & a1h & a0l & a1l unimpl
# 5F21h TL2 max  a1h, a0h || max a1l, a0l || vtrshr
op:"max" a1h, a0h || "max" a1l, a0l || "vtrshr" is opcode_0_15=0x5F21 & a0h & a1h & a0l & a1l unimpl
# D784h TL2 max  Axh@1, Bxh@0 || max Axl@1, Bxl@0 || vtrshr
op:"max" Axh_1, Bxh_0 || "max" Axl_1, Bxl_0 || "vtrshr" is opcode_2_15=(0xD784>>2) & Axh_1 & Axl_1 & Bxh_0 & Bxl_0 unimpl
# 4A40h TL2 max  Axh@3, Bxh@4 || max Axl@3, Bxl@4 || mov Axl@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: bit 2 chooses between Axl_Not3 and Axh_Not3 - this could be merged
op:"max" Axh_3, Bxh_4 || "max" Axl_3, Bxl_4 || "mov" Axl_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A4>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axl_Not3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 unimpl
# 4A44h TL2 max  Axh@3, Bxh@4 || max Axl@3, Bxl@4 || mov Axh@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
op:"max" Axh_3, Bxh_4 || "max" Axl_3, Bxl_4 || "mov" Axh_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A4>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axh_Not3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 unimpl
# 45A0h TL2 max  Axh@4, Bxh@3 || max Axl@4, Bxl@3 || mov Axh@not4, MemR45@2
#            || mov Axl@not4, MemR01@2 || vtrshr
#            || R01@2stepII2@0, R45@2stepII2@1
op:"max" Axh_4, Bxh_3 || "max" Axl_4, Bxl_3 || "mov" Axh_Not4, MemR45_2 || "mov" Axl_Not4, MemR01_2 || "vtrshr" || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x45A>>1) & Axh_4 & Axl_4 & Axh_Not4 & Axl_Not4 & Bxh_3 & Bxl_3 & MemR45_2 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
# D590h TL2 max  Axh@6, Bxh@5 || max Axl@6, Bxl@5 || mov Axh@not6, MemR01@2
#            || mov Axl@not6, MemR45@2 || vtrshr
#            || R01@2stepII2@0, R45@2stepII2@1
op:"max" Axh_6, Bxh_5 || "max" Axl_6, Bxl_5 || "mov" Axh_Not6, MemR01_2 || "mov" Axl_Not6, MemR45_2 || "vtrshr" || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_7_15=(0xD59>>3) & Axh_6 & Axl_6 & Axh_Not6 & Axl_Not6 & Bxh_5 & Bxl_5 & opcode_3_4=2 & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
# 4A60h TL2 max  Bxh@4, Axh@3 || max Bxl@4, Axl@3 || mov Bxl@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
op:"max" Bxh_4, Axh_3 || "max" Bxl_4, Axl_3 || "mov" Bxl_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A6>>1) & Bxh_4 & Bxl_4 & Bxl_Not4 & Axh_3 & Axl_3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 unimpl
# 4A64h TL2 max  Bxh@4, Axh@3 || max Bxl@4, Axl@3 || mov Bxh@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
op:"max" Bxh_4, Axh_3 || "max" Bxl_4, Axl_3 || "mov" Bxh_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A6>>1) & Bxh_4 & Bxl_4 & Bxh_Not4 & Axh_3 & Axl_3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 unimpl
@endif
# 8060h TL  maxd NoReverse, Ax@8, MemR0, ge, Implied mixp, Implied r0
#            || R0stepZIDS@3   ;when (r0) >= aX
op:"maxd" Ax_8, MemR0, "ge", mixp || R0_stepZIDS_3 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & MemR0 & mixp unimpl
# 8260h TL  maxd NoReverse, Ax@8, MemR0, gt, Implied mixp, Implied r0
#            || R0stepZIDS@3   ;when (r0) > aX
op:"maxd" Ax_8, MemR0, "gt", mixp || R0_stepZIDS_3 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & MemR0 & mixp unimpl
# 8860h TL  min  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, le,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY <= aX
# NOTE: matches 8460h
op:"min" Ax_8, Ax_Not8, r0, "le", mixp || R0_stepZIDS_3 is opcode_9_15=(0x88>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp unimpl
# 8A60h TL  min  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, lt,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY < aX
# NOTE: matches 8660h
op:"min" Ax_8, Ax_Not8, r0, "lt", mixp || R0_stepZIDS_3 is opcode_9_15=(0x8A>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp unimpl
@ifdef TEAK_LITE_2
# 43C2h TL2 min  Axh@0, Axh@not0 || min Axl@0, Axl@not0 || vtrshr
op:"min" Axh_0, Axh_Not0 || "min" Axl_0, Axl_Not0 || "vtrshr" is opcode_1_15=(0x43C2>>1) & Axh_0 & Axh_Not0 & Axl_0 & Axl_Not0 unimpl
# D2B8h TL2 min  Axh@11, Bxh@10 || min Axl@11, Bxl@10
#            || mov Axh@not11, MemR01@2 || mov Axl@not11, MemR45@2
#            || vtrshr || R01@2stepII2@0, R45@2stepII2@1
op:"min" Axh_11, Bxh_10 || "min" Axl_11, Bxl_10 || "mov" Axh_Not11, MemR01_2 || "mov" Axl_Not11, MemR45_2 || "vtrshr" || R01_2_stepII2_0 || R45_2_stepII2_1
	is opcode_12_15=0xD & Axh_11 & Axl_11 & Axh_Not11 & Axl_Not11 & Bxh_10 & Bxl_10 & opcode_3_9=(0x2B8>>3) & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
# 4A00h TL2 min  Axh@3, Bxh@4 || min Axl@3, Bxl@4 || mov Axl@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: bit 2 chooses between Axl_Not3 and Axh_Not3 - this could be merged
# NOTE: matches 4A40h
op:"min" Axh_3, Bxh_4 || "min" Axl_3, Bxl_4 || "mov" Axl_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A0>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axl_Not3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 unimpl
# 4A04h TL2 min  Axh@3, Bxh@4 || min Axl@3, Bxl@4 || mov Axh@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: matches 4A44h
op:"min" Axh_3, Bxh_4 || "min" Axl_3, Bxl_4 || "mov" Axh_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A0>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axh_Not3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 unimpl
# 45E0h TL2 min  Axh@4, Bxh@3 || min Axl@4, Bxl@3 || mov Axh@not4, MemR45@2
#            || mov Axl@not4, MemR01@2 || vtrshr
#            || R01@2stepII2@0, R45@2stepII2@1
# NOTE: matches 45A0h
op:"min" Axh_4, Bxh_3 || "min" Axl_4, Bxl_3 || "mov" Axh_Not4, MemR45_2 || "mov" Axl_Not4, MemR01_2 || "vtrshr" || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x45E>>1) & Axh_4 & Axl_4 & Axh_Not4 & Axl_Not4 & Bxh_3 & Bxl_3 & MemR45_2 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
# D4BAh TL2 min  Axh@8, Bxh@0 || min Axl@8, Bxl@0 || vtrshr
op:"min" Axh_8, Bxh_0 || "min" Axl_8, Bxl_0 || "vtrshr" is opcode_9_15=(0xD4>>1) & Axh_8 & Axl_8 & opcode_1_7=(0xBA>>1) & Bxh_0 & Bxl_0 unimpl
# 4A20h TL2 min  Bxh@4, Axh@3 || min Bxl@4, Axl@3 || mov Bxl@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: matches 4A60h
op:"min" Bxh_4, Axh_3 || "min" Bxl_4, Axl_3 || "mov" Bxl_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A2>>1) & Bxh_4 & Bxl_4 & Bxl_Not4 & Axh_3 & Axl_3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 unimpl
# 4A24h TL2 min  Bxh@4, Axh@3 || min Bxl@4, Axl@3 || mov Bxh@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: matches 4A64h
op:"min" Bxh_4, Axh_3 || "min" Bxl_4, Axl_3 || "mov" Bxh_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A2>>1) & Bxh_4 & Bxl_4 & Bxh_Not4 & Axh_3 & Axl_3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 unimpl
# 47A0h TL2 mind NoReverse, Ax@3, MemR0, le, Implied mixp, Implied r0
#            || R0stepZIDS@0
op:"mind" Ax_3, MemR0, "le", mixp || R0_stepZIDS_0 is opcode_4_15=0x47A & Ax_3 & opcode_2_2=0 & R0_stepZIDS_0 & MemR0 & mixp unimpl
# 47A4h TL2 mind NoReverse, Ax@3, MemR0, lt, Implied mixp, Implied r0
#            || R0stepZIDS@0
op:"mind" Ax_3, MemR0, "lt", mixp || R0_stepZIDS_0 is opcode_4_15=0x47A & Ax_3 & opcode_2_2=1 & R0_stepZIDS_0 & MemR0 & mixp unimpl
@endif
# 0080h TL  modr MemRn@0stepZIDS@3
op:"modr" MemRn_0_stepZIDS_3 is opcode_5_15=(0x008>>1) & MemRn_0_stepZIDS_3 { build MemRn_0_stepZIDS_3; }
# 00A0h TL  modr MemRn@0stepZIDS@3, dmod  ;Disable modulo
op:"modr" MemRn_0_stepZIDS_3,"dmod" is opcode_5_15=(0x00A>>1) & MemRn_0_stepZIDS_3 { build MemRn_0_stepZIDS_3; }
@ifdef TEAK_LITE_2
# NOTE: nocash documentation has a "modrstepII2D2S0" which is what is used here (the difference is
# that one uses stepi/stepj (unclear which) and the other uses stepi0/stepj0 (also unclear which).)
# For whatever reason nocash doesn't use modrstepII2D2S0 in the actual instruction list though.
# D294h TL2 modr MemR0123@10stepII2D2S0@0 || modr MemR4567@10stepII2D2S0@5
op:"modr" MemR0123_10_modrstepII2D2S0_0 || "modr" MemR4567_10_modrstepII2D2S0_5
	is opcode_12_15=0xD & opcode_7_9=(0x29>>3) & MemR4567_10_modrstepII2D2S0_5 & opcode_2_4=(0x14>>2) & MemR0123_10_modrstepII2D2S0_0
{
	build MemR0123_10_modrstepII2D2S0_0;
	build MemR4567_10_modrstepII2D2S0_5;
}
# 0D80h TL2 modr MemR0123@5stepII2D2S0@1  || modr MemR4567@5stepII2D2S0@3, dmod
op:"modr" MemR0123_5_modrstepII2D2S0_1 || "modr" MemR4567_5_modrstepII2D2S0_3, "dmod"
	is opcode_5_15=(0x0D8>>3) & MemR4567_5_modrstepII2D2S0_3 & MemR0123_5_modrstepII2D2S0_1 & opcode_0_0=0
{
	build MemR0123_5_modrstepII2D2S0_1;
	build MemR4567_5_modrstepII2D2S0_3;
}
# 0D81h TL2 modr MemR0123@5stepII2D2S0@1, dmod
#            || modr MemR4567@5stepII2D2S0@3, dmod
# NOTE: identical to 0D80h apart from the first dmod (TODO: which we haven't implemented yet)
op:"modr" MemR0123_5_modrstepII2D2S0_1 || "modr" MemR4567_5_modrstepII2D2S0_3, "dmod"
	is opcode_5_15=(0x0D8>>3) & MemR4567_5_modrstepII2D2S0_3 & MemR0123_5_modrstepII2D2S0_1 & opcode_0_0=1
{
	build MemR0123_5_modrstepII2D2S0_1;
	build MemR4567_5_modrstepII2D2S0_3;
}
# 8464h TL2 modr MemR0123@8stepII2D2S0@0, dmod || modr MemR4567@8stepII2D2S0@3
op:"modr" MemR0123_8_modrstepII2D2S0_0, "dmod" || "modr" MemR4567_8_modrstepII2D2S0_3
	is opcode_10_15=(0x84>>2) & opcode_5_7=(6>>1) & MemR4567_8_modrstepII2D2S0_3 & opcode_2_2=1 & MemR0123_8_modrstepII2D2S0_0
{
	build MemR0123_8_modrstepII2D2S0_0;
	build MemR4567_8_modrstepII2D2S0_3;
}
# TODO: Brackets? (See comment on MemR0123_5_modrstepII2D2S0_1)
# 5DA0h TL2 modr MemRn@0stepD2
op:"modr" MemRn_0-2 is opcode_3_15=(0x5DA0>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 - 2; }
# 5DA8h TL2 modr MemRn@0stepD2, dmod
op:"modr" MemRn_0-2, "dmod" is opcode_3_15=(0x5DA8>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 - 2; }  # TODO: dmod
# 4990h TL2 modr MemRn@0stepI2
op:"modr" MemRn_0+2 is opcode_3_15=(0x4990>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 + 2; }
# 4998h TL2 modr MemRn@0stepI2, dmod
op:"modr" MemRn_0+2, "dmod" is opcode_3_15=(0x4998>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 + 2; }  # TODO: dmod
@endif
# D290h TL  mov  Ab@10, Ab@5
op:"mov" Ab_10, Ab_5 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x29>>3) & Ab_5 & opcode_0_4=0x10 { Ab_5 = Ab_10; }
# D298h TL  mov  Abl@10, dvm
op:"mov" Abl_10, dvm is opcode_12_15=0xD & Abl_10 & opcode_0_9=0x298 & dvm { dvm = Abl_10; }
# D2D8h TL  mov  Abl@10, x0
op:"mov" Abl_10, x0 is opcode_12_15=0xD & Abl_10 & opcode_0_9=0x2D8 & x0 { x0 = Abl_10; }
# 3000h TL  mov  Ablh@9, MemImm8@0
op:"mov" Ablh_9, MemImm8_0 is opcode_12_15=0x3 & Ablh_9 & opcode_8_8=0 & MemImm8_0 { MemImm8_0 = Ablh_9; }
# D4BCh TL  mov  Axl@8, MemImm16@16
op:"mov" Axl_8, MemImm16 is opcode_9_15=(0xD4>>1) & Axl_8 & opcode_0_7=0xBC; MemImm16 { MemImm16 = Axl_8; }
# D49Ch TL  mov  Axl@8, MemR7Imm16@16
op:"mov" Axl_8, MemR7Imm16 is opcode_9_15=(0xD4>>1) & Axl_8 & opcode_0_7=0x9C; MemR7Imm16 { MemR7Imm16 = Axl_8; }
# DC80h TL  mov  Axl@8, MemR7Imm7s@0
op:"mov" Axl_8, MemR7Imm7s_0 is opcode_9_15=(0xDC>>1) & Axl_8 & opcode_7_7=1 & MemR7Imm7s_0 { MemR7Imm7s_0 = Axl_8; }
# D4B8h TL  mov  MemImm16@16, Ax@8
# TODO: sign extension or zero-extension? Where in the accumulator do we move to?
op:"mov" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xB8; MemImm16 { Ax_8 = sext(MemImm16); }
# 6100h TL  mov  MemImm8@0, Ab@11
op:"mov" MemImm8_0, Ab_11 is opcode_13_15=(6>>1) & Ab_11 & opcode_8_10=1 & MemImm8_0 { Ab_11 = sext(MemImm8_0); }
# 6200h TL  mov  MemImm8@0, Ablh@10
op:"mov" MemImm8_0, Ablh_10 is opcode_13_15=(6>>1) & Ablh_10 & opcode_8_9=2 & MemImm8_0 { Ablh_10 = MemImm8_0; }
# 6500h TL  mov  MemImm8@0, Axh@12, eu   ;aka Axheu
# TODO: What is this? Is this like Abe (a0e/a1e etc)? If so, why "eu" and not just "e", and why isn't it in the operand encoding table?
op:"mov" MemImm8_0, Axh_12, "eu" is opcode_13_15=(6>>1) & Axh_12 & opcode_8_11=5 & MemImm8_0 unimpl
# 6000h TL  mov  MemImm8@0, R0123457y0@10
op:"mov" MemImm8_0, R0123457y0_10 is opcode_13_15=(6>>1) & R0123457y0_10 & opcode_8_9=0 & MemImm8_0 { R0123457y0_10 = MemImm8_0; }
# 6D00h TL  mov  MemImm8@0, sv
op:"mov" MemImm8_0, sv is opcode_8_15=0x6D & MemImm8_0 & sv { sv = MemImm8_0; }
# D491h TL  mov  dvm, Ab@5
op:"mov" dvm, Ab_5 is opcode_7_15=(0xD49>>3) & Ab_5 & opcode_0_4=0x11 & dvm { Ab_5 = sext(dvm); }
# D492h TL  mov  icr, Ab@5
op:"mov" icr, Ab_5 is opcode_7_15=(0xD49>>3) & Ab_5 & opcode_0_4=0x12 & icr { Ab_5 = sext(icr); }
# 5E20h TL  mov  Imm16@16, Bx@8
op:"mov" Imm16, Bx_8 is opcode_9_15=(0x5E>>1) & Bx_8 & opcode_0_7=0x20; Imm16 { Bx_8 = sext(Imm16); }
# 5E00h TL  mov  Imm16@16, Register@0
op:"mov" Imm16, Register_0 is opcode_5_15=(0x5E0>>1) & Register_0; Imm16 { Register_0 = Imm16; }
# 4F80h TL  mov  Imm5u@0, icr    ;uh, but icr is 8bit wide (only 4bit are R/W)?
# TODO: comment from nocash
op:"mov" Imm5u_0, icr is opcode_5_15=(0x4F8>>1) & Imm5u_0 & icr { icr = Imm5u_0; }
# 2500h TL  mov  Imm8s@0, Axh@12         ;signed!
op:"mov" Imm8s_0, Axh_12 is opcode_13_15=(2>>1) & Axh_12 & opcode_8_11=5 & Imm8s_0 { Axh_12 = Imm8s_0; }
# 2900h TL  mov  Imm8s@0, ext0
# TODO: ext0 through ext3 could definitely be merged
op:"mov" Imm8s_0, ext0 is opcode_8_15=0x29 & Imm8s_0 & ext0 { ext0 = Imm8s_0; }
# 2D00h TL  mov  Imm8s@0, ext1
op:"mov" Imm8s_0, ext1 is opcode_8_15=0x2D & Imm8s_0 & ext1 { ext1 = Imm8s_0; }
# 3900h TL  mov  Imm8s@0, ext2
op:"mov" Imm8s_0, ext2 is opcode_8_15=0x39 & Imm8s_0 & ext2 { ext2 = Imm8s_0; }
# 3D00h TL  mov  Imm8s@0, ext3
op:"mov" Imm8s_0, ext3 is opcode_8_15=0x3D & Imm8s_0 & ext3 { ext3 = Imm8s_0; }
# 2300h TL  mov  Imm8s@0, R0123457y0@10  ;signed!
op:"mov" Imm8s_0, R0123457y0_10 is opcode_13_15=(2>>1) & R0123457y0_10 & opcode_8_9=3 & Imm8s_0 { R0123457y0_10 = Imm8s_0; }
# 0500h TL  mov  Imm8s@0, sv
op:"mov" Imm8s_0, sv is opcode_8_15=0x05 & Imm8s_0 & sv { sv = Imm8s_0; }
# 2100h TL  mov  Imm8u@0, Axl@12         ;unsigned!
op:"mov" Imm8u_0, Axl_12 is opcode_13_15=(2>>1) & Axl_12 & opcode_8_11=1 & Imm8u_0 { Axl_12 = Imm8u_0; }
# D498h TL  mov  MemR7Imm16@16, Ax@8
op:"mov" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0x98; MemR7Imm16 { Ax_8 = sext(MemR7Imm16); }
# D880h TL  mov  MemR7Imm7s@0, Ax@8
op:"mov" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0xD8>>1) & Ax_8 & opcode_7_7=1 & MemR7Imm7s_0 { Ax_8 = sext(MemR7Imm7s_0); }
# 98C0h TL  mov  MemRn@0, Bx@8 || Rn@0stepZIDS@3
op:"mov" MemRn_0, Bx_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0xD8>>1) & Bx_8 & opcode_5_7=(0xC>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Bx_8 = sext(MemRn_0); build Rn_0_stepZIDS_3; }
# 1C00h TL  mov  MemRn@0, Register@5 || Rn@0stepZIDS@3
op:"mov" MemRn_0, Register_5 || Rn_0_stepZIDS_3 is opcode_10_15=(0x1C>>2) & Register_5 & Rn_0_stepZIDS_3 & MemRn_0 { Register_5 = MemRn_0; build Rn_0_stepZIDS_3; }
# 47E0h TL  mov  MemSp, Register@0
op:"mov" MemSp, Register_0 is opcode_5_15=(0x47E>>1) & Register_0 & MemSp { Register_0 = MemSp; }
# 47C0h TL  mov  mixp, Register@0
op:"mov" mixp, Register_0 is opcode_5_15=(0x47C>>1) & Register_0 & mixp { Register_0 = mixp; }
# 2000h TL  mov  R0123457y0@9, MemImm8@0
op:"mov" R0123457y0_9, MemImm8_0 is opcode_12_15=2 & R0123457y0_9 & opcode_8_8=0 & MemImm8_0 { MemImm8_0 = R0123457y0_9; }
# 4FC0h TL  mov  Register@0, icr
op:"mov" Register_0, icr is opcode_5_15=(0x4FC>>1) & Register_0 & icr { icr = Register_0; }
# 5E80h TL  mov  Register@0, mixp
op:"mov" Register_0, mixp is opcode_5_15=(0x5E8>>1) & Register_0 & mixp { mixp = Register_0; }
# 1800h TL  mov  Register@5, MemRn@0 || Rn@0stepZIDS@3
op:"mov" Register_5, MemRn_0 || Rn_0_stepZIDS_3 is opcode_10_15=(0x18>>2) & Register_5 & Rn_0_stepZIDS_3 & MemRn_0 { MemRn_0 = Register_5; build Rn_0_stepZIDS_3; }
# 5EC0h TL  mov  RegisterP0@0, Bx@5
op:"mov" Register_P_0, Bx_5 is opcode_6_15=(0x5EC>>2) & Bx_5 & Register_P_0 { Bx_5 = sext(Register_P_0); }
# 5800h TL  mov  RegisterP0@0, Register@5
op:"mov" Register_P_0, Register_5 is opcode_10_15=(0x58>>2) & Register_5 & Register_P_0 { Register_5 = Register_P_0; }
# D490h TL  mov  repc, Ab@5
op:"mov" repc, Ab_5 is opcode_7_15=(0xDA9>>3) & Ab_5 & opcode_0_4=0x10 & repc { Ab_5 = sext(repc); }
# 7D00h TL  mov  sv, MemImm8@0
op:"mov" sv, MemImm8_0 is opcode_8_15=0x7D & MemImm8_0 & sv { MemImm8_0 = sv; }
# D493h TL  mov  x0, Ab@5
op:"mov" x0, Ab_5 is opcode_7_15=(0xD49>>3) & Ab_5 & opcode_0_4=0x13 & x0 { Ab_5 = sext(x0); }
@ifdef TEAK_LITE_2
# D49Bh TL2 mov  a0h, stepi0
op:"mov" a0h, stepi0 is opcode_0_15=0xD49B & a0h & stepi0 { stepi0 = a0h; }
# D59Bh TL2 mov  a0h, stepj0
op:"mov" a0h, stepj0 is opcode_0_15=0xD59B & a0h & stepj0 { stepj0 = a0h; }
# 4390h TL2 mov  a0h, MemR0425@2 || mov y0, MemR0425@2offsZIDZ@0
#            || R0425@2stepII2D2S@0
op:"mov" a0h, MemR0425_2 || "mov" y0, MemR0425_2_offsZIDZ_0 || R0425_2_stepII2D2S_0 is opcode_4_15=0x439 & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0 & a0h & y0 {
	MemR0425_2 = a0h;
	MemR0425_2_offsZIDZ_0 = y0;
	build R0425_2_stepII2D2S_0;
}
# 43D0h TL2 mov  a1h, MemR0425@2 || mov y0, MemR0425@2offsZIDZ@0
#            || R0425@2stepII2D2S@0
op:"mov" a1h, MemR0425_2 || "mov" y0, MemR0425_2_offsZIDZ_0 || R0425_2_stepII2D2S_0 is opcode_4_15=0x43D & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0 & a1h & y0 {
	MemR0425_2 = a1h;
	MemR0425_2_offsZIDZ_0 = y0;
	build R0425_2_stepII2D2S_0;
}
# 8FD4h TL2 mov  Ab@0, p0
op:"mov" Ab_0, p0 is opcode_2_15=(0x8FD4>>2) & Ab_0 & p0 unimpl # TODO: { p0 = Ab_0; } gives a size error
# 43A0h TL2 mov  Abh@3, MemR01@2 || mov Abl@3, MemR45@2
#            || R01@2stepII2@0, R45@2stepII2@1
op:"mov" Abh_3, MemR01_2 || "mov" Abl_3, MemR45_2 || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_5_15=(0x43A>>1) & Abh_3 & Abl_3 & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 {
	MemR01_2 = Abh_3;
	MemR45_2 = Abl_3;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 43E0h TL2 mov  Abh@3, MemR45@2 || mov Abl@3, MemR01@2
#            || R01@2stepII2@0, R45@2stepII2@1
op:"mov" Abh_3, MemR45_2 || "mov" Abl_3, MemR01_2 || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_5_15=(0x43E>>1) & Abh_3 & Abl_3 & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 {
	MemR45_2 = Abh_3;
	MemR01_2 = Abl_3;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 9D40h TL2 mov  Abh@4, MemR04@1 || mov Abh@2, MemR04@1offsZI@0
#            || R04@1stepII2@0
op:"mov" Abh_4, MemR04_1 || "mov" Abh_2, MemR04_1_offsZI_0 || R04_1_stepII2_0 is opcode_6_15=(0x9D4>>2) & Abh_4 & Abh_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 {
	MemR04_1 = Abh_4;
	MemR04_1_offsZI_0 = Abh_2;
	build R04_1_stepII2_0;
}
# 9164h TL2 mov  Abl@0, prpage
op:"mov" Abl_0, prpage is opcode_2_15=(0x9164>>2) & Abl_0 & prpage { prpage = Abl_0; }
# 9064h TL2 mov  Abl@0, repc
op:"mov" Abl_0, repc is opcode_2_15=(0x9064>>2) & Abl_0 & repc { repc = Abl_0; }
# D394h TL2 mov  Abl@0, x1
op:"mov" Abl_0, x1 is opcode_2_15=(0xD394>>2) & Abl_0 & x1 { x1 = Abl_0; }
# D384h TL2 mov  Abl@0, y1
op:"mov" Abl_0, y1 is opcode_2_15=(0xD384>>2) & Abl_0 & y1 { y1 = Abl_0; }
# 9540h TL2 mov  Abl@3, ArArp@0
op:"mov" Abl_3, ArArp_0 is opcode_5_15=(0x954>>1) & Abl_3 & ArArp_0 { ArArp_0 = Abl_3; }
# 9C60h TL2 mov  Abl@3, SttMod@0
op:"mov" Abl_3, SttMod_0 is opcode_5_15=(0x9C6>>1) & Abl_3 & SttMod_0 { SttMod_0 = Abl_3; }
# 9560h TL2 mov  ArArp@0, Abl@3
op:"mov" ArArp_0, Abl_3 is opcode_5_15=(0x956>>1) & Abl_3 & ArArp_0 { Abl_3 = ArArp_0; }
# D488h TL2 mov  ArArp@0, MemR04@8 || R04@8stepII2@5
op:"mov" ArArp_0, MemR04_8 || R04_8_stepII2_5 is opcode_9_15=(0xD4>>1) & MemR04_8 & opcode_6_7=(8>>2) & R04_8_stepII2_5 & opcode_3_4=(0x08>>3) & ArArp_0 {
	MemR04_8 = ArArp_0;
	build R04_8_stepII2_5;
}
# 5F50h TL2 mov  ArArpSttMod@0, MemR7Imm16@16
op:"mov" ArArpSttMod_0, MemR7Imm16 is opcode_4_15=0x5F5 & ArArpSttMod_0; MemR7Imm16 { MemR7Imm16 = ArArpSttMod_0; }
# 886Bh TL2 mov  Ax@8, pc
op:"mov" Ax_8, pc is opcode_9_15=(0x88>>1) & Ax_8 & opcode_0_7=0x6B & pc { goto Ax_8; }
# 8C60h TL2 mov  Axh@4, MemR4567@8 || mov MemR0123@8, Axh@4
#            || R0123@8stepII2D2S@0, R4567@8stepII2D2S@2
op:"mov" Axh_4, MemR4567_8 || "mov" MemR0123_8, Axh_4_copy || R0123_8_stepII2D2S_0, R4567_8_stepII2D2S_2
	is opcode_10_15=(0x8C>>2) & MemR4567_8 & MemR0123_8 & opcode_5_7=(1>>2) & Axh_4 & Axh_4_copy & R4567_8_stepII2D2S_2 & R0123_8_stepII2D2S_0
{
	MemR4567_8 = Axh_4;
	Axh_4 = MemR0123_8;
	build R0123_8_stepII2D2S_0;
	build R4567_8_stepII2D2S_2;
}
# 4800h TL2 mov  Axh@6, MemR0123@4 || movr MemR4567@4, Axh@6
#            || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mov" Axh_6, MemR0123_4 || "movr" MemR4567_4, Axh_6_copy || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_7_15=(0x480>>3) & Axh_6 & Axh_6_copy & MemR0123_4 & MemR4567_4 & R4567_4_stepII2D2S_2 & R0123_4_stepII2D2S_0
{
	MemR0123_4 = Axh_6;
	Axh_6 = MemR4567_4;  # TODO: movr
	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 4900h TL2 mov  Axh@6, MemR0123@4 || mov  MemR4567@4, Axh@6
#            || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mov" Axh_6, MemR0123_4 || "mov" MemR4567_4, Axh_6_copy || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_7_15=(0x490>>3) & Axh_6 & Axh_6_copy & MemR0123_4 & MemR4567_4 & R4567_4_stepII2D2S_2 & R0123_4_stepII2D2S_0
{
	MemR0123_4 = Axh_6;
	Axh_6 = MemR4567_4;
	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 7F80h TL2 mov  Axh@6, MemR4567@4 || movr MemR0123@4, Axh@6
#            || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mov" Axh_6, MemR4567_4 || "movr" MemR0123_4, Axh_6_copy || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_7_15=(0x7F8>>3) & Axh_6 & Axh_6_copy & MemR0123_4 & MemR4567_4 & R4567_4_stepII2D2S_2 & R0123_4_stepII2D2S_0
{
	MemR4567_4 = Axh_6;
	Axh_6 = MemR0123_4;  # TODO: movr
	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 8863h TL2 mov  Bx@8, pc
op:"mov" Bx_8, pc is opcode_9_15=(0x88>>1) & Bx_8 & opcode_0_7=0x63 & pc { goto Bx_8; }
# 0008h TL2 mov  Imm16@16, ArArp@0
op:"mov" Imm16, ArArp_0 is opcode_3_15=(0x0008>>3) & ArArp_0; Imm16 { ArArp_0 = Imm16; }
# 0023h TL2 mov  Imm16@16, r6
op:"mov" Imm16, r6 is opcode_0_15=0x0023 & r6; Imm16 { r6 = Imm16; }
# 0001h TL2 mov  Imm16@16, repc
op:"mov" Imm16, repc is opcode_0_15=0x0001 & repc; Imm16 { repc = Imm16; }
# 8971h TL2 mov  Imm16@16, stepi0
op:"mov" Imm16, stepi0 is opcode_0_15=0x8971 & stepi0; Imm16 { stepi0 = Imm16; }
# 8979h TL2 mov  Imm16@16, stepj0
op:"mov" Imm16, stepj0 is opcode_0_15=0x8979 & stepj0; Imm16 { stepj0 = Imm16; }
# 0030h TL2 mov  Imm16@16, SttMod@0
op:"mov" Imm16, SttMod_0 is opcode_3_15=(0x0030>>3) & SttMod_0; Imm16 { SttMod_0 = Imm16; }
# 5DD0h TL2 mov  Imm4u@0, prpage
op:"mov" Imm4u_0, prpage is opcode_4_15=0x5DD & Imm4u_0 & prpage { prpage = Imm4u_0; }
# 80C4h TL2 mov  MemR01@9, Abh@10 || mov MemR45@9, Abl@10
#            || R01@9stepII2@0, R45@9stepII2@8
op:"mov" MemR01_9, Abh_10 || "mov" MemR45_9, Abl_10 || R01_9_stepII2_0, R45_9_stepII2_8
	is opcode_11_15=(0x80>>3) & Abh_10 & Abl_10 & MemR01_9 & MemR45_9 & R45_9_stepII2_8 & opcode_1_7=(0xC4>>1) & R01_9_stepII2_0
{
	Abh_10 = MemR01_9;
	Abl_10 = MemR45_9;
	build R01_9_stepII2_0;
	build R45_9_stepII2_8;
}
# D292h TL2 mov  MemR0425@10_MemR0425@10offsZIDZ@5, Px@0
#            || R0425@10stepII2D2S@5
op:"mov" MemR0425_10^"_"^MemR0425_10_offsZIDZ_5, Px_0 || R0425_10_stepII2D2S_5
	is opcode_12_15=0xD & MemR0425_10 & opcode_7_9=(0x29>>3) & MemR0425_10_offsZIDZ_5 & R0425_10_stepII2D2S_5 & opcode_1_4=(0x12>>1) & Px_0
unimpl  # TODO: Presumably requires p0l and p0h? Also what if the offset is 0?
# D7D4h TL2 mov  MemR04@1, repc || R04@1stepII2@0
op:"mov" MemR04_1, repc || R04_1_stepII2_0 is opcode_2_15=(0xD7D4>>2) & MemR04_1 & R04_1_stepII2_0 & repc { repc = MemR04_1; build R04_1_stepII2_0; }
# 5F4Ch TL2 mov  MemR04@1, sv || sub3 MemR04@1, p0, p1, b0 || R04@1stepII2@0
op:"mov" MemR04_1, sv || "sub3" MemR04_1_copy, p0, p1, b0 || R04_1_stepII2_0 is opcode_2_15=(0x5F4C>>2) & MemR04_1 & MemR04_1_copy & R04_1_stepII2_0 & sv & p0 & p1 & b0 unimpl
# D4B4h TL2 mov  MemR04@1, sv || sub3rnd MemR04@1, p0, p1, b1 || R04@1stepII2@0
op:"mov" MemR04_1, sv || "sub3rnd" MemR04_1_copy, p0, p1, b1 || R04_1_stepII2_0 is opcode_2_15=(0xD4B4>>2) & MemR04_1 & MemR04_1_copy & R04_1_stepII2_0 & sv & p0 & p1 & b1 unimpl
# DE9Ch TL2 mov  MemR04@1, sv || sub3rnd MemR04@1, p0, p1, b0 || R04@1stepII2@0
op:"mov" MemR04_1, sv || "sub3rnd" MemR04_1_copy, p0, p1, b0 || R04_1_stepII2_0 is opcode_2_15=(0xDE9C>>2) & MemR04_1 & MemR04_1_copy & R04_1_stepII2_0 & sv & p0 & p1 & b0 unimpl
# 4B40h TL2 mov  MemR04@3, sv || addsub    MemR04@3, p1, p0, Bx@0
#            || R04@3stepII2@2
op:"mov" MemR04_3, sv || "addsub"    MemR04_3_copy, p1, p0, Bx_0 || R04_3_stepII2_2
	is opcode_4_15=0x4B4 & MemR04_3 & MemR04_3_copy & R04_3_stepII2_2 & opcode_1_1=0 & Bx_0 & sv & p1 & p0
unimpl
# 4B42h TL2 mov  MemR04@3, sv || addsubrnd MemR04@3, p1, p0, Bx@0
#            || R04@3stepII2@2
op:"mov" MemR04_3, sv || "addsubrnd" MemR04_3_copy, p1, p0, Bx_0 || R04_3_stepII2_2
	is opcode_4_15=0x4B4 & MemR04_3 & MemR04_3_copy & R04_3_stepII2_2 & opcode_1_1=1 & Bx_0 & sv & p1 & p0
unimpl
# 8062h TL2 mov  MemR04@4, ArArp@8  || R04@4stepII2@3
op:"mov" MemR04_4, ArArp_8 || R04_4_stepII2_3 is opcode_11_15=(0x80>>3) & ArArp_8 & opcode_5_7=(0x6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=2 {
	ArArp_8 = MemR04_4;
	build R04_4_stepII2_3;
}
# 8063h TL2 mov  MemR04@4, SttMod@8 || R04@4stepII2@3
op:"mov" MemR04_4, SttMod_8 || R04_4_stepII2_3 is opcode_11_15=(0x80>>3) & SttMod_8 & opcode_5_7=(0x6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=3 {
	SttMod_8 = MemR04_4;
	build R04_4_stepII2_3;
}
# 9960h TL2 mov  MemR04@4, sv || addsub    MemR04@4, p1, p0, Bx@2
#            || R04@4stepD2S@3  ;<-- ordered p1, p0 here !
# TODO: why the order warning here but not 4B40 / 4B42? (Maybe to contrast with 9860?)
op:"mov" MemR04_4, sv || "addsub"    MemR04_4_copy, p1, p0, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x996>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p1 & p0
unimpl
# 99E0h TL2 mov  MemR04@4, sv || addsubrnd MemR04@4, p1, p0, Bx@2
#            || R04@4stepD2S@3  ;<-- ordered p1, p0 here !
op:"mov" MemR04_4, sv || "addsubrnd" MemR04_4_copy, p1, p0, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x99E>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p1 & p0
unimpl
# 9860h TL2 mov  MemR04@4, sv || sub3      MemR04@4, p0, p1, Bx@2
#            || R04@4stepD2S@3
op:"mov" MemR04_4, sv || "addsub"    MemR04_4_copy, p0, p1, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x986>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p0 & p1
unimpl
# 98E0h TL2 mov  MemR04@4, sv || sub3rnd   MemR04@4, p0, p1, Bx@2
#            || R04@4stepD2S@3
op:"mov" MemR04_4, sv || "addsubrnd" MemR04_4_copy, p0, p1, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x98E>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p0 & p1
unimpl
# 8873h TL2 mov  MemR04@8, sv || sub3 MemR04@8, p0, p1, b1 || R04@8stepII2@3
op:"mov" MemR04_8, sv || "sub3" MemR04_8_copy, p0, p1, b1 || R04_8_stepII2_3
	is opcode_9_15=(0x88>>1) & MemR04_8 & MemR04_8_copy & opcode_4_7=7 & R04_8_stepII2_3 & opcode_0_2=3 & sv & p0 & p1 & b1
unimpl
# D4C0h TL2 mov  MemR45@5, Abh@2 || mov MemR01@5, Abl@2
#            || R01@5stepII2@0, R45@5stepII2@1
op:"mov" MemR45_5, Abh_2 || "mov" MemR01_5, Abl_2 || R01_5_stepII2_0, R45_5_stepII2_1
	is opcode_6_15=(0xD4C>>2) & MemR45_5 & MemR01_5 & opcode_4_4=0 & Abh_2 & Abl_2 & R45_5_stepII2_1 & R01_5_stepII2_0
{
	Abh_2 = MemR45_5;
	Abl_2 = MemR01_5;
	build R01_5_stepII2_0;
	build R45_5_stepII2_1;
}
# 4D90h TL2 mov  MemR7Imm16@16, ArArpSttMod@0
op:"mov" MemR7Imm16, ArArpSttMod_0 is opcode_4_15=0x4D9 & ArArpSttMod_0; MemR7Imm16 { ArArpSttMod_0 = MemR7Imm16; }
# D2DCh TL2 mov  MemR7Imm16@16, repc, Unused2@0, Unused1@10
op:"mov" MemR7Imm16, repc is opcode_11_15=(0xD2>>3) & unused_10_10 & opcode_2_9=(0x2DC>>2) & unused_0_1 & repc; MemR7Imm16 { repc = MemR7Imm16; }
# 1B20h TL2 mov  MemRn@0, r6 || Rn@0stepZIDS@3 ;override 1800h (mov a1,MemRn@0)
op:"mov" MemRn_0, r6 || Rn_0_stepZIDS_3 is opcode_5_15=(0x1B2>>1) & Rn_0_stepZIDS_3 & MemRn_0 & r6 { r6 = MemRn_0; build Rn_0_stepZIDS_3; }
# D29Ch TL2 mov  MemSp, r6, Unused2@0, Unused1@10
op:"mov" MemSp, r6 is opcode_11_15=(0xD2>>3) & unused_10_10 & opcode_2_9=(0x29C>>2) & unused_0_1 & r6 & MemSp { r6 = MemSp; }
# 8A73h TL2 mov  mixp, Bx@3
op:"mov" mixp, Bx_3 is opcode_4_15=0x8A7 & Bx_3 & opcode_0_2=3 & mixp { Bx_3 = zext(mixp); } # TODO: extension
# 4381h TL2 mov  mixp, r6
op:"mov" mixp, r6 is opcode_0_15=0x4381 & mixp & r6 { r6 = mixp; }
# 4382h TL2 mov  p0h, Bx@0
op:"mov" p0h, Bx_0 is opcode_1_15=(0x4382>>1) & Bx_0 & p0h { Bx_0 = zext(p0h); } # TODO: extension
# D3C2h TL2 mov  p0h, r6
op:"mov" p0h, r6 is opcode_0_15=0xD3C2 & p0h & r6 { r6 = p0h; }
# 4B60h TL2 mov  p0h, Register@0     ;<-- here "p0h" as source
# TODO: ... as opposed to the other ones, where p0h isn't the source? Is this supposed to indicate NoReverse or something?
# Or is this supposed to be something related to Register_0 vs Register_P_0?
op:"mov" p0h, Register_0 is opcode_5_15=(0x4B6>>1) & Register_0 & p0h { Register_0 = p0h; }
# 8FD8h TL2 mov  p1, Ab@0
op:"mov" p1, Ab_0 is opcode_2_15=(0x8FD8>>2) & Ab_0 & p1 { Ab_0 = zext(p1); } # TODO: extension? If it's actually even needed?
# 88D0h TL2 mov  Px@1, MemR0425@8_MemR0425@8offsZIDZ@2   || R0425@8stepII2D2S@2
op:"mov" Px_1, MemR0425_8^"_"^MemR0425_8_offsZIDZ_2 || R0425_8_stepII2D2S_2
	is opcode_10_15=(0x88>>2) & MemR0425_8 & opcode_4_7=0xD & MemR0425_8_offsZIDZ_2 & R0425_8_stepII2D2S_2 & Px_1 & opcode_0_0=0
unimpl
# 88D1h TL2 mov  Px@1, MemR0425@8_MemR0425@8offsZIDZ@2,s || R0425@8stepII2D2S@2
op:"mov" Px_1, MemR0425_8^"_"^MemR0425_8_offsZIDZ_2^",s" || R0425_8_stepII2D2S_2
	is opcode_10_15=(0x88>>2) & MemR0425_8 & opcode_4_7=0xD & MemR0425_8_offsZIDZ_2 & R0425_8_stepII2D2S_2 & Px_1 & opcode_0_0=1
unimpl
# TODO: what is ",s"?
# D481h TL2 mov  r6, Bx@8
op:"mov" r6, Bx_8 is opcode_9_15=(0xD4>>1) & Bx_8 & opcode_0_7=0x81 & r6 { Bx_8 = zext(r6); } # TODO: extension
# 1B00h TL2 mov  r6, MemRn@0 || Rn@0stepZIDS@3 ;override 1800h (mov a0,MemRn@0)
op:"mov" r6, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x1B0>>1) & Rn_0_stepZIDS_3 & MemRn_0 & r6 { MemRn_0 = r6; build Rn_0_stepZIDS_3; }
# 43C1h TL2 mov  r6, mixp
op:"mov" r6, mixp is opcode_0_15=0x43C1 & r6 & mixp { mixp = r6; }
# 5F00h TL2 mov  r6, Register@0
op:"mov" r6, Register_0 is opcode_5_15=(0x5F0>>1) & Register_0 & r6 { Register_0 = r6; }
# 5F60h TL2 mov  Register@0, r6
op:"mov" Register_0, r6 is opcode_5_15=(0x5F6>>1) & Register_0 & r6 { r6 = Register_0; }
# D2D9h TL2 mov  repc, Abl@10
op:"mov" repc, Abl_10 is opcode_12_15=0xD & Abl_10 & opcode_0_9=0x2D9 & repc { Abl_10 = repc; }
# D7D0h TL2 mov  repc, MemR04@1 || R04@1stepII2@0
op:"mov" repc, MemR04_1 || R04_1_stepII2_0 is opcode_2_15=(0xD7D0>>2) & MemR04_1 & R04_1_stepII2_0 & repc { MemR04_1 = repc; build R04_1_stepII2_0; }
# D3C8h TL2 mov  repc, MemR7Imm16@16, Unused3@0
op:"mov" repc, MemR7Imm16 is opcode_3_15=(0xD3C8>>3) & unused_0_2 & repc; MemR7Imm16 { MemR7Imm16 = repc; }
# D482h TL2 mov  stepi0, a0h
op:"mov" stepi0, a0h is opcode_0_15=0xD482 & stepi0 & a0h { a0h = stepi0; }
# D582h TL2 mov  stepj0, a0h
op:"mov" stepj0, a0h is opcode_0_15=0xD582 & stepj0 & a0h { a0h = stepj0; }
# D2F8h TL2 mov  SttMod@0, Abl@10
op:"mov" SttMod_0, Abl_10 is opcode_12_15=0xD & Abl_10 & opcode_3_9=(0x2F8>>3) & SttMod_0 { Abl_10 = SttMod_0; }
# 49C1h TL2 mov  x1, Ab@4
op:"mov" x1, Ab_4 is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_0_3=1 & x1 { Ab_4 = zext(x1); } # TODO: extension
# D299h TL2 mov  y1, Ab@10
op:"mov" y1, Ab_10 is opcode_12_15=0xD & Ab_10 & opcode_0_9=0x299 & y1 { Ab_10 = zext(y1); } # TODO: extension
# 5EB0h TL2 mov  prpage, Abl@0
op:"mov" prpage, Abl_0 is opcode_2_15=(0x5EB0>>2) & Abl_0 & prpage { Abl_0 = prpage; }
# 49A0h TL2 mov  SttMod@0, MemR04@4 || R04@4stepII2@3
op:"mov" SttMod_0, MemR04_4 || R04_4_stepII2_3 is opcode_5_15=(0x49A>>1) & MemR04_4 & R04_4_stepII2_3 & SttMod_0 { MemR04_4 = SttMod_0; build R04_4_stepII2_3; }
# 4DC0h TL2 mova Ab@4, MemR0425@2_MemR0425@2offsZIDZ@0 || R0425@2stepII2D2S@0
op:"mova" Ab_4, MemR0425_2^"_"^MemR0425_2_offsZIDZ_0 || R0425_2_stepII2D2S_0
	is opcode_6_15=(0x4DC>>2) & Ab_4 & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0
unimpl
# 4BC0h TL2 mova MemR0425@2_MemR0425@2offsZIDZ@0, Ab@4 || R0425@2stepII2D2S@0
op:"mova" MemR0425_2^"_"^MemR0425_2_offsZIDZ_0, Ab_4 || R0425_2_stepII2D2S_0
	is opcode_6_15=(0x4BC>>2) & Ab_4 & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0
unimpl
@endif
# 5F80h TL  movd MemR0123@0,ProgMemR45@2 || R0123@0stepZIDS@3, R45@2stepZIDS@5
# TODO: write to progmem?
op:"movd" MemR0123_0, ProgMemR45_2 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5
	is opcode_7_15=(0x5F8>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & ProgMemR45_2 & MemR0123_0
{
	ProgMemR45_2 = MemR0123_0;
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 0040h TL  movp ProgMemAxl@5, Register@0
op:"movp" ProgMemAxl_5, Register_0 is opcode_6_15=(0x004>>2) & ProgMemAxl_5 & Register_0 { Register_0 = ProgMemAxl_5; }
@ifdef TEAK_LITE_2
# 0D40h TL2 movp ProgMemAx@5, Register@0
op:"movp" ProgMemAx_5, Register_0 is opcode_6_15=(0x064>>2) & ProgMemAx_5 & Register_0 { Register_0 = ProgMemAx_5; }
@endif
# 0600h TL  movp ProgMemRn@0, MemR0123@5 || R0123@5stepZIDS@7, Rn@0stepZIDS@3
op:"movp" ProgMemRn_0, MemR0123_5 || R0123_5_stepZIDS_7, Rn_0_stepZIDS_3
	is opcode_9_15=(0x06>>1) & R0123_5_stepZIDS_7 & MemR0123_5 & Rn_0_stepZIDS_3 & ProgMemRn_0
{
	MemR0123_5 = ProgMemRn_0;
	build R0123_5_stepZIDS_7;
	build Rn_0_stepZIDS_3;
}
@ifdef TEAK_LITE_2
# D499h TL2 movpdw ProgMemAx@8_ProgMemAx@8offsI, pc
op:"movpdw" ProgMemAx_8^"_"^ProgMemAx_8_offsI, pc is opcode_9_15=(0xD4>>1) & ProgMemAx_8 & ProgMemAx_8_offsI & opcode_0_7=0x99 & pc unimpl
@endif
# 8864h TL  movr MemR0425@3, Abh@8 || R0425@3stepII2D2S@0   ;op*10000h+8000h
# TODO: rounding?
op:"movr" MemR0425_3, Abh_8 || R0425_3_stepII2D2S_0 is opcode_10_15=(0x88>>2) & Abh_8 & opcode_5_7=(6>>1) & MemR0425_3 & opcode_2_2=1 & R0425_3_stepII2D2S_0 {
	Abh_8 = MemR0425_3;
	build R0425_3_stepII2D2S_0;
}
# 9CE0h TL  movr MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"movr" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0xE>>1) & Rn_0_stepZIDS_3 & MemRn_0 {
	Ax_8 = zext(MemRn_0);
	build Rn_0_stepZIDS_3;
}
# 9CC0h TL  movr RegisterP0@0, Ax@8
op:"movr" Register_P_0, Ax_8 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0xC>>1) & Register_P_0 { Ax_8 = zext(Register_P_0); }
@ifdef TEAK_LITE_2
# 5DF4h TL2 movr Bx@1, Ax@0
op:"movr" Bx_1, Ax_0 is opcode_2_15=(0x5DF4>>2) & Bx_1 & Ax_0 { Ax_0 = Bx_1; }
# 8961h TL2 movr r6, Ax@3
op:"movr" r6, Ax_3 is opcode_4_15=0x896 & Ax_3 & opcode_0_2=1 & r6 { Ax_3 = zext(r6); }
@endif
# 6300h TL  movs Implied sv, MemImm8@0, Ab@11
# TODO: what does this do and what does sv do?
op:"movs" MemImm8_0, Ab_11 is opcode_12_15=6 & Ab_11 & opcode_8_10=3 & MemImm8_0 { Ab_11 = zext(MemImm8_0); }
# 0180h TL  movs Implied sv, MemRn@0, Ab@5 || Rn@0stepZIDS@3
op:"movs" MemRn_0, Ab_5 || Rn_0_stepZIDS_3 is opcode_7_15=(0x018>>3) & Ab_5 & Rn_0_stepZIDS_3 & MemRn_0 { Ab_5 = zext(MemRn_0); build Rn_0_stepZIDS_3; }
# 0100h TL  movs Implied sv, RegisterP0@0, Ab@5
op:"movs" Register_P_0, Ab_5 is opcode_7_15=(0x010>>3) & Ab_5 & Register_P_0 { Ab_5 = zext(Register_P_0); }
@ifdef TEAK_LITE_2
# 5F42h TL2 movs Implied sv, r6, Ax@0
op:"movs" r6, Ax_0 is opcode_1_15=(0x5F42>>1) & Ax_0 & r6 { Ax_0 = zext(r6); }
@endif
# 4080h TL  movsi Implied Imm5s@0, R0123457y0@9, Ab@5, Bogus Imm5s@0
# TODO: OK, this is trying to indicate a different order or something? But what is it doing? Hardcoding a value for sv?
op:"movsi" Imm5s_0, R0123457y0_9, Ab_5 is opcode_12_15=4 & R0123457y0_9 & opcode_7_8=(0x08>>3) & Ab_5 & Imm5s_0 { Ab_5 = zext(R0123457y0_9); }
# D000h TL  mpy  MemR45@2, MemR0123@0 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"mpy" MemR45_2, MemR0123_0 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_7_15=(0xD00>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8000h TL  mpy  MemRn@0, Imm16@16    || Rn@0stepZIDS@3
op:"mpy" MemRn_0, Imm16 || Rn_0_stepZIDS_3 is opcode_5_15=(0x800>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8020h TL  mpy  y0, MemRn@0          || Rn@0stepZIDS@3
op:"mpy" y0, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x802>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8040h TL  mpy  y0, Register@0
op:"mpy" y0, Register_0 is opcode_5_15=(0x804>>1) & Register_0 & y0 unimpl
# E000h TL  mpy  y0, MemImm8@0
op:"mpy" y0, MemImm8_0 is opcode_8_15=0xE0 & MemImm8_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 5EA0h TL2 mpy  y0, r6
op:"mpy" y0, r6 is opcode_0_15=0x5EA0 & y0 & r6 unimpl
# CB00h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
# opcode_0_0: mpysu vs mpyus
# opcode_1_1: sub3 vs sub3a or add3 vs add3a
# opcode_2_2: sub vs add
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=0 & p0 & p1
unimpl
# CB01h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=1 & p0 & p1
unimpl
# CB02h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=2 & p0 & p1
unimpl
# CB03h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=3 & p0 & p1
unimpl
# CB04h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=4 & p0 & p1
unimpl
# CB05h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=5 & p0 & p1
unimpl
# CB06h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=6 & p0 & p1
unimpl
# CB07h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=7 & p0 & p1
unimpl
# D5E0h TL2 mpy  MemR04@1, x1 || mpy y1, x0 || sub3 p0, p1, Ax@3
#            || R04@1stepII2@0
op:"mpy" MemR04_1, x1 || "mpy" y1, x0 || "sub3" p0, p1, Ax_3 || R04_1_stepII2_0
	is opcode_5_15=(0xD5E>>1) & MemR04_1 & Ax_3 & opcode_2_2=0 & R04_1_stepII2_0 & x1 & y1 & x0 & p0 & p1
unimpl
# D5E4h TL2 mpy  MemR04@1, x1 || mpy y1, x0 || add3 p0, p1, Ax@3
#            || R04@1stepII2@0
op:"mpy" MemR04_1, x1 || "mpy" y1, x0 || "add3" p0, p1, Ax_3 || R04_1_stepII2_0
	is opcode_5_15=(0xD5E>>1) & MemR04_1 & Ax_3 & opcode_2_2=1 & R04_1_stepII2_0 & x1 & y1 & x0 & p0 & p1
unimpl
# C800h TL2 mpy  MemR4567@4, MemR0123@4
#            || mpy MemR4567@4offsZIDZ@2, MemR0123@4offsZIDZ@0
#            || add3 p0, p1, Ab@6 || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mpy" MemR4567_4, MemR0123_4 || "mpy" MemR4567_4_offsZIDZ_2, MemR0123_4_offsZIDZ_0 || "add3" p0, p1, Ab_6 || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_8_15=0xC8 & Ab_6 & MemR4567_4 & MemR0123_4 & MemR4567_4_offsZIDZ_2 & R4567_4_stepII2D2S_2 & MemR0123_4_offsZIDZ_0 & R0123_4_stepII2D2S_0 & p0 & p1
unimpl
# C900h TL2 mpy  MemR4567@4, MemR0123@4
#            || mpy MemR4567@4offsZIDZ@2, MemR0123@4offsZIDZ@0
#            || sub3 p0, p1, Ab@6 || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mpy" MemR4567_4, MemR0123_4 || "mpy" MemR4567_4_offsZIDZ_2, MemR0123_4_offsZIDZ_0 || "sub3" p0, p1, Ab_6 || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_8_15=0xC9 & Ab_6 & MemR4567_4 & MemR0123_4 & MemR4567_4_offsZIDZ_2 & R4567_4_stepII2D2S_2 & MemR0123_4_offsZIDZ_0 & R0123_4_stepII2D2S_0 & p0 & p1
unimpl
# 80C2h TL2 mpy  MemR45@0, MemR01@0 || mpy MemR45@0offsZI@9, MemR01@0offsZI@8
#            || add3a p0, p1, Ab@10 || R01@0stepII2@8, R45@0stepII2@9
op:"mpy" MemR45_0, MemR01_0 || "mpy" MemR45_0_offsZI_9, MemR01_0_offsZI_8 || "add3a" p0, p1, Ab_10 || R01_0_stepII2_8, R45_0_stepII2_9
	is opcode_12_15=8 & Ab_10 & MemR45_0_offsZI_9 & R45_0_stepII2_9 & MemR01_0_offsZI_8 & R01_0_stepII2_8 & opcode_1_7=(0xC2>>1) & MemR45_0 & MemR01_0 & p0 & p1
unimpl
# 49C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || sub3a p0, p1, Ab@4 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "sub3a" p0, p1, Ab_4 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_3_3=1 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1
unimpl
# 80C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || addsub  p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "addsub" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x0C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1
unimpl
# 81C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || addsuba p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "addsuba" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x1C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1
unimpl
# 82C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || add     p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "add" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x2C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1
unimpl
# 83C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || adda    p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "adda" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x3C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1
unimpl
# 00C0h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || sub  p0, p1, Ab@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "sub" p0, p1, Ab_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_6_15=(0x00C>>2) & Ab_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=0 & p0 & p1
unimpl
# 00C1h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || suba p0, p1, Ab@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "suba" p0, p1, Ab_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_6_15=(0x00C>>2) & Ab_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=1 & p0 & p1
unimpl
# 0D20h TL2 mpy  MemR45@3, MemR01@3 || mpyus MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3a p0, p1, Ax@0, dmodi || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpyus" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3" p0, p1, Ax_0, "dmodi" || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_4_15=0x0D2 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & Ax_0 & p0 & p1
unimpl
# 0D30h TL2 mpy  MemR45@3, MemR01@3 || mpyus MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3a p0, p1, Ax@0, dmodj || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpyus" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3" p0, p1, Ax_0, "dmodj" || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_4_15=0x0D3 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & Ax_0 & p0 & p1
unimpl
# 4B50h TL2 mpy  MemR45@3, MemR01@3 || mpyus MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3a p0, p1, Ax@0, dmodij || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpyus" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3" p0, p1, Ax_0, "dmodij" || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_4_15=0x4B5 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & Ax_0 & p0 & p1
unimpl
# D7A0h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3    sv, p0, p1, Ax@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3" sv, p0, p1, Ax_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_5_15=(0xD7A>>1) & Ax_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=0 & sv & p0 & p1
unimpl
# D7A1h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3rnd sv, p0, p1, Ax@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3rnd" sv, p0, p1, Ax_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_5_15=(0xD7A>>1) & Ax_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=1 & sv & p0 & p1
unimpl
# 9861h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3  p0, p1, Ax@8, dmodj  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3" p0, p1, Ax_8, "dmodj" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x6>>1) &  MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=1 & p0 & p1
unimpl
# 9862h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3  p0, p1, Ax@8, dmodi  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3" p0, p1, Ax_8, "dmodi" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x6>>1) &  MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=2 & p0 & p1
unimpl
# 9863h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3  p0, p1, Ax@8, dmodij || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3" p0, p1, Ax_8, "dmodij" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x6>>1) &  MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=3 & p0 & p1
unimpl
# 98E1h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3a p0, p1, Ax@8, dmodj  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3a" p0, p1, Ax_8, "dmodj" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xE>>1) &  MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=1 & p0 & p1
unimpl
# 98E2h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3a p0, p1, Ax@8, dmodi  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3a" p0, p1, Ax_8, "dmodi" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xE>>1) &  MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=2 & p0 & p1
unimpl
# 98E3h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3a p0, p1, Ax@8, dmodij || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3a" p0, p1, Ax_8, "dmodij" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xE>>1) &  MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=3 & p0 & p1
unimpl
# 4DA0h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || sub3  p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "sub3" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=0 & y0 & y1 & p0 & p1
unimpl
# 4DA1h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || sub3a p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "sub3a" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=1 & y0 & y1 & p0 & p1
unimpl
# 4DA2h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || add3  p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "add3" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=2 & y0 & y1 & p0 & p1
unimpl
# 4DA3h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || add3a p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "add3a" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=3 & y0 & y1 & p0 & p1
unimpl
# 94E0h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || sub3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "sub3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=0 & y0 & y1 & p0 & p1
unimpl
# 94E2h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || sub3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "sub3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=2 & y0 & y1 & p0 & p1
unimpl
# 94E4h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || add3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "add3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=4 & y0 & y1 & p0 & p1
unimpl
# 94E6h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || add3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "add3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=6 & y0 & y1 & p0 & p1
unimpl
# 94E1h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || sub3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "sub3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=1 & y0 & y1 & p0 & p1
unimpl
# 94E3h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || sub3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "sub3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=3 & y0 & y1 & p0 & p1
unimpl
# 94E5h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || add3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "add3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=5 & y0 & y1 & p0 & p1
unimpl
# 94E7h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || add3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "add3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=7 & y0 & y1 & p0 & p1
unimpl
# 8862h TL2 mpy  y0, x1 || mpy   MemR04@4, x0 || sub3  p0, p1, Ax@8
#            || R04@4stepII2@3
op:"mpy" y0, x1 || "mpy" MemR04_4, x0 || "sub3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x88>>1) & Ax_8 & opcode_5_7=(6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=2 & y0 & x1 & x0 & p0 & p1
unimpl
# 8A62h TL2 mpy  y0, x1 || mpy   MemR04@4, x0 || add3  p0, p1, Ax@8
#            || R04@4stepII2@3
op:"mpy" y0, x1 || "mpy" MemR04_4, x0 || "add3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x8A>>1) & Ax_8 & opcode_5_7=(6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=2 & y0 & x1 & x0 & p0 & p1
unimpl
# 4D88h TL2 mpy  y0, x1 || mpy   y1, x0 || sub p0, p1, Ax@1
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub" p0, p1, Ax_1 is opcode_2_15=(0x4D88>>2) & Ax_1 & opcode_0_0=0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 5E24h TL2 mpy  y0, x1 || mpy   y1, x0 || add p0, p1, Ab@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "add" p0, p1, Ab_0 is opcode_2_15=(0x5E24>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8061h TL2 mpy  y0, x1 || mpy   y1, x0 || add3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x61 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8071h TL2 mpy  y0, x1 || mpy   y1, x0 || add3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3a" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x71 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8461h TL2 mpy  y0, x1 || mpy   y1, x0 || sub3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub3" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x61 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8471h TL2 mpy  y0, x1 || mpy   y1, x0 || sub3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub3a" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x71 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# D484h TL2 mpy  y0, x1 || mpy   y1, x0 || add3aa p0, p1, Ab@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3aa" p0, p1, Ab_0 is opcode_2_15=(0xD484>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# D49Dh TL2 mpy  y0, x1 || mpy   y1, x0 || sub p0, p1, Bx@5
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub" p0, p1, Bx_5 is opcode_6_15=(0xD49>>2) & Bx_5 & opcode_0_4=0x1D & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# D4A0h TL2 mpy  y0, x1 || mpy   y1, x0 || addsub p0, p1, Ab@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" p0, p1, Ab_0 is opcode_2_15=(0xD4A0>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 4FA0h TL2 mpy  y0, x1 || mpy y1, x0 || add3 p0, p1, Ab@3
#            || mov Axh@6, MemR04@1 || mov Bxh@2, MemR04@1offsZI@0
#            || R04@1stepII2@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3" p0, p1, Ab_3 || "mov" Axh_6, MemR04_1 || "mov" Bxh_2, MemR04_1_offsZI_0 || R04_1_stepII2_0
	is opcode_7_15=(0x4FA>>3) & Axh_6 & opcode_5_5=(2>>1) & Ab_3 & Bxh_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 & x0 & x1 & y0 & y1 & p0 & p1
unimpl
# 5818h TL2 mpy  y0, x1 || mpy y1, x0 || addsub    sv, p0, p1, Ax@0
#            || mov Axh@0, MemR0425@7 || mov Axh@not0, MemR0425@7offsZI@6
#            || R0425@7stepII2@6  ;override 5800h+18h (mov a0, Register)
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" sv, p0, p1, Ax_0 || "mov" Axh_0, MemR0425_7 || "mov" Axh_Not0, MemR0425_7_offsZI_6 || R0425_7_stepII2_6
	is opcode_9_15=(0x58>>1) & MemR0425_7 & MemR0425_7_offsZI_6 & R0425_7_stepII2_6 & opcode_1_5=(0x18>>1) & Ax_0 & Axh_0 & Axh_Not0 & x0 & x1 & y0 & y1 & sv & p0 & p1
unimpl
# 5838h TL2 mpy  y0, x1 || mpy y1, x0 || addsubrnd sv, p0, p1, Ax@0
#            || mov Axh@0, MemR0425@7 || mov Axh@not0, MemR0425@7offsZI@6
#            || R0425@7stepII2@6  ;override 5800h+38h (mov a1, Register)
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" sv, p0, p1, Ax_0 || "mov" Axh_0, MemR0425_7 || "mov" Axh_Not0, MemR0425_7_offsZI_6 || R0425_7_stepII2_6
	is opcode_9_15=(0x58>>1) & MemR0425_7 & MemR0425_7_offsZI_6 & R0425_7_stepII2_6 & opcode_1_5=(0x38>>1) & Ax_0 & Axh_0 & Axh_Not0 & x0 & x1 & y0 & y1 & sv & p0 & p1
unimpl
# 80D0h TL2 mpy  y0, x1 || mpy y1, x0 || addsub    sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=0 & x0 & x1 & y0 & y1 & sv & p0 & p1
unimpl
# 80D1h TL2 mpy  y0, x1 || mpy y1, x0 || addsubrnd sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsubrnd" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=1 & x0 & x1 & y0 & y1 & sv & p0 & p1
unimpl
# 80D2h TL2 mpy  y0, x1 || mpy y1, x0 || add3      sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=2 & x0 & x1 & y0 & y1 & sv & p0 & p1
unimpl
# 80D3h TL2 mpy  y0, x1 || mpy y1, x0 || add3rnd   sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3rnd" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=3 & x0 & x1 & y0 & y1 & sv & p0 & p1
unimpl
# D3A0h TL2 mpy  y0, x1 || mpy y1, x0 || addsub p0, p1, Ab@3
#            || mov Axh@6, MemR04@1 || mov Bxh@2, MemR04@1offsZI@0
#            || R04@1stepII2@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" p0, p1, Ab_3 || "mov" Axh_6, MemR04_1 || "mov" Bxh_2, MemR04_1_offsZI_0 || R04_1_stepII2_0
	is opcode_7_15=(0xD3A>>3) & Axh_6 & opcode_5_5=(2>>1) & Ab_3 & Bxh_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 & x0 & x1 & y0 & y1 & p0 & p1
unimpl
# 4D89h TL2 mpy  y0, x1 || mpyus y1, x0 || sub p0, p1, Ax@1
op:"mpy" y0, x1 || "mpyus" y1, x0 || "sub" p0, p1, Ax_1 is opcode_2_15=(0x4D89>>2) & Ax_1 & opcode_0_0=1 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 5F24h TL2 mpy  y0, x1 || mpyus y1, x0 || add p0, p1, Ab@0
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add" p0, p1, Ab_0 is opcode_2_15=(0x5F24>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8069h TL2 mpy  y0, x1 || mpyus y1, x0 || add3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x69 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8079h TL2 mpy  y0, x1 || mpyus y1, x0 || add3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x79 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8469h TL2 mpy  y0, x1 || mpyus y1, x0 || sub3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x69 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# 8479h TL2 mpy  y0, x1 || mpyus y1, x0 || sub3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x79 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# D584h TL2 mpy  y0, x1 || mpyus y1, x0 || add3aa p0, p1, Ab@0
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3aa" p0, p1, Ab_0 is opcode_2_15=(0xD584>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# D59Dh TL2 mpy  y0, x1 || mpyus y1, x0 || sub p0, p1, Bx@5
op:"mpy" y0, x1 || "mpyus" y1, x0 || "sub" p0, p1, Bx_5 is opcode_6_15=(0xD59>>2) & Bx_5 & opcode_0_4=(0x1D) & x0 & x1 & y0 & y1 & p0 & p1 unimpl
# D5A0h TL2 mpy  y0, x1 || mpyus y1, x0 || addsub p0, p1, Ab@0
op:"mpy" y0, x1 || "mpyus" y1, x0 || "addsub" p0, p1, Ab_0 is opcode_2_15=(0xD5A0>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 unimpl
@endif
# 0800h TL  mpyi NoReverse, Implied p0, y0, Imm8s@0   ;multiply  ;aka "mpys"
op:"mpyi" y0, Imm8s_0 is opcode_8_15=0x08 & Imm8s_0 & y0 unimpl
# D100h TL  mpysu MemR45@2, MemR0123@0 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"mpysu" MemR45_2, MemR0123_0 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_7_15=(0xD10>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 8100h TL  mpysu MemRn@0, Imm16@16    || Rn@0stepZIDS@3
op:"mpysu" MemRn_0, Imm16 || Rn_0_stepZIDS_3 is opcode_5_15=(0x810>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8120h TL  mpysu y0, MemRn@0          || Rn@0stepZIDS@3
op:"mpysu" y0, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x812>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 8140h TL  mpysu y0, Register@0
op:"mpysu" y0, Register_0 is opcode_5_15=(0x814>>1) & Register_0 & y0 unimpl
@ifdef TEAK_LITE_2
# CA00h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=0 & p0 & p1
unimpl
# CA01h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=1 & p0 & p1
unimpl
# CA02h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=2 & p0 & p1
unimpl
# CA03h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=3 & p0 & p1
unimpl
# CA04h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=4 & p0 & p1
unimpl
# CA05h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=5 & p0 & p1
unimpl
# CA06h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=6 & p0 & p1
unimpl
# CA07h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=7 & p0 & p1
unimpl
# 5EA2h TL2 mpysu y0, r6
op:"mpysu" y0, r6 is opcode_0_15=0x5EA2 & y0 & r6 unimpl
@endif
# D080h TL  msu  MemR45@2,MemR0123@0,Ax@8 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"msu" MemR45_2, MemR0123_0, Ax_8 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_9_15=(0xD0>>1) & Ax_8 & opcode_7_7=1 & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 unimpl
# 90C0h TL  msu  MemRn@0, Imm16@16,  Ax@8 || Rn@0stepZIDS@3 ;multiply, subtract
op:"msu" MemRn_0, Imm16, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0xC>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 9080h TL  msu  y0, MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"msu" y0, MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 unimpl
# 90A0h TL  msu  y0, Register@0, Ax@8
op:"msu" y0, Register_0, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 & y0 unimpl
# B000h TL  msu  y0,MemImm8@0, Ax@8
op:"msu" y0, MemImm8_0, Ax_8 is opcode_9_15=(0xB0>>1) & Ax_8 & MemImm8_0 & y0 unimpl
@ifdef TEAK_LITE_2
# 9462h TL2 msu  y0, r6, Ax@0
op:"msu" y0, r6, Ax_0 is opcode_1_15=(0x9462>>1) & Ax_0 & r6 & y0 unimpl
# 8264h TL2 msusu y0, MemR0425@3, Ax@8 || R0425@3stepII2D2S@0
op:"msusu" y0, MemR0425_3, Ax_8 || R0425_3_stepII2D2S_0 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(0x6>>1) & MemR0425_3 & opcode_2_2=1 & R0425_3_stepII2D2S_0 & y0 unimpl
@endif
# 6790h TL  neg  Ax@12, Cond@0 ;aX=0-aX
op:"neg" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x79 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = -Ax_12;
}
op:"neg" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x79 & cond_0=0 { Ax_12 = -Ax_12; }
# 0000h TL  nop
op:"nop" is opcode_0_15=0x0000 {}
# 94C0h TL  norm Ax@8, Bogus MemRn@0 || Rn@0stepZIDS@3  ;if N=0 (aX=aX*2,rN+/-)
op:"norm" Ax_8, MemRn_0 || Rn_0_stepZIDS_3 is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xC>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 6780h TL  not  Ax@12, Cond@0 ;aX=not aX
op:"not" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x78 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = ~Ax_12;
}
op:"not" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x78 & cond_0=0 { Ax_12 = ~Ax_12; }
# D4F8h TL  or   MemImm16@16, Ax@8
op:"or" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xF8; MemImm16 { Ax_8 = Ax_8 | zext(MemImm16); }
# A000h TL  or   MemImm8@0, Ax@8
op:"or" MemImm8_0, Ax_8 is opcode_9_15=(0xA0>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 | zext(MemImm8_0); }
# 80C0h TL  or   Imm16@16, Ax@8
op:"or" Imm16, Ax_8 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 | zext(Imm16); }
# C000h TL  or   Imm8u@0, Ax@8
op:"or" Imm8u_0, Ax_8 is opcode_9_15=(0xC0>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 | zext(Imm8u_0); }
# D4D8h TL  or   MemR7Imm16@16, Ax@8
op:"or" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xD8; MemR7Imm16 { Ax_8 = Ax_8 | zext(MemR7Imm16); }
# 4000h TL  or   MemR7Imm7s@0, Ax@8
op:"or" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x40>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 | zext(MemR7Imm7s_0); }
# 8080h TL  or   MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"or" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_5_7=(8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 | zext(MemRn_0); build Rn_0_stepZIDS_3; }
# 80A0h TL  or   RegisterP0@0, Ax@8
op:"or" Register_P_0, Ax_8 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_P_0 { Ax_8 = Ax_8 | zext(Register_P_0); }
@ifdef TEAK_LITE_2
# D291h TL2 or   Ab@10, Ax@6, Ax@5
# TODO: which are the sources and which is the destination?
op:"or" Ab_10, Ax_6, Ax_5 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x29>>3) & Ax_6 & Ax_5 & opcode_0_4=0x11 unimpl
# D4A4h TL2 or   Ax@8, Bx@1, Ax@0
op:"or" Ax_8, Bx_1, Ax_0 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_2_7=(0xA4>>2) & Bx_1 & Ax_0 unimpl
# D3C4h TL2 or   b0, Bx@1, Ax@0
op:"or" b0, Bx_1, Ax_0 is opcode_2_15=(0xD3C4>>2) & Bx_1 & Ax_0 & b0 unimpl
# D7C4h TL2 or   b1, Bx@1, Ax@0
op:"or" b1, Bx_1, Ax_0 is opcode_2_15=(0xD7C4>>2) & Bx_1 & Ax_0 & b1 unimpl
# D388h TL2 or   r6, Ax@4
op:"or" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=8 & r6 unimpl
@endif
# 67B0h TL  pacr Implied Const8000h, Implied p0, Ax@12, Cond@0 ;aX=shfP+8000h
op:"pacr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7B & Cond_0 unimpl
op:"pacr" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7B & cond_0=0 unimpl
@ifdef TEAK_LITE_2
# D7C2h TL2 pacr1 Implied Const8000h, Implied p1, Ax@0
op:"pacrl" Ax_0 is opcode_1_15=(0xD7C2>>1) & Ax_0 unimpl
@endif
# 5E60h TL  pop  Register@0
op:"pop" Register_0 is opcode_5_15=(0x5E60>>5) & Register_0 {
	Register_0 = *[data]:2 sp;
	sp = sp + 1;
}
@ifdef TEAK_LITE_2
# 47B4h TL2 pop  Abe@0
op:"pop" Abe_0 is opcode_2_15=(0x47B4>>2) & Abe_0 {
	Abe_0 = *[data]:2 sp;
	sp = sp + 1;
}
# 80C7h TL2 pop  ArArpSttMod@8
op:"pop" ArArpSttMod_8 is opcode_12_15=0x8 & ArArpSttMod_8 & opcode_0_7=0xc7 {
	ArArpSttMod_8 = *[data]:2 sp;
	sp = sp + 1;
}
# 0006h TL2 pop  Bx@5, Unused1@0
op:"pop" Bx_5 is opcode_6_15=0 & Bx_5 & opcode_1_4=(6>>1) & unused_0_0 {
	Bx_5 = *[data]:2 sp;
	sp = sp + 1;
}
# D7F4h TL2 pop  prpage, Unused2@0
op:"pop" prpage is opcode_2_15=(0xD7F4>>2) & unused_0_1 & prpage {
	prpage = *[data]:2 sp;
	sp = sp + 1;
}
# D496h TL2 pop  Px@0
op:"pop" Px_0 is opcode_1_15=(0xD496>>1) & Px_0 {
	Px_0 = *[data]:2 sp;
	sp = sp + 1;
}
# 0024h TL2 pop  r6, Unused1@0
op:"pop" r6 is opcode_1_15=(0x0024>>1) & unused_0_0 & r6 {
	r6 = *[data]:2 sp;
	sp = sp + 1;
}
# D7F0h TL2 pop  repc, Unused2@0
op:"pop" repc is opcode_2_15=(0xD7F0>>2) & unused_0_1 & repc {
	repc = *[data]:2 sp;
	sp = sp + 1;
}
# D494h TL2 pop  x0
op:"pop" x0 is opcode_0_15=0xD494 & x0 {
	x0 = *[data]:2 sp;
	sp = sp + 1;
}
# D495h TL2 pop  x1
op:"pop" x1 is opcode_0_15=0xD495 & x1 {
	x1 = *[data]:2 sp;
	sp = sp + 1;
}
# 0004h TL2 pop  y1, Unused1@0
op:"pop" y1 is opcode_1_15=(4>>1) & unused_0_0 & y1 {
	y1 = *[data]:2 sp;
	sp = sp + 1;
}
# 47B0h TL2 popa Ab@0
op:"popa" Ab_0 is opcode_2_15=(0x47B0>>2) & Ab_0 unimpl
@endif
# 5F40h TL  push Imm16@16
op:"push" Imm16 is opcode_0_15=0x5F40; Imm16 {
	sp = sp - 1;
	*[data]:2 sp = Imm16;
}
# 5E40h TL  push Register@0
op:"push" Register_0 is opcode_5_15=(0x5E40>>5) & Register_0 {
	sp = sp - 1;
	*[data]:2 sp = Register_0;
}
@ifdef TEAK_LITE_2
# D7C8h TL2 push Abe@1, Unused1@0
op:"push" Abe_1 is opcode_2_15=(0xD7C8>>2) & Abe_1 & unused_0_0 {
	sp = sp - 1;
	*[data]:2 sp = Abe_1;
}
# D3D0h TL2 push ArArpSttMod@0
op:"push" ArArpSttMod_0 is opcode_4_15=0xD3D & ArArpSttMod_0 {
	sp = sp - 1;
	*[data]:2 sp = ArArpSttMod_0;
}
# D7FCh TL2 push prpage, Unused2@0
op:"push" prpage is opcode_2_15=(0xD7FC>>2) & unused_0_1 & prpage {
	sp = sp - 1;
	*[data]:2 sp = prpage;
}
# D78Ch TL2 push Px@1, Unused1@0
op:"push" Px_1 is opcode_2_15=(0xD78C>>2) & Px_1 & unused_0_0 {
	sp = sp - 1;
	*[data]:2 sp = Px_1;
}
# D4D7h TL2 push r6, Unused1@5
op:"push" r6 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x17 & r6 {
	sp = sp - 1;
	*[data]:2 sp = r6;
}
# D7F8h TL2 push repc, Unused2@0
op:"push" repc is opcode_2_15=(0xD7F8>>2) & unused_0_1 & repc {
	sp = sp - 1;
	*[data]:2 sp = repc;
}
# D4D4h TL2 push x0, Unused1@5
op:"push" x0 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x14 & x0 {
	sp = sp - 1;
	*[data]:2 sp = x0;
}
# D4D5h TL2 push x1, Unused1@5
op:"push" x1 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x15 & x1 {
	sp = sp - 1;
	*[data]:2 sp = x1;
}
# D4D6h TL2 push y1, Unused1@5
op:"push" y1 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x16 & y1 {
	sp = sp - 1;
	*[data]:2 sp = y1;
}
# 4384h TL2 pusha Ax@6, Unused2@0
op:"pusha" Ax_6 is opcode_7_15=(0x438>>3) & Ax_6 & opcode_2_5=(4>>2) & unused_0_1 unimpl
# D788h TL2 pusha Bx@1, Unused1@0
op:"pusha" Bx_1 is opcode_2_15=(0xD788>>2) & Bx_1 & unused_0_0 unimpl
@endif
AfterLoopWrapper:tmp is epsilon [ tmp = inst_start + 2; ] { export *[code]:2 tmp; }
# 0C00h TL  rep  Imm8u@0    ;repeat next opcode N+1 times
# Note: these should use repc instead of the same system as bkrep, but I don't think there's any
# way to actually observe this in a single-instruction loop.
op:"rep" Imm8u_0 is opcode_8_15=0x0C & Imm8u_0 & AfterLoopWrapper & CurLC [
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Imm8u_0;
}
# 0D00h TL  rep  Register@0 ;repeat next opcode N+1 times
op:"rep" Register_0 is opcode_5_15=(0x0D0>>1) & Register_0 & AfterLoopWrapper & CurLC [
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Register_0;
}
@ifdef TEAK_LITE_2
# 0002h TL2 rep  r6, Unused1@0
op:"rep" r6 is opcode_1_15=(0x0002>>1) & unused_0_0 & r6 & AfterLoopWrapper & CurLC [
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = r6;
}
@endif
# 4580h TL  ret  Cond@0      ;=pop pc
op:"ret" Cond_0 is opcode_4_15=0x458 & Cond_0 {
	if (!Cond_0) goto inst_next;
	# TODO: proper stack
	return [sp];
}
op:"ret" is opcode_4_15=0x458 & cond_0=0 {
	# TODO: proper stack
	return [sp];
}
# D780h TL  retd    ;delayed return (after 2 clks)
# TODO: This assumes every instruction is 1 clock, but http://problemkaputt.de/gbatek-dsi-teak-misc.htm says there are a few exceptions
op:"retd" is opcode_0_15=0xD780 {
	delayslot(2);
	# TODO: proper stack
	return [sp];
}
# 45C0h TL  reti Cond@0          ;Don't context switch
op:"reti" Cond_0 is opcode_4_15=0x45C & Cond_0 {
	if (!Cond_0) goto inst_next;
	# TODO: proper stack
	return [sp];
}
op:"reti" is opcode_4_15=0x45C & cond_0=0 {
	# TODO: proper stack
	return [sp];
}
# 45D0h TL  reti Cond@0, context ;Do context switch
op:"reti" Cond_0, "context" is opcode_4_15=0x45D & Cond_0 {
	if (!Cond_0) goto inst_next;
	# TODO: proper stack
	return [sp];
}
op:"reti" "context" is opcode_4_15=0x45D & cond_0=0 {
	# TODO: proper stack
	return [sp];
}
# D7C0h TL  retid   ;delayed, from interrupt
op:"retid" is opcode_0_15=0xD7C0 {
	delayslot(2);
	# TODO: proper stack
	return [sp];
}
@ifdef TEAK_LITE_2
# D3C3h TL2 retid context
op:"retid" "context" is opcode_0_15=0xD3C3 {
	delayslot(2);
	# TODO: proper stack
	return [sp];
}
@endif
# 0900h TL  rets Imm8u@0          ;ret+dealloc sp (for INCOMING pushed params)
op:"rets" Imm8u_0 is opcode_8_15=0x09 & Imm8u_0 {
	# TODO: proper stack
	return [sp];
}
# 67A0h TL  rnd  Implied Const8000h, Ax@12, Cond@0 ;aX=aX+8000h
op:"rnd" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x7A) & Cond_0 unimpl
op:"rnd" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x7A) & cond_0=0 unimpl
# 6750h TL  rol  Implied Const1,     Ax@12, Cond@0 ;aX=aX rcl 1 (37bit rotate)
op:"rol" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x75) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = (Ax_12 << 1) | ((Ax_12 >> 37) & 1);
}
op:"rol" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x75) & cond_0=0 {
	Ax_12 = (Ax_12 << 1) | ((Ax_12 >> 37) & 1);
}
# 6F50h TL  rol  Implied Const1,     Bx@12, Cond@0 ;bX=bX rcl 1 (37bit rotate)
op:"rol" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF5) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = (Bx_12 << 1) | ((Bx_12 >> 37) & 1);
}
op:"rol" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF5) & cond_0=0 {
	Bx_12 = (Bx_12 << 1) | ((Bx_12 >> 37) & 1);
}
# 6740h TL  ror  Implied Const1,     Ax@12, Cond@0 ;aX=aX rcr 1 (37bit rotate)
op:"ror" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x74) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = (Ax_12 >> 1) | ((Ax_12 & 1) << 37);
}
op:"ror" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x74) & cond_0=0 {
	Ax_12 = (Ax_12 >> 1) | ((Ax_12 & 1) << 37);
}
# 6F40h TL  ror  Implied Const1,     Bx@12, Cond@0 ;bX=bX rcr 1 (37bit rotate)
op:"ror" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF4) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = (Bx_12 >> 1) | ((Bx_12 & 1) << 37);
}
op:"ror" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF4) & cond_0=0 {
	Bx_12 = (Bx_12 >> 1) | ((Bx_12 & 1) << 37);
}
# E300h TL  rst  Imm16@16, MemImm8@0
op:"rst" Imm16, MemImm8_0 is opcode_8_15=0xE3 & MemImm8_0; Imm16 unimpl
# 82E0h TL  rst  Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"rst" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x82E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 83E0h TL  rst  Imm16@16, Register@0
op:"rst" Imm16, Register_0 is opcode_5_15=(0x83E>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# 47B9h TL2 rst  Imm16@16, r6
op:"rst" Imm16, r6 is opcode_0_15=0x47B9 & r6; Imm16 unimpl
# 4388h TL2 rst  Imm16@16, SttMod@0
op:"rst" Imm16, SttMod_0 is opcode_3_15=(0x4388>>3) & SttMod_0; Imm16 unimpl
@endif
# E100h TL  set  Imm16@16, MemImm8@0
op:"set" Imm16, MemImm8_0 is opcode_8_15=0xE1 & MemImm8_0; Imm16 unimpl
# 80E0h TL  set  Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"set" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x80E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 81E0h TL  set  Imm16@16, Register@0
op:"set" Imm16, Register_0 is opcode_5_15=(0x81E>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# 47B8h TL2 set  Imm16@16, r6
op:"set" Imm16, r6 is opcode_0_15=0x47B8 & r6; Imm16 unimpl
# 43C8h TL2 set  Imm16@16, SttMod@0
op:"set" Imm16, SttMod_0 is opcode_3_15=(0x43C8>>3) & SttMod_0; Imm16 unimpl
@endif
# D280h TL  shfc Implied sv, Ab@10, Ab@5, Cond@0
op:"shfc" Ab_10, Ab_5, Cond_0 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x28>>3) & Ab_5 & opcode_4_4=0 & Cond_0 unimpl
op:"shfc" Ab_10, Ab_5 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x28>>3) & Ab_5 & opcode_4_4=0 & cond_0=0 unimpl
# 9240h TL  shfi Implied Imm6s@0, Ab@10, Ab@7, Bogus Imm6s@0
# TODO: reorder?
op:"shfi" Ab_10, Ab_7, Imm6s_0 is opcode_12_15=9 & Ab_10 & opcode_9_9=1 & Ab_7 & opcode_6_6=1 & Imm6s_0 unimpl
# 6720h TL  shl  Implied Const1,     Ax@12, Cond@0 ;aX=aX*2
op:"shl" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x72 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_12 << 1;
}
op:"shl" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x72 & cond_0=0 { Ax_12 = Ax_12 << 1; }
# 6F20h TL  shl  Implied Const1,     Bx@12, Cond@0 ;bX=bX*2
op:"shl" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF2 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = Bx_12 << 1;
}
op:"shl" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF2 & cond_0=0 { Bx_12 = Bx_12 << 1; }
# 6730h TL  shl4 Implied Const4,     Ax@12, Cond@0 ;aX=aX*10h
op:"shl4" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x73 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_12 << 4;
}
op:"shl4" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x73 & cond_0=0 { Ax_12 = Ax_12 << 4; }
# 6F30h TL  shl4 Implied Const4,     Bx@12, Cond@0 ;bX=bX*10h
op:"shl4" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF3 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = Bx_12 << 4;
}
op:"shl4" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF3 & cond_0=0 { Bx_12 = Bx_12 << 4; }
# 6700h TL  shr  Implied Const1,     Ax@12, Cond@0 ;aX=aX/2
# TODO: signed vs unsigned shift?
op:"shr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x70 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_12 >> 1;
}
op:"shl" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x70 & cond_0=0 { Ax_12 = Ax_12 >> 1; }
# 6F00h TL  shr  Implied Const1,     Bx@12, Cond@0 ;bX=bX/2
op:"shl" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF0 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = Bx_12 >> 1;
}
op:"shl" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF0 & cond_0=0 { Bx_12 = Bx_12 >> 1; }
# 6710h TL  shr4 Implied Const4,     Ax@12, Cond@0 ;aX=aX/10h
op:"shl4" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x71 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_12 >> 4;
}
op:"shl4" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x71 & cond_0=0 { Ax_12 = Ax_12 >> 4; }
# 6F10h TL  shr4 Implied Const4,     Bx@12, Cond@0 ;bX=bX/10h
op:"shl4" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF1 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = Bx_12 >> 4;
}
op:"shl4" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF1 & cond_0=0 { Bx_12 = Bx_12 >> 4; }
# BA00h TL  sqr  MemImm8@0
op:"sqr" MemImm8_0 is opcode_8_15=0xBA & MemImm8_0 unimpl
# 9A80h TL  sqr  MemRn@0 || Rn@0stepZIDS@3
op:"sqr" MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x9A8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9AA0h TL  sqr  Register@0
op:"sqr" Register_0 is opcode_5_15=(0x9AA>>1) & Register_0 unimpl
@ifdef TEAK_LITE_2
# D790h TL2 sqr  Abh@2 || sqr Abl@2 || add3 p0, p1, Ab@0
op:"sqr" Abh_2 || "sqr" Abl_2 || "add3" p0, p1, Ab_0 is opcode_4_15=0xD79 & Abh_2 & Abl_2 & Ab_0 & p0 & p1 unimpl
# 49C4h TL2 sqr  Abh@4 || mpysu Abh@4, Abl@4 || add3a p0, p1, Ab@0
op:"sqr" Abh_4 || "mpysu" Abh_4_copy, Abl_4 || "add3a" p0, p1, Ab_0 is opcode_6_15=(0x49C>>2) & Abh_4 & Abh_4_copy & Abl_4 & opcode_2_3=(4>>2) & Ab_0 & p0 & p1 unimpl
# 4B00h TL2 sqr  MemR0425@4 || sqr MemR0425@4offsZIDZ@2 || add3 p0, p1, Ab@0
#            || R0425@4stepII2D2S@2
op:"sqr" MemR0425_4 || "sqr" MemR0425_4_offsZIDZ_2 || "add3" p0, p1, Ab_0 || R0425_4_stepII2D2S_2
	is opcode_6_15=(0x4B0>>2) & MemR0425_4 & MemR0425_4_offsZIDZ_2 & R0425_4_stepII2D2S_2 & Ab_0 & p0 & p1
unimpl
# 5F41h TL2 sqr  r6
op:"sqr" r6 is opcode_0_15=0x5F41 & r6 unimpl
@endif
# BC00h TL  sqra MemImm8@0, Ax@8
op:"sqra" MemImm8_0, Ax_8 is opcode_9_15=(0xBC>>1) & Ax_8 & MemImm8_0 unimpl
# 9C80h TL  sqra MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"sqra" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9CA0h TL  sqra Register@0, Ax@8
op:"sqra" Register_0, Ax_8 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 unimpl
@ifdef TEAK_LITE_2
# 9062h TL2 sqra r6, Ax@8, Unused1@0
op:"sqra" r6, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_1_7=(0x62>>1) & unused_0_0 & r6 unimpl
@endif
# D4FFh TL  sub  MemImm16@16, Ax@8
op:"sub" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xFF; MemImm16 { Ax_8 = Ax_8 - sext(MemImm16); }
# AE00h TL  sub  MemImm8@0, Ax@8
op:"sub" MemImm8_0, Ax_8 is opcode_9_15=(0xAE>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 - sext(MemImm8_0); }
# 8EC0h TL  sub  Imm16@16, Ax@8
op:"sub" Imm16, Ax_8 is opcode_9_15=(0x8E>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 - sext(Imm16); }
# CE00h TL  sub  Imm8u@0, Ax@8
op:"sub" Imm8u_0, Ax_8 is opcode_9_15=(0xCE>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 - zext(Imm8u_0); }
# D4DFh TL  sub  MemR7Imm16@16, Ax@8
op:"sub" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDF; MemR7Imm16 { Ax_8 = Ax_8 - sext(MemR7Imm16); }
# 4E00h TL  sub  MemR7Imm7s@0, Ax@8
op:"sub" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x4E>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 - sext(MemR7Imm7s_0); }
# 8E80h TL  sub  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"sub" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x8E>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 - sext(MemRn_0); build Rn_0_stepZIDS_3; }
# 8EA0h TL  sub  RegisterP0@0, Ax@8
op:"sub" Register_P_0, Ax_8 is opcode_9_15=(0x8E>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_P_0 { Ax_8 = Ax_8 - sext(Register_P_0); }
@ifdef TEAK_LITE_2
# 8A61h TL2 sub  Ab@3, Bx@8
op:"sub" Ab_3, Bx_8 is opcode_9_15=(0x8A>>1) & Bx_8 & opcode_5_7=(6>>1) & Ab_3 & opcode_0_2=1 { Bx_8 = Bx_8 - Ab_3; }
# 8861h TL2 sub  Bx@4, Ax@3
op:"sub" Bx_4, Ax_3 is opcode_5_15=(0x886>>1) & Bx_4 & Ax_3 & opcode_0_2=1 { Ax_3 = Ax_3 - Bx_4; }
# 8064h TL2 sub  MemR01@8, sv, Abh@3 || add MemR01@8offsZI@0, sv, Abl@3
#            || mov MemR45@8, sv || R01@8stepII2@0, R45@8stepII2@1
op:"sub" MemR01_8, sv, Abh_3 || "add" MemR01_8_offsZI_0, sv_copy, Abl_3 || "mov" MemR45_8, sv_copy_2 || R01_8_stepII2_0, R45_8_stepII2_1
	is opcode_9_15=(0x80>>1) & MemR01_8 & MemR45_8 & opcode_4_7=6 & Abh_3 & Abl_3 & opcode_2_2=1 & MemR01_8_offsZI_0 & R01_8_stepII2_0 & R45_8_stepII2_1 & sv & sv_copy & sv_copy_2
unimpl
# 5DE0h TL2 sub  MemR04@1, sv, Abh@2 || add MemR04@1offsZI@0, sv, Abl@2
#            || R04@1stepII2@0
op:"sub" MemR04_1, sv, Abh_2 || "add" MemR04_1_offsZI_0, sv_copy, Abl_2 || R04_1_stepII2_0
	is opcode_4_15=0x5DE & Abh_2 & Abl_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 & sv & sv_copy
unimpl
# 6FC0h TL2 sub  MemR45@2, MemR01@2, Abh@3
#            || add MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"sub" MemR45_2, MemR01_2, Abh_3 || "add" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x6FC>>1) & Abh_3 & Abl_3 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0
unimpl
# 6FE0h TL2 sub  MemR45@2, MemR01@2, Abh@3
#            || sub MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"sub" MemR45_2, MemR01_2, Abh_3 || "sub" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x6FE>>1) & Abh_3 & Abl_3 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0
unimpl
# 5D80h TL2 sub  MemR45@2, sv, Abh@3 || add MemR45@2offsZI@1, sv, Abl@3
#            || mov MemR01@2, sv || R01@2stepII2@0, R45@2stepII2@1
op:"sub" MemR45_2, sv, Abh_3 || "add" MemR45_2_offsZI_1, sv_copy, Abl_3 || "mov" MemR01_2, sv_copy_2 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x5D8>>1) & Abh_3 & Abl_3 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & R01_2_stepII2_0 & sv & sv_copy & sv_copy_2
unimpl
# 5DC2h TL2 sub  p0, p1, Ab@2
# TODO: Should this just be sub  p0, Ab@2? Or how does it differ from sub3?
op:"sub" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=2 & p0 & p1 unimpl
# D4B9h TL2 sub  p1, Ax@8
op:"sub" p1, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xB9 & p1 { Ax_8 = Ax_8 - sext(p1); }
# 8FD0h TL2 sub  Px@1, Bx@0
op:"sub" Px_1, Bx_0 is opcode_2_15=(0x8FD0>>2) & Px_1 & Bx_0 { Bx_0 = Bx_0 - sext(Px_1); }
# D38Fh TL2 sub  r6, Ax@4
op:"sub" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xF & r6 { Ax_4 = Ax_4 - sext(r6); }
# 80C6h TL2 sub3 p0, p1, Ab@10
op:"sub3" p0, p1, Ab_10 is opcode_12_15=8 & Ab_10 & opcode_0_9=0x0C6 & p0 & p1 unimpl
# 82C6h TL2 sub3a p0, p1, Ab@10
op:"sub3a" p0, p1, Ab_10 is opcode_12_15=8 & Ab_10 & opcode_0_9=0x2C6 & p0 & p1 unimpl
# 83C6h TL2 sub3aa p0, p1, Ab@10
op:"sub3aa" p0, p1, Ab_10 is opcode_12_15=8 & Ab_10 & opcode_0_9=0x3C6 & p0 & p1 unimpl
# 5DC3h TL2 suba p0, p1, Ab@2
op:"suba" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=3 & p0 & p1 unimpl
@endif
# B600h TL  subh MemImm8@0, Ax@8
op:"subh" MemImm8_0, Ax_8 is opcode_9_15=(0xB6>>1) & Ax_8 & MemImm8_0 unimpl
# 9680h TL  subh MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"subh" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x96>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 96A0h TL  subh Register@0, Ax@8
op:"subh" Register_0, Ax_8 is opcode_9_15=(0x96>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 unimpl
@ifdef TEAK_LITE_2
# 5E23h TL2 subh r6, Ax@8
op:"subh" r6, Ax_8 is opcode_9_15=(0x5E>>2) & Ax_8 & opcode_0_7=0x23 & r6 unimpl
@endif
# B800h TL  subl MemImm8@0, Ax@8
op:"subl" MemImm8_0, Ax_8 is opcode_9_15=(0xB8>>1) & Ax_8 & MemImm8_0 unimpl
# 9880h TL  subl MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"subl" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 98A0h TL  subl Register@0, Ax@8
op:"subl" Register_0, Ax_8 is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0 unimpl
@ifdef TEAK_LITE_2
# 5E22h TL2 subl r6, Ax@8
op:"subl" r6, Ax_8 is opcode_9_15=(0x5E>>2) & Ax_8 & opcode_0_7=0x22 & r6 unimpl
@endif
# EF00h TL  subv Imm16@16, MemImm8@0
op:"subv" Imm16, MemImm8_0 is opcode_8_15=0xEF & MemImm8_0; Imm16 unimpl
# 8EE0h TL  subv Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"subv" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x8EE>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8FE0h TL  subv Imm16@16, Register@0
op:"subv" Imm16, Register_0 is opcode_5_15=(0x8FE>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# 47BFh TL2 subv Imm16@16, r6
op:"subv" Imm16, r6 is opcode_0_15=0x47BF & r6; Imm16 unimpl
@endif
# 4980h TL  swap SwapTypes4@0
#
# SwapTypes:
# val native           nocash         ;meaning
# 0:  (a0,b0)          a0,b0          ;a0 <--> b0                ;flags(a0)
# 1:  (a0,b1)          a0,b1          ;a0 <--> b1                ;flags(a0)
# 2:  (a1,b0)          a1,b0          ;a1 <--> b0                ;flags(a1)
# 3:  (a1,b1)          a1,b1          ;a1 <--> b1                ;flags(a1)
# 4:  (a0,b0),(a1,b1)  a0:a1,b0:b1    ;a0 <--> b0 and a1 <--> b1 ;flags(a0)
# 5:  (a0,b1),(a1,b0)  a0:a1,b1:b0    ;a0 <--> b1 and a1 <--> b0 ;flags(a0)
# 6:  (a0,b0,a1)       a1,b0,a0       ;a0 --> b0 --> a1          ;flags(a1)
# 7:  (a0,b1,a1)       a1,b1,a0       ;a0 --> b1 --> a1          ;flags(a1)
# 8:  (a1,b0,a0)       a0,b0,a1       ;a1 --> b0 --> a0          ;flags(a0)
# 9:  (a1,b1,a0)       a0,b1,a1       ;a1 --> b1 --> a0          ;flags(a0)
# A:  (b0,a0,b1)       b1,a0,b0       ;b0 --> a0 --> b1          ;flags(a0)!
# B:  (b0,a1,b1)       b1,a1,b0       ;b0 --> a1 --> b1          ;flags(a1)!
# C:  (b1,a0,b0)       b0,a0,b1       ;b1 --> a0 --> b0          ;flags(a0)!
# D:  (b1,a1,b0)       b0,a1,b1       ;b1 --> a1 --> b0          ;flags(a1)!
# E:  reserved         reserved       ;-                         ;-
# F:  reserved         reserved       ;-                         ;-
#
# Note that nocash vs native is not just a punctuation difference; it reorders things too.

macro swap_2(x, y) { # x <--> y
	local tmp = x;
	x = y;
	y = tmp;
}
macro swap_3(x, y, z) { # x --> y --> z
	local tmp = z;
	z = y;
	y = x;
	x = tmp;
}
macro swap_flags(register) {} # TODO

# 0:  (a0,b0)          a0,b0          ;a0 <--> b0                ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b0) is SwapTypes_0=0 & a0 & b0
@else
SwapTypes:a0,b0 is SwapTypes_0=0 & a0 & b0
@endif
{ swap_2(a0, b0); swap_flags(a0); }
# 1:  (a0,b1)          a0,b1          ;a0 <--> b1                ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b1) is SwapTypes_0=1 & a0 & b1
@else
SwapTypes:a0,b1 is SwapTypes_0=1 & a0 & b1
@endif
{ swap_2(a0, b1); swap_flags(a0); }
# 2:  (a1,b0)          a1,b0          ;a1 <--> b0                ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b0) is SwapTypes_0=2 & a1 & b0
@else
SwapTypes:a1,b0 is SwapTypes_0=2 & a1 & b0
@endif
{ swap_2(a1, b0); swap_flags(a1); }
# 3:  (a1,b1)          a1,b1          ;a1 <--> b1                ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b1) is SwapTypes_0=3 & a1 & b1
@else
SwapTypes:a1,b1 is SwapTypes_0=3 & a1 & b1
@endif
{ swap_2(a1, b1); swap_flags(a1); }
# 4:  (a0,b0),(a1,b1)  a0:a1,b0:b1    ;a0 <--> b0 and a1 <--> b1 ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b0),(a1,b1) is SwapTypes_0=4 & a0 & a1 & b0 & b1
@else
SwapTypes:a0:a1,b0:b1 is SwapTypes_0=4 & a0 & a1 & b0 & b1
@endif
{ swap_2(a0, b0); swap_2(a1, b1); swap_flags(a0); }
# 5:  (a0,b1),(a1,b0)  a0:a1,b1:b0    ;a0 <--> b1 and a1 <--> b0 ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b1),(a1,b0) is SwapTypes_0=5 & a0 & a1 & b0 & b1
@else
SwapTypes:a0:a1,b1:b0 is SwapTypes_0=5 & a0 & a1 & b0 & b1
@endif
{ swap_2(a0, b1); swap_2(a1, b0); swap_flags(a0); }
# 6:  (a0,b0,a1)       a1,b0,a0       ;a0 --> b0 --> a1          ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b0,a1) is SwapTypes_0=6 & a0 & b0 & a1
@else
SwapTypes:a1,b0,a0 is SwapTypes_0=6 & a0 & b0 & a1
@endif
{ swap_3(a0, b0, a1); swap_flags(a1); }
# 7:  (a0,b1,a1)       a1,b1,a0       ;a0 --> b1 --> a1          ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b1,a1) is SwapTypes_0=7 & a0 & b1 & a1
@else
SwapTypes:a1,b1,a0 is SwapTypes_0=7 & a0 & b1 & a1
@endif
{ swap_3(a0, b1, a1); swap_flags(a1); }
# 8:  (a1,b0,a0)       a0,b0,a1       ;a1 --> b0 --> a0          ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b0,a0) is SwapTypes_0=8 & a0 & b0 & a1
@else
SwapTypes:a0,b0,a1 is SwapTypes_0=8 & a0 & b0 & a1
@endif
{ swap_3(a1, b0, a0); swap_flags(a0); }
# 9:  (a1,b1,a0)       a0,b1,a1       ;a1 --> b1 --> a0          ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b1,a0) is SwapTypes_0=9 & a0 & b1 & a1
@else
SwapTypes:a0,b1,a1 is SwapTypes_0=9 & a0 & b1 & a1
@endif
{ swap_3(a1, b1, a0); swap_flags(a0); }
# A:  (b0,a0,b1)       b1,a0,b0       ;b0 --> a0 --> b1          ;flags(a0)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b0,a0,b1) is SwapTypes_0=0xA & b0 & b1 & a0
@else
SwapTypes:b1,a0,b0 is SwapTypes_0=0xA & b0 & b1 & a0
@endif
{ swap_3(b0, a0, b1); swap_flags(a0); }
# B:  (b0,a1,b1)       b1,a1,b0       ;b0 --> a1 --> b1          ;flags(a1)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b0,a1,b1) is SwapTypes_0=0xB & b0 & b1 & a1
@else
SwapTypes:b1,a1,b0 is SwapTypes_0=0xB & b0 & b1 & a1
@endif
{ swap_3(b0, a1, b1); swap_flags(a1); }
# C:  (b1,a0,b0)       b0,a0,b1       ;b1 --> a0 --> b0          ;flags(a0)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b1,a0,b0) is SwapTypes_0=0xC & b0 & b1 & a0
@else
SwapTypes:b0,a0,b1 is SwapTypes_0=0xC & b0 & b1 & a0
@endif
{ swap_3(b1, a0, b0); swap_flags(a0); }
# D:  (b1,a1,b0)       b0,a1,b1       ;b1 --> a1 --> b0          ;flags(a1)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b1,a1,b0) is SwapTypes_0=0xD & b0 & b1 & a1
@else
SwapTypes:b0,a1,b1 is SwapTypes_0=0xD & b0 & b1 & a1
@endif
{ swap_3(b1, a1, b0); swap_flags(a1); }

op:"swap" SwapTypes is opcode_4_15=0x498 & SwapTypes { build SwapTypes; }
# 0020h TL  trap                  ;software interrupt
define pcodeop software_interrupt;
op:"trap" is opcode_0_15=0x0020 { software_interrupt(); }
# A800h TL  tst0 Axl@8, MemImm8@0
op:"tst0" is opcode_9_15=(0xA8>>1) & Axl_8 & MemImm8_0 unimpl
# 8880h TL  tst0 Axl@8, MemRn@0 || Rn@0stepZIDS@3
op:"tst0" Axl_8, MemRn_0 || Rn_0_stepZIDS_3 is opcode_9_15=(0x88>>1) & Axl_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 88A0h TL  tst0 Axl@8, Register@0
op:"tst0" Axl_8, Register_0 is opcode_9_15=(0x88>>1) & Axl_8 & opcode_5_7=(0xA>>1) & Register_0 unimpl
# E900h TL  tst0 Imm16@16, MemImm8@0
op:"tst0" Imm16, MemImm8_0 is opcode_8_15=0xE9 & MemImm8_0; Imm16 unimpl
# 88E0h TL  tst0 Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"tst0" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x88E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 89E0h TL  tst0 Imm16@16, Register@0
op:"tst0" Imm16, Register_0 is opcode_5_15=(0x89E>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# D38Ch TL2 tst0 Axl@4, r6
op:"tst0" Axl_4, r6 is opcode_5_15=(0xD38>>1) & Axl_4 & opcode_0_3=0xC & r6; Imm16 unimpl
# 47BCh TL2 tst0 Imm16@16, r6
op:"tst0" Imm16, r6 is opcode_0_15=0x47BC & r6; Imm16 unimpl
# 9470h TL2 tst0 Imm16@16, SttMod@0
op:"tst0" Imm16, SttMod_0 is opcode_3_15=(0x9470>>3) & SttMod_0; Imm16 unimpl
@endif
# AA00h TL  tst1 Axl@8, MemImm8@0 Implied Not
op:"tst1" is opcode_9_15=(0xAA>>1) & Axl_8 & MemImm8_0 unimpl
# 8A80h TL  tst1 Axl@8, MemRn@0 Implied Not || Rn@0stepZIDS@3
op:"tst1" Axl_8, MemRn_0 || Rn_0_stepZIDS_3 is opcode_9_15=(0x8A>>1) & Axl_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 8AA0h TL  tst1 Axl@8, Register@0 Implied Not
op:"tst1" Axl_8, Register_0 is opcode_9_15=(0x8A>>1) & Axl_8 & opcode_5_7=(0xA>>1) & Register_0 unimpl
# EB00h TL  tst1 Imm16@16, MemImm8@0 Implied Not
op:"tst1" Imm16, MemImm8_0 is opcode_8_15=0xEB & MemImm8_0; Imm16 unimpl
# 8AE0h TL  tst1 Imm16@16, MemRn@0 Implied Not || Rn@0stepZIDS@3
op:"tst1" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x8AE>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 unimpl
# 8BE0h TL  tst1 Imm16@16, Register@0 Implied Not
op:"tst1" Imm16, Register_0 is opcode_5_15=(0x8BE>>1) & Register_0; Imm16 unimpl
@ifdef TEAK_LITE_2
# D38Dh TL2 tst1 Axl@4, r6 Implied Not
op:"tst1" Axl_4, r6 is opcode_5_15=(0xD38>>1) & Axl_4 & opcode_0_3=0xD & r6; Imm16 unimpl
# 47BDh TL2 tst1 Imm16@16, r6 Implied Not
op:"tst1" Imm16, r6 is opcode_0_15=0x47BD & r6; Imm16 unimpl
# 9478h TL2 tst1 Imm16@16, SttMod@0 Implied Not
op:"tst1" Imm16, SttMod_0 is opcode_3_15=(0x9478>>3) & SttMod_0; Imm16 unimpl
# 80C1h TL2 tst4b a0l, MemR0425@10 || R0425@10stepII2D2S@8
op:"tst4b" a0l, MemR0425_10 || R0425_10_stepII2D2S_8 is opcode_12_15=8 & MemR0425_10 & R0425_10_stepII2D2S_8 & opcode_0_7=0xC1 & a0l unimpl
# 4780h TL2 tst4b a0l, MemR0425@2, Ax@4 || R0425@2stepII2D2S@0
op:"tst4b" a0l, MemR0425_2, Ax_4 || R0425_2_stepII2D2S_0 is opcode_5_15=(0x478>>1) & Ax_4 & MemR0425_2 & R0425_2_stepII2D2S_0 & a0l unimpl
@endif
# F000h TL  tstb NoReverse, Implied Not MemImm8@0, Imm4bitno@8
op:"tstb" MemImm8_0, Imm4bitno_8 is opcode_11_15=0xF & Imm4bitno_8 & MemImm8_0 unimpl
# 9020h TL  tstb NoReverse, Implied Not MemRn@0, Imm4bitno@8 || Rn@0stepZIDS@3
op:"tstb" MemRn_0, Imm4bitno_8 || Rn_0_stepZIDS_3 is opcode_11_15=9 & Imm4bitno_8 & opcode_5_7=(2>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9000h TL  tstb NoReverse, Implied Not Register@0, Imm4bitno@8
op:"tstb" Register_0, Imm4bitno_8 is opcode_11_15=9 & Imm4bitno_8 & opcode_5_7=0 & Register_0 unimpl
@ifdef TEAK_LITE_2
# 9018h TL2 tstb NoReverse, Implied Not r6, Imm4bitno@8  ;override tstb a0,Imm4
op:"tstb" r6, Imm4bitno_8 is opcode_11_15=9 & Imm4bitno_8 & opcode_0_7=0x18 & r6 unimpl
# 0028h TL2 tstb NoReverse, Implied Not SttMod@0, Imm4bitno@16, Unused12@20
op:"tstb" SttMod_0, Imm4bitno_16 is opcode_3_15=(0x0028>>3) & SttMod_0; Imm4bitno_16 & expanded_unused_20_31 unimpl
# 5F45h TL2 vtrclr vtr0         ;vtr0=0           ;for Viterbi decoding...
op:"vtrclr" vtr0 is opcode_0_15=0x5F45 & vtr0 { vtr0 = 0; }
# 5F47h TL2 vtrclr vtr0, vtr1   ;vtr0=0, vtr1=0   ;(saved C/C1 carry flags)
# TODO: C/C1 carry flags?
op:"vtrclr" vtr0, vtr1 is opcode_0_15=0x5F47 & vtr0 & vtr1 { vtr0 = 0; vtr1 = 0; }
# 5F46h TL2 vtrclr vtr1         ;vtr1=0
op:"vtrclr" vtr1 is opcode_0_15=0x5F46 & vtr1 { vtr1 = 0; }
# D383h TL2 vtrmov Axl@4        ;Axl=(vtr1 and FF00h)+(vtr0/100h)
op:"vtrmov" Axl_4 is opcode_5_15=(0xD38>>1) & Axl_4 & opcode_0_3=3 { Axl_4 = (vtr1 & 0xFF00) | ((vtr0 & 0xFF00) >> 8); }
# D29Ah TL2 vtrmov vtr0, Axl@0  ;Axl=vtr0
op:"vtrmov" vtr0, Axl_0 is opcode_1_15=(0xD29A>>1) & Axl_0 & vtr0 { Axl_0 = vtr0; }
# D69Ah TL2 vtrmov vtr1, Axl@0  ;Axl=vtr1
op:"vtrmov" vtr1, Axl_0 is opcode_1_15=(0xD69A>>1) & Axl_0 & vtr1 { Axl_0 = vtr1; }
# D781h TL2 vtrshr              ;vtr0=vtr0/2+C*8000h, vtr1=vtr1/2+C1*8000h
op:"vtrshr" is opcode_0_15=0xD781 unimpl
@endif
# D4FAh TL  xor  MemImm16@16, Ax@8
op:"xor" MemImm16, Ax_8 is opcode_9_15=(0xDA>>1) & Ax_8 & opcode_0_7=0xFA; MemImm16 { Ax_8 = Ax_8 ^ zext(MemImm16); }
# A400h TL  xor  MemImm8@0, Ax@8
op:"xor" MemImm8_0, Ax_8 is opcode_9_15=(0xA4>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 ^ zext(MemImm8_0); }
# 84C0h TL  xor  Imm16@16, Ax@8
op:"xor" Imm16, Ax_8 is opcode_9_15=(0x84>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 ^ zext(Imm16); }
# C400h TL  xor  Imm8u@0, Ax@8
op:"xor" Imm8u_0, Ax_8 is opcode_9_15=(0xC4>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 ^ zext(Imm8u_0); }
# D4DAh TL  xor  MemR7Imm16@16, Ax@8
op:"xor" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDA; MemR7Imm16 { Ax_8 = Ax_8 ^ zext(MemR7Imm16); }
# 4400h TL  xor  MemR7Imm7s@0, Ax@8
op:"xor" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x44>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 ^ zext(MemR7Imm7s_0); }
# 8480h TL  xor  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"xor" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x84>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 ^ zext(MemRn_0); build Rn_0_stepZIDS_3; }
# 84A0h TL  xor  RegisterP0@0, Ax@8
op:"xor" Register_P_0, Ax_8 is opcode_9_15=(0x84>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_P_0 { Ax_8 = Ax_8 ^ zext(Register_P_0); }
@ifdef TEAK_LITE_2
# D38Ah TL2 xor  r6, Ax@4
op:"xor" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xA & r6 { Ax_4 = Ax_4 ^ zext(r6); }
@endif
# 8800h TL  undefined Unused5@0, Unused1@8 ;(mpy/mpys without A in bit11)
# 8820h TL  undefined Unused5@0, Unused1@8 ;(mpy/mpys without A in bit11)
# 8840h TL  undefined Unused5@0, Unused1@8 ;(mpy/mpys without A in bit11)
# D800h TL  undefined Unused7@0, Unused1@8 ;(mpy/mpys without A in bit11)
# 9B80h TL  undefined Unused6@0  ;(sqr without A in bit8)
# BB00h TL  undefined Unused8@0  ;(sqr without A in bit8)
# E800h TL  undefined Unused8@0  ;(mpy without A in bit11)
@ifdef TEAK_LITE_2
# 5EA1h TL2 undefined Unused1@1  ;(mpy/mpys without A in bit11)
# 5DFCh TL2 undefined - would be clrp clearing neither p0 nor p1
# 8CDEh TL2 undefined
# D3C1h TL2 undefined
# 5EB4h TL2 undefined Unused2@0
@endif

# Handle looping logic:
LoopJumpBackAddrWrapper: " =>"^loopjumpbackaddr is loopjumpbackaddr { export *[code]:2 loopjumpbackaddr; }

# Note: unlike GCDSP, a rep 0 or bkrep 0 instruction still runs the loop once. So we don't need
# to check to skip a loop, and instead can handle everything in the jumpback.
# Also, teakra checks this at the start of the instruction, instead of the end of the previous one:
# https://github.com/wwylele/teakra/blob/01db7cdd00aabcce559a8dddce8798dabb71949b/src/interpreter.h#L102-L112
# I guess this would make a difference with jumps, but it seems weird.
loopjumpback:"" is hasloopjumpback=0 {}
loopjumpback:LoopJumpBackAddrWrapper is hasloopjumpback=1 & LoopJumpBackAddrWrapper & CurLC {
	if (CurLC == 0) goto inst_next;
	CurLC = CurLC - 1;
	goto LoopJumpBackAddrWrapper;
}

# Now populate the root instruction table.
:^op is op & hasloopjumpback=0 {
	build op;
}
:^" "^op^loopjumpback is op & hasloopjumpback=1 & loopjumpback {
	build loopjumpback;
}

@ifdef OLD_GCDSP_JUNK
# Note that if *[const]:2 is not used to use the value as a pointer in the constant address space, things break and the value will be treated as 0.
# i.e. with just { export imm8; } setting a register to Imm8 apepars to set it to 0, while setting it to imm8 works fine.
# There is a warning for this, though it's not obvious: "Table 'Imm8' exports size 0".
Imm6: "#"^imm6 is imm6 { export *[const]:2 imm6; }
# See comment by LSR
Imm6Right: "#"^rightshiftvalue is imm6=0 [ rightshiftvalue = 0; ] { export *[const]:2 rightshiftvalue; }
Imm6Right: "#"^rightshiftvalue is imm6 [ rightshiftvalue = (64 - imm6); ] { export *[const]:2 rightshiftvalue; }

Imm8: "#"^imm8 is imm8 { export *[const]:2 imm8; }
SImm8: "#"^simm8 is simm8 { export *[const]:2 simm8; }
Mem8FF: "@"^addr is imm8 [ addr = 0xff00 | imm8; ] { export *:2 addr; }
@ifdef SIMPLIFY_CR
Mem8CR: Mem8FF is Mem8FF { export Mem8FF; }
@else
Mem8CR: "@((cr << 8) | "^imm8^")" is imm8 { addr:2 = (((cr & 0xff) << 8) | imm8); export *:2 addr; }
@endif

define token data16 (16)
	imm16  = (0,15)
	simm16 = (0,15) signed
;

Addr16: imm16 is imm16 { export *[inst]:1 imm16; }
# Formatting convenience: add 1 to the address for BLOOP/BLOOPI, to point to the address after the loop
# instead of the one in the loop.  This puts a label after the loop instead of inside of the loop.
# (This is mainly needed because Ghidra generates the label off of the operand, not the actual jump location.
# Even with this, BLOOP generates a _read_ reference instead of a jump reference, for some reason)
# Note that this is also used for context variable purposes, even when BLOOP_ONE_AFTER is not defined.
Addr16After: dest is imm16 [ dest = imm16 + 1; ] { export *[inst]:1 dest; }
Imm16: "#"^imm16 is imm16 { export *[const]:2 imm16; }
SImm16: "#"^simm16 is simm16 { export *[const]:2 simm16; }
Mem16: "@"^imm16 is imm16 { export *:2 imm16; }

attach variables [ _reg0_5 _reg5_10 ] [
	ar0 ar1 ar2 ar3
	ix0 ix1 ix2 ix3
	wr0 wr1 wr2 wr3
	st0 st1 st2 st3
	ac0.h ac1.h
	cr sr
	prod.l prod.m1 prod.h prod.m2
	ax0.l ax1.l ax0.h ax1.h
	ac0.l ac1.l ac0.m ac1.m
];

macro SIGN_EXTEND_AC0M() {
@ifdef USE_40_BIT_SIGN_EXTENSION
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	if (!$(SR_40_MODE)) goto <done>;
@endif
	acc0 = sext(ac0.m) << 16;
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	<done>
@endif
@endif
}
macro SIGN_EXTEND_AC1M() {
@ifdef USE_40_BIT_SIGN_EXTENSION
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	if (!$(SR_40_MODE)) goto <done>;
@endif
	acc1 = sext(ac1.m) << 16;
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	<done>
@endif
@endif
}

# According to 7.9. P-code Macros:
# Parameters are passed by reference, so the value of varnodes passed into the macro can be changed.
# Currently, there is no syntax for returning a value from the macro,
# except by writing to a parameter or global symbol.
macro GET_SATURATED_AC0M(dest) {
@ifdef USE_40_BIT_SATURATION
	# If the 40-bit mode is disabled, no saturation is needed.
	if (!$(SR_40_MODE)) goto <no_saturation_needed>;
	# If the accumulator is the same as its s32 version, no saturation is needed.
	if (acc0 == sext(ac0:4)) goto <no_saturation_needed>;
	# Saturation is needed; check if it needs to be be positive or negative.
	if (acc0 s< 0) goto <negative_saturation>;
	# Positive
	dest = 0x7fff;
	goto <done>;
	<negative_saturation>
	dest = 0x8000;
	goto <done>;
	<no_saturation_needed>
@endif
	dest = ac0.m;
	goto <done>;
	<done>
}
macro GET_SATURATED_AC1M(dest) {
@ifdef USE_40_BIT_SATURATION
	# If the 40-bit mode is disabled, no saturation is needed.
	if (!$(SR_40_MODE)) goto <no_saturation_needed>;
	# If the accumulator is the same as its s32 version, no saturation is needed.
	if (acc1 == sext(ac1:4)) goto <no_saturation_needed>;
	# Saturation is needed; check if it needs to be be positive or negative.
	if (acc1 s< 0) goto <negative_saturation>;
	# Positive
	dest = 0x7fff;
	goto <done>;
	<negative_saturation>
	dest = 0x8000;
	goto <done>;
	<no_saturation_needed>
@endif
	dest = ac1.m;
	goto <done>;
	<done>
}

sign_extend_reg0_5_after: is _reg0_5 {}
sign_extend_reg0_5_after: is _reg0_5=0x10 { ac0.h = sext(ac0.hreal); }
sign_extend_reg0_5_after: is _reg0_5=0x11 { ac1.h = sext(ac1.hreal); }
sign_extend_reg0_5_after: is _reg0_5=0x1E { SIGN_EXTEND_AC0M(); }
sign_extend_reg0_5_after: is _reg0_5=0x1F { SIGN_EXTEND_AC1M(); }

saturated_reg0_5: is _reg0_5 { export _reg0_5; }
saturated_reg0_5: is _reg0_5=0x10 { local tmp:2 = sext(ac0.hreal); export tmp; }
saturated_reg0_5: is _reg0_5=0x11 { local tmp:2 = sext(ac1.hreal); export tmp; }
saturated_reg0_5: is _reg0_5=0x1E { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_reg0_5: is _reg0_5=0x1F { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

sign_extend_reg5_10_after: is _reg5_10 {}
sign_extend_reg5_10_after: is _reg5_10=0x10 { ac0.h = sext(ac0.hreal); }
sign_extend_reg5_10_after: is _reg5_10=0x11 { ac1.h = sext(ac1.hreal); }
sign_extend_reg5_10_after: is _reg5_10=0x1E { SIGN_EXTEND_AC0M(); }
sign_extend_reg5_10_after: is _reg5_10=0x1F { SIGN_EXTEND_AC1M(); }

attach variables [ _ar0_2 _ar5_7 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ _ix0_2 _ix2_4 _ix5_7 ] [ ix0 ix1 ix2 ix3 ];

attach variables [ _reg5_8 ] [ ar0 ar1 ar2 ar3 ix0 ix1 ix2 ix3 ];

attach variables [ _acm8 ] [ ac0.m ac1.m ]; # Middle of 40-bit accumulators
attach variables [ _acf8 ] [ acc0 acc1 ]; # Full 40-bit accumulators
attach variables [ _acs8 ] [ acs0 acs1 ]; # 24 bits of 40-bit accumulators
attach variables [ _ac8_11 ] [ ax0.l ax1.l ax0.h ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ _ac8_10 ] [ ac0.l ac1.l ac0.m ac1.m ]; # 2-bit field referring to a register starting at 0x1C (ac0.l)
attach variables [ _ach8display ] [ ac0.h ac1.h ]; # Top of 40-bit accumulators
attach variables [ _ach8 ] [ ac0.hreal ac1.hreal ]; # Top of 40-bit accumulators, as 8-bit registers

sign_extend_acm8_after: is _acm8=0 { SIGN_EXTEND_AC0M(); }
sign_extend_acm8_after: is _acm8=1 { SIGN_EXTEND_AC1M(); }

sign_extend_ac8_11_after: is _ac8_11 {}
sign_extend_ac8_11_after: is _ac8_11=6 { SIGN_EXTEND_AC0M(); }
sign_extend_ac8_11_after: is _ac8_11=7 { SIGN_EXTEND_AC1M(); }

saturated_ac8_10: is _ac8_10 { export _ac8_10; }
saturated_ac8_10: is _ac8_10=2 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_ac8_10: is _ac8_10=3 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

@ifdef USE_REAL_SR_REGISTER
# Offset by 6
attach names srbit [ SR_LOGIC_ZERO SR_OVERFLOW_STICKY SR_100 SR_INT_ENABLE SR_400 SR_EXT_INT_ENABLE SR_1000 SR_MUL_MODIFY ];
@else
attach variables srbit [ SR_LOGIC_ZERO_ SR_OVERFLOW_STICKY_ SR_100_ SR_INT_ENABLE_ SR_400_ SR_EXT_INT_ENABLE_ SR_1000_ SR_MUL_MODIFY_ ];
@endif

# GCDSP also supports extension instructions, where a 1-byte arithmetic
# instruction is followed by a 1-byte extension instruction.
# This is written as e.g. 46 51 ADDR'L acc0, ax1.h : ax0.h, @ar1 where
# 46 corresponds to ADDR acc0, ax1.h and 51 corresponds to 'L ax0.h, @ar1.
# SLEIGH lets us have two separate tokens which can form two tables that
# are merged later, which could be used for implementing this.
#
# Unfortunately, the two-separate-bytes model is not accurate, as arithmetic
# instructions with an opcode starting with 3 actually use 9 bytes, leaving
# the remaining 7 for extension instructions.  Thus, a single merged token
# is used instead.
define token axopbyte (16)
	# Opbyte for arithmetic instructions
	aop0_8 = (8,  15) # (0, 7)
	aop4_8 = (12, 15) # (4, 7)
	aop5_8 = (13, 15) # (5, 7)
	aop2_4 = (10, 11) # (2, 3)
	aop1   = (9,  9)  # (1, 1)
	aop3   = (11, 11) # (3, 3)
	aop0_3 = (8,  10) # (0, 2)
	aop1_4 = (9,  11) # (1, 3)
	aop1_3 = (9,  10) # (1, 2)

	_aacl0 = (8, 8) # (0, 0) # Low part of 40-bit accumulator

	_aacm0 = (8, 8) # (0, 0) # Middle of 40-bit accumulator
	_aacm1 = (9, 9) # (1, 1) # Middle of 40-bit accumulator
	_aacm0_other = (8, 8) # (0, 0) # Middle of 40-bit accumulator, backwards
	_aacm4 = (12, 12) # (4, 4) # Middle of 40-bit accumulator

	_aacf0 = (8, 8) # (0, 0) # Full 40 bits of an accumulator
	_aacf0_other = (8, 8) # (0, 0) # Full 40 bits of an accumulator, backwards
	_aacf3 = (11, 11) # (3, 3) # Full 40 bits of an accumulator

	_aacs0 = (8, 8) # (0, 0) # 24 bits of a 40-bit accumulator

	_aaxh0 = (8,  8)  # (0, 0) # High bits of 32-bit accumulator
	_aaxh1 = (9,  9)  # (1, 1) # High bits of 32-bit accumulator
	_aaxh3 = (11, 11) # (3, 3) # High bits of 32-bit accumulator
	_aaxh4 = (12, 12) # (4, 4) # High bits of 32-bit accumulator
	_aaxl0 = (8,  8)  # Low bits of 32-bit accumulator
	_aaxl1 = (9,  9)  # Low bits of 32-bit accumulator
	_aaxl3 = (11, 11) # Low bits of 32-bit accumulator
	_aaxf1 = (9,  9)  # Full 32 bits of an accumulator
	_aax1_2 = (9, 10) # (1, 2) # 32-bit accumulator

	_aax0lh1 = (9,  9)  # (1, 1) # Either ax0.l or ax0.h
	_aax0lh4 = (12, 12) # (4, 4) # Either ax0.l or ax0.h
	_aax1lh0 = (8,  8)  # (0, 0) # Either ax1.l or ax1.h
	_aax1lh3 = (11, 11) # (3, 3) # Either ax1.l or ax1.h

	# Bit that belongs in xop but is used by arithmetic ops where aop4_8=0b0011
	axbit = (7, 7)

	# Opbyte for extension instructions
	xop0_2 = (0, 1)
	xop0_7 = (0, 6)
	xop4_7 = (4, 6)
	xop1   = (1, 1)
	xop2   = (2, 2)
	xop5   = (5, 5)
	xop6   = (6, 6)
	xop2_4 = (2, 3)

	_xar0_2 = (0, 1) # Addressing register
	_xix0_2 = (0, 1) # Index register
	_xac3_6 = (3, 5) # Either accumulator
	_xax2_4 = (2, 3) # 32-bit accumulator
	_xax4_6 = (4, 5) # 32-bit accumulator
	_xac0_2 = (0, 1) # 40-bit accumulator
	_xac3_5 = (3, 4) # 40-bit accumulator
	_xacm0  = (0, 0) # Either ac0.m or ac1.m

	_xax0lh5 = (5, 5) # Either ax0.l or ax0.h
	_xax1lh4 = (4, 4) # Either ax1.l or ax1.h

	_xax4  = (4, 4) # Either ax0 or ax1
	_xaxl4 = (4, 4) # Either ax0.l or ax1.l
	_xaxh4 = (4, 4) # Either ax0.h or ax1.h

	_xar5 = (5, 5) # Either ar0 or ar1; ar2 and ar3 are not selectable
	_xix5 = (5, 5) # Either ix0 or ix1
;

# Variables for arithmetic opcodes
attach variables [ _aacl0 ] [ ac0.l ac1.l ];
attach variables [ _aacm0 _aacm1 _aacm4 ] [ ac0.m ac1.m ];
attach variables [ _aacm0_other ] [ ac1.m ac0.m ];
attach variables [ _aacf0 _aacf3 ] [ acc0 acc1 ];
attach variables [ _aacf0_other ] [ acc1 acc0 ];
attach variables [ _aacs0 ] [ acs0 acs1 ];
attach variables [ _aaxh0 _aaxh1 _aaxh3 _aaxh4 ] [ ax0.h ax1.h ];
attach variables [ _aaxl0 _aaxl1 _aaxl3 ] [ ax0.l ax1.l ];
attach variables [ _aax1_2 ] [ ax0.l ax1.l ax0.h ax1.h ]; # 2-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ _aaxf1 ] [ ax0 ax1 ];

attach variables [ _aax0lh1 _aax0lh4 ] [ ax0.l ax0.h ];
attach variables [ _aax1lh0 _aax1lh3 ] [ ax1.l ax1.h ];

# Variables for extension opcodes
attach variables [ _xar0_2 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ _xix0_2 ] [ ix0 ix1 ix2 ix3 ];
attach variables [ _xac3_6 ] [ ax0.l ax1.l ax0.h ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ _xax2_4 _xax4_6 ] [ ax0.l ax1.l ax0.h ax1.h ]; # 2-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ _xac0_2 _xac3_5 ] [ ac0.l ac1.l ac0.m ac1.m ]; # 2-bit field referring to a register starting at 0x1C (ac0.l)
attach variables [ _xacm0 ] [ ac0.m ac1.m ];

sign_extend_xac3_6_after: is _xac3_6 {}
sign_extend_xac3_6_after: is _xac3_6=6 { SIGN_EXTEND_AC0M(); }
sign_extend_xac3_6_after: is _xac3_6=7 { SIGN_EXTEND_AC1M(); }

saturated_xac0_2: is _xac0_2 { export _xac0_2; }
saturated_xac0_2: is _xac0_2=2 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_xac0_2: is _xac0_2=3 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

saturated_xac3_5: is _xac3_5 { export _xac3_5; }
saturated_xac3_5: is _xac3_5=2 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_xac3_5: is _xac3_5=3 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

saturated_xacm0: is _xacm0=0 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_xacm0: is _xacm0=1 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

attach variables [ _xax0lh5 ] [ ax0.l ax0.h ];
attach variables [ _xax1lh4 ] [ ax1.l ax1.h ];

attach variables [ _xax4  ] [ ax0   ax1   ];
attach variables [ _xaxl4 ] [ ax0.l ax1.l ];
attach variables [ _xaxh4 ] [ ax0.h ax1.h ];

attach variables [ _xar5 ] [ ar0 ar1 ];
attach variables [ _xix5 ] [ ix0 ix1 ];

# These are all so that a $ can be prepended to the register name, and should be used in
# instructions instead of the underscore-prefixed ones.
ar0_2:       "$"^_ar0_2       is _ar0_2       { export _ar0_2;       }
ix0_2:       "$"^_ix0_2       is _ix0_2       { export _ix0_2;       }
ix2_4:       "$"^_ix2_4       is _ix2_4       { export _ix2_4;       }
reg0_5:      "$"^_reg0_5      is _reg0_5      { export _reg0_5;      }
ar5_7:       "$"^_ar5_7       is _ar5_7       { export _ar5_7;       }
ix5_7:       "$"^_ix5_7       is _ix5_7       { export _ix5_7;       }
reg5_8:      "$"^_reg5_8      is _reg5_8      { export _reg5_8;      }
reg5_10:     "$"^_reg5_10     is _reg5_10     { export _reg5_10;     }
acm8:        "$"^_acm8        is _acm8        { export _acm8;        }
acf8:        "$"^_acf8        is _acf8        { export _acf8;        }
acs8:        "$"^_acs8        is _acs8        { export _acs8;        }
ac8_11:      "$"^_ac8_11      is _ac8_11      { export _ac8_11;      }
ac8_10:      "$"^_ac8_10      is _ac8_10      { export _ac8_10;      }
ach8display: "$"^_ach8display is _ach8display { export _ach8display; }
ach8:        "$"^_ach8        is _ach8        { export _ach8;        }
aacl0:       "$"^_aacl0       is _aacl0       { export _aacl0;       }
aacm0:       "$"^_aacm0       is _aacm0       { export _aacm0;       }
aacm1:       "$"^_aacm1       is _aacm1       { export _aacm1;       }
aacm0_other: "$"^_aacm0_other is _aacm0_other { export _aacm0_other; }
aacm4:       "$"^_aacm4       is _aacm4       { export _aacm4;       }
aacf0:       "$"^_aacf0       is _aacf0       { export _aacf0;       }
aacf0_other: "$"^_aacf0_other is _aacf0_other { export _aacf0_other; }
aacf3:       "$"^_aacf3       is _aacf3       { export _aacf3;       }
aacs0:       "$"^_aacs0       is _aacs0       { export _aacs0;       }
aaxh0:       "$"^_aaxh0       is _aaxh0       { export _aaxh0;       }
aaxh1:       "$"^_aaxh1       is _aaxh1       { export _aaxh1;       }
aaxh3:       "$"^_aaxh3       is _aaxh3       { export _aaxh3;       }
aaxh4:       "$"^_aaxh4       is _aaxh4       { export _aaxh4;       }
aaxl0:       "$"^_aaxl0       is _aaxl0       { export _aaxl0;       }
aaxl1:       "$"^_aaxl1       is _aaxl1       { export _aaxl1;       }
aaxl3:       "$"^_aaxl3       is _aaxl3       { export _aaxl3;       }
aaxf1:       "$"^_aaxf1       is _aaxf1       { export _aaxf1;       }
aax1_2:      "$"^_aax1_2      is _aax1_2      { export _aax1_2;      }
aax0lh1:     "$"^_aax0lh1     is _aax0lh1     { export _aax0lh1;     }
aax0lh4:     "$"^_aax0lh4     is _aax0lh4     { export _aax0lh4;     }
aax1lh0:     "$"^_aax1lh0     is _aax1lh0     { export _aax1lh0;     }
aax1lh3:     "$"^_aax1lh3     is _aax1lh3     { export _aax1lh3;     }
xar0_2:      "$"^_xar0_2      is _xar0_2      { export _xar0_2;      }
xix0_2:      "$"^_xix0_2      is _xix0_2      { export _xix0_2;      }
xac3_6:      "$"^_xac3_6      is _xac3_6      { export _xac3_6;      }
xax2_4:      "$"^_xax2_4      is _xax2_4      { export _xax2_4;      }
xax4_6:      "$"^_xax4_6      is _xax4_6      { export _xax4_6;      }
xac0_2:      "$"^_xac0_2      is _xac0_2      { export _xac0_2;      }
xac3_5:      "$"^_xac3_5      is _xac3_5      { export _xac3_5;      }
xacm0:       "$"^_xacm0       is _xacm0       { export _xacm0;       }
xax0lh5:     "$"^_xax0lh5     is _xax0lh5     { export _xax0lh5;     }
xax1lh4:     "$"^_xax1lh4     is _xax1lh4     { export _xax1lh4;     }
xax4:        "$"^_xax4        is _xax4        { export _xax4;        }
xaxl4:       "$"^_xaxl4       is _xaxl4       { export _xaxl4;       }
xaxh4:       "$"^_xaxh4       is _xaxh4       { export _xaxh4;       }
xar5:        "$"^_xar5        is _xar5        { export _xar5;        }
xix5:        "$"^_xix5        is _xix5        { export _xix5;        }

macro FLAGS16X(result, carry, overflow, over_s32) {
	$(SR_CARRY) = carry;  # Carry
	$(SR_OVERFLOW) = overflow;  # Overflow
	$(SR_ARITH_ZERO) = (result == 0);  # Zero
	$(SR_SIGN) = (result s< 0);  # Sign
	$(SR_OVER_32) = over_s32;  # Above s32
	$(SR_TOP2BITS) = ((result & 0xc000) == 0) || ((result & 0xc000) == 0xc000);  # Top 2 bits equal
	$(SR_OVERFLOW_STICKY) = $(SR_OVERFLOW_STICKY) | $(SR_OVERFLOW);  # Sticky overflow
}

macro FLAGS16(result, result_40) {
	FLAGS16X(result, 0, 0, (result_40 != sext(result_40:4)));
}

macro FLAGS40X(result, carry, overflow) {
	# Flags for a 40-bit operation (like Dolphin's UpdateSR64)
	$(SR_CARRY) = carry;  # Carry
	$(SR_OVERFLOW) = overflow;  # Overflow
	$(SR_ARITH_ZERO) = (result == 0);  # Zero
	$(SR_SIGN) = (result s< 0);  # Sign
	$(SR_OVER_32) = (result != sext(result:4));  # Above s32
	$(SR_TOP2BITS) = ((result & 0xc0000000) == 0) || ((result & 0xc0000000) == 0xc0000000);  # Top 2 bits equal
	$(SR_OVERFLOW_STICKY) = $(SR_OVERFLOW_STICKY) | $(SR_OVERFLOW);  # Sticky overflow
}

macro FLAGS40(result) {
	FLAGS40X(result, 0, 0);
}

macro FLAGS_ADD40(a, b) {
	# Flags for a 40-bit add (like Dolphin's UpdateSR64Add)
	# Carry uses an unsigned comparison to match Dolphin's isCarrySubtract.
	# Comparing Dolphin's isOverflow in DSPIntCCUtil.h and Ghidra's OpBehaviorIntScarry.java,
	# scarry seems to match our desired behavior here.  Note that this is the same for add and subtract
	FLAGS40X(a + b, (a > (a + b)), scarry(a, b));
}

macro FLAGS_SUB40(a, b) {
	# Flags for a 40-bit subtract (like Dolphin's UpdateSR64Sub)
	# Carry uses an unsigned comparison to match Dolphin's isCarrySubtract.
	# Comparing Dolphin's isOverflow in DSPIntCCUtil.h and Ghidra's OpBehaviorIntScarry.java,
	# scarry seems to match our desired behavior here.  Note that this is the same for add and subtract
	FLAGS40X(a - b, (a >= (a - b)), scarry(a, -b));
}

#---------------------------------------------------------------------------------------------------
# Define regular opcodes and opcode parameters.
# (These are separated for technical reasons, described at the end of the file.)
#
# In this section, bits are numbered like this:
# 1111 1100 0000 0000
# 5432 1098 7654 3210
# (i.e. the most significant bit/leftmost is 15, and the least significant/rightmost bit is 0).
#---------------------------------------------------------------------------------------------------

# 0000 0000 0000 0000
with : op0_4=0 & op4_8=0 & op8_16=0 {
r_opc:"NOP" is epsilon {}
r_opp:"" is epsilon {}
}

# 0000 0000 0000 0001 through 0000 0000 0000 0011 are unused (but probably just other forms of NOP)

# 0000 0000 0000 01dd
with : op2_4=0b01 & op4_8=0 & op8_16=0 {
r_opc:"DAR" is epsilon {}
r_opp:ar0_2 is ar0_2 {
	ar0_2 = ar0_2 - 1;
}
}

# 0000 0000 0000 10dd
with : op2_4=0b10 & op4_8=0 & op8_16=0 {
r_opc:"IAR" is epsilon {}
r_opp:ar0_2 is ar0_2 {
	ar0_2 = ar0_2 + 1;
}
}

# 0000 0000 0000 11dd
with : op2_4=0b11 & op4_8=0b0000 & op8_16=0 {
r_opc:"SUBARN" is epsilon {}
r_opp:ar0_2, ix0_2 is ar0_2 & ix0_2 {
	ar0_2 = ar0_2 - ix0_2;
}
}

# 0000 0000 0001 ssdd
with : op4_8=0b0001 & op8_16=0 {
r_opc:"ADDARN" is epsilon {}
r_opp:ar0_2, ix2_4 is ar0_2 & ix2_4 {
	ar0_2 = ar0_2 + ix2_4;
}
}

# HALT is the only instruction in 0000 0000 0010 xxxx

# 0000 0000 0010 0001
with : op0_4=0b0001 & op4_8=0b0010 & op8_16=0 {
r_opc:"HALT" is epsilon {}
r_opp:"" is epsilon {
	goto inst_start; # Infinite loop
}
}

# Wrapper for the loop skip address, for use in LOOP and LOOPI for setting loopstackdepth.
# Note that although "globalset(loopskipaddr, loopstackdepth)" is valid, it behaves incorrectly
# due to the 2-byte word size (e.g. if inst_start is 0x400, globalset(loopskipaddr) would use
# address 0x201 instead of address 0x402). Using a wrapper like this avoids the issue, for some
# reason (perhaps because it's marking it as a pointer?)
AfterLoopWrapper:tmp is epsilon [ tmp = inst_start + 2; ] { export *[inst]:1 tmp; }

# 0000 0000 010r rrrr
with : op5_8=0b010 & op8_16=0 {
r_opc:"LOOP" is epsilon {}
r_opp:reg0_5 is reg0_5 & saturated_reg0_5 & CurSt3 & AfterLoopWrapper [
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = inst_start + 2;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopcheck);
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopcheck = 0;
	hasloopjumpback = 0;
	loopskipaddr = 0;
	loopjumpbackaddr = 0;
] {
	CurSt3 = saturated_reg0_5;
}
}

# 0000 0000 011r rrrr aaaa aaaa aaaa aaaa
# with blocks don't seem to work for multi-token instructions
r_opc:"BLOOP" is op5_8=0b011 & op8_16=0; imm16 {}
@ifndef BLOOP_ONE_AFTER
r_opp:reg0_5, Addr16 is reg0_5 & saturated_reg0_5 & op5_8=0b011 & op8_16=0 & CurSt3; Addr16 & Addr16After & imm16
@else
r_opp:reg0_5, Addr16After is reg0_5 & saturated_reg0_5 & op5_8=0b011 & op8_16=0 & CurSt3; Addr16 & Addr16After & imm16
@endif
[
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = imm16 + 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(Addr16After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopcheck);
	globalset(Addr16, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(Addr16, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopcheck = 0;
	hasloopjumpback = 0;
	loopskipaddr = 0;
	loopjumpbackaddr = 0;
] {
	CurSt3 = saturated_reg0_5;
}

# 0000 0000 100d dddd iiii iiii iiii iiii
r_opc:"LRI" is op5_8=0b100 & op8_16=0; imm16 {}
r_opp:reg0_5, Imm16 is reg0_5 & op5_8=0b100 & op8_16=0 & sign_extend_reg0_5_after; Imm16 {
	reg0_5 = Imm16;
	build sign_extend_reg0_5_after;
}

# 0000 0000 101x xxxx
# No instruction with op5_8=0b101 & op8_16=0

# 0000 0000 110d dddd mmmm mmmm mmmm mmmm
r_opc:"LR" is op5_8=0b110 & op8_16=0; imm16 {}
r_opp:reg0_5, Mem16 is reg0_5 & op5_8=0b110 & op8_16=0 & sign_extend_reg0_5_after; Mem16 {
	reg0_5 = Mem16;
	build sign_extend_reg0_5_after;
}

# 0000 0000 111s ssss mmmm mmmm mmmm mmmm
r_opc:"SR" is op5_8=0b111 & op8_16=0; imm16 {}
r_opp:Mem16, reg0_5 is reg0_5 & op5_8=0b111 & op8_16=0 & saturated_reg0_5; Mem16 {
	Mem16 = saturated_reg0_5;
}

cc: "GE"  is cc0_4=0b0000 { c:1 = ($(SR_OVERFLOW) == $(SR_SIGN)); export c; }
cc: "L"   is cc0_4=0b0001 { c:1 = ($(SR_OVERFLOW) != $(SR_SIGN)); export c; }
cc: "G"   is cc0_4=0b0010 { c:1 = (($(SR_OVERFLOW) == $(SR_SIGN)) && !$(SR_ARITH_ZERO)); export c; }
cc: "LE"  is cc0_4=0b0011 { c:1 = (($(SR_OVERFLOW) != $(SR_SIGN)) || $(SR_ARITH_ZERO)); export c; }
cc: "NZ"  is cc0_4=0b0100 { c:1 = !$(SR_ARITH_ZERO); export c; }
cc: "Z"   is cc0_4=0b0101 { c:1 = $(SR_ARITH_ZERO); export c; }
cc: "NC"  is cc0_4=0b0110 { c:1 = !$(SR_CARRY); export c; }
cc: "C"   is cc0_4=0b0111 { c:1 = $(SR_CARRY); export c; }
cc: "x8"  is cc0_4=0b1000 { c:1 = !$(SR_OVER_32); export c; } # "Below s32"
cc: "x9"  is cc0_4=0b1001 { c:1 = $(SR_OVER_32); export c; } # "Above s32"
cc: "xA"  is cc0_4=0b1010 { c:1 = (($(SR_OVER_32) || $(SR_TOP2BITS)) && !$(SR_ARITH_ZERO)); export c; } # Per dolphin
cc: "xB"  is cc0_4=0b1011 { c:1 = ((!$(SR_OVER_32) && !$(SR_TOP2BITS)) || $(SR_ARITH_ZERO)); export c; } # Per dolphin
cc: "LNZ" is cc0_4=0b1100 { c:1 = !$(SR_LOGIC_ZERO); export c; }
cc: "LZ"  is cc0_4=0b1101 { c:1 = $(SR_LOGIC_ZERO); export c; }
cc: "O"   is cc0_4=0b1110 { c:1 = $(SR_OVERFLOW); export c; }
# The always variant (cc0_4=0b1111) isn't listed here, so it can be handled separately

# 0000 0010 0111 cccc
with : op4_8=0b0111 & op8_16=2 {
r_opc:"IF"^cc is cc {}
r_opp:"" is cc {
	if (!cc) goto inst_next;
	# Use delayslot to merge the next instruction; this makes goto inst_next skip past the merged instruction
	# (and also automatically marks the affected instruction, for free!)
	delayslot(1);
}
}

# 0000 0010 1001 cccc aaaa aaaa aaaa aaaa
r_opc:"J"^cc is cc & op4_8=0b1001 & op8_16=2; imm16 {}
r_opp:Addr16 is cc & op4_8=0b1001 & op8_16=2; Addr16 {
	if (!cc) goto inst_next;
	goto Addr16;
}

# 0000 0010 1011 cccc aaaa aaaa aaaa aaaa
r_opc:"CALL"^cc is cc & op4_8=0b1011 & op8_16=2; imm16 {}
r_opp:Addr16    is cc & op4_8=0b1011 & op8_16=2; Addr16 {
	st0 = inst_next;
	if (!cc) goto inst_next;
	call Addr16;
}

# 0000 0010 1101 cccc
with : op4_8=0b1101 & op8_16=2 {
r_opc:"RET"^cc is cc {}
r_opp:"" is cc {
	if (!cc) goto inst_next;

	return [st0];
}
}

# 0000 0010 1111 cccc
with : op4_8=0b1111 & op8_16=2 {
r_opc:"RTI"^cc is cc {}
r_opp:"" is cc {
	if (!cc) goto inst_next;

	tmp:2 = 0; # TODO: Return address
	return [tmp];
}
}

# Unconditional variants

# 0000 0010 0111 1111
# Unconditionally execute the next opcode, presumably... not very useful?  Mark as unimpl so that a warning occurs
with : cc0_4=0b1111 & op4_8=0b0111 & op8_16=2 {
r_opc:"IF" is epsilon {}
r_opp:"" is epsilon unimpl
}

# 0000 0010 1001 1111 aaaa aaaa aaaa aaaa
r_opc:"JMP"  is cc0_4=0b1111 & op4_8=0b1001 & op8_16=2; imm16 {}
r_opp:Addr16 is cc0_4=0b1111 & op4_8=0b1001 & op8_16=2; Addr16 {
	goto Addr16;
}

# 0000 0010 1011 1111 aaaa aaaa aaaa aaaa
r_opc:"CALL" is cc0_4=0b1111 & op4_8=0b1011 & op8_16=2; imm16 {}
r_opp:Addr16 is cc0_4=0b1111 & op4_8=0b1011 & op8_16=2; Addr16 {
	st0 = inst_next;
	call Addr16;
}

# 0000 0010 1101 1111
with : cc0_4=0b1111 & op4_8=0b1101 & op8_16=2 {
r_opc:"RET" is epsilon {}
r_opp:"" is epsilon {
	return [st0];
}
}

# 0000 0010 1111 1111
with : cc0_4=0b1111 & op4_8=0b1111 & op8_16=2 {
r_opc:"RTI" is epsilon {}
r_opp:"" is epsilon {
	tmp:2 = 0; # TODO: Return address
	return [tmp];
}
}

# 0000 001d 0000 0000 iiii iiii iiii iiii
r_opc:"ADDI" is op0_4=0 & op4_8=0b0000 & op9_16=1; imm16 {}
r_opp:acs8, SImm16 is op0_4=0 & op4_8=0b0000 & acs8 & op9_16=1 & acf8; SImm16 {
	FLAGS_ADD40(acf8, sext(SImm16) << 16); acs8 = acs8 + sext(SImm16);
}

# 0000 001d 0010 0000 iiii iiii iiii iiii
r_opc:"XORI" is op0_4=0 & op4_8=0b0010 & op9_16=1; imm16 {}
r_opp:acm8, Imm16 is op0_4=0 & op4_8=0b0010 & acm8 & op9_16=1 & acf8; Imm16 {
	acm8 = acm8 ^ Imm16; FLAGS16(acm8, acf8);
}

# 0000 001d 0100 0000 iiii iiii iiii iiii
r_opc:"ANDI" is op0_4=0 & op4_8=0b0100 & op9_16=1; imm16 {}
r_opp:acm8, Imm16 is op0_4=0 & op4_8=0b0100 & acm8 & op9_16=1 & acf8; Imm16 {
	acm8 = acm8 & Imm16; FLAGS16(acm8, acf8);
}

# 0000 001d 0110 0000 iiii iiii iiii iiii
r_opc:"ORI" is op0_4=0 & op4_8=0b0110 & op9_16=1; imm16 {}
r_opp:acm8, Imm16 is op0_4=0 & op4_8=0b0110 & acm8 & op9_16=1 & acf8; Imm16 {
	acm8 = acm8 | Imm16; FLAGS16(acm8, acf8);
}

# 0000 001d 1000 0000 iiii iiii iiii iiii
r_opc:"CMPI" is op0_4=0 & op4_8=0b1000 & op9_16=1; imm16 {}
r_opp:acf8, SImm16 is op0_4=0 & op4_8=0b1000 & acf8 & op9_16=1; SImm16 {
	FLAGS_SUB40(acf8, sext(SImm16) << 16);
}

# 0000 001d 1010 0000 iiii iiii iiii iiii
r_opc:"ANDF" is op0_4=0 & op4_8=0b1010 & op9_16=1; imm16 {}
r_opp:acm8, Imm16 is op0_4=0 & op4_8=0b1010 & acm8 & op9_16=1; Imm16 {
	$(SR_LOGIC_ZERO) = ((acm8 & Imm16) == 0);
}

# 0000 001d 1100 0000 iiii iiii iiii iiii
r_opc:"ANDCF" is op0_4=0 & op4_8=0b1100 & op9_16=1; imm16 {}
r_opp:acm8, Imm16 is op0_4=0 & op4_8=0b1100 & acm8 & op9_16=1; Imm16 {
	$(SR_LOGIC_ZERO) = ((acm8 & Imm16) == Imm16);
}

@ifdef SIMPLIFY_SHIFTS
define pcodeop twowaylogicalshift;
define pcodeop twowayarithmeticshift;

macro TwoWayLogicalShift(value, shift) {
	value = twowaylogicalshift(value, shift);
	FLAGS40(value);
}

macro TwoWayArithmeticShift(value, shift) {
	value = twowayarithmeticshift(value, shift);
	FLAGS40(value);
}
@else
macro TwoWayLogicalShift(value, shift) {
	# Treated as a signed 7-bit field, like LSL/LSR
	if (shift[6,1] == 1) goto <rightshift>;

	# left shift
	value = value << shift[0,6];
	goto <done>;

	<rightshift>
	# A right-shift of 64 is actually a right-shift of 0
	if (shift[0,6] == 0) goto <done>;

	value = value >> (64 - shift[0,6]);

	<done>
	FLAGS40(value);
}

macro TwoWayArithmeticShift(value, shift) {
	# Treated as a signed 7-bit field, like ASL/ASR
	if (shift[6,1] == 1) goto <rightshift>;

	# left shift
	value = value << shift[0,6];
	goto <done>;

	<rightshift>
	# A right-shift of 64 is actually a right-shift of 0
	if (shift[0,6] == 0) goto <done>;

	value = value s>> (64 - shift[0,6]);

	<done>
	FLAGS40(value);
}
@endif

# Dolphin's DSPTables.cpp mentions "these two were discovered by ector".
# These two operate directly on acc0 and ac1.m.
# 0000 0010 1100 1010
with : op0_4=0b1010 & op4_8=0b1100 & op8_16=2 {
r_opc:"LSRN" is epsilon {}
r_opp:"" is epsilon {
	TwoWayLogicalShift(acc0, ac1.m);
}
}

# 0000 0010 1100 1011
with : op0_4=0b1011 & op4_8=0b1100 & op8_16=2 {
r_opc:"ASRN" is epsilon {}
r_opp:"" is epsilon {
	TwoWayArithmeticShift(acc0, ac1.m);
}
}

# 0000 001d 0001 00ss
with : op2_4=0 & op4_8=1 & op9_16=1 {
r_opc:"ILRR" is epsilon {}
r_opp:acm8, "@"^ar0_2 is ar0_2 & acm8 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	build sign_extend_acm8_after;
}
}

# 0000 001d 0001 01ss
with : op2_4=1 & op4_8=1 & op9_16=1 {
r_opc:"ILRRD" is epsilon {}
r_opp:acm8, "@"^ar0_2 is ar0_2 & acm8 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	ar0_2 = ar0_2 - 1;
	build sign_extend_acm8_after;
}
}

# 0000 001d 0001 10ss
with : op2_4=2 & op4_8=1 & op9_16=1 {
r_opc:"ILRRI" is epsilon {}
r_opp:acm8, "@"^ar0_2 is ar0_2 & acm8 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	ar0_2 = ar0_2 + 1;
	build sign_extend_acm8_after;
}
}

# 0000 001d 0001 11ss
# ar0_2 and ix0_2 are the same bits in the instruction.  The manual doesn't show ix0_2, but I've included it in the disassembly.
with : op2_4=3 & op4_8=1 & op9_16=1 {
r_opc:"ILRRN" is epsilon {}
r_opp:acm8, "@"^ar0_2, ix0_2 is ar0_2 & acm8 & ix0_2 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	ar0_2 = ar0_2 + ix0_2;
	build sign_extend_acm8_after;
}
}

# 0000 010d iiii iiii
with : op9_16=0b0000010 {
r_opc:"ADDIS" is epsilon {}
r_opp:acf8, SImm8 is SImm8 & acf8 & acs8 {
	FLAGS_ADD40(acf8, sext(SImm8) << 16);
	acs8 = acs8 + sext(SImm8);
}
}

# 0000 011d iiii iiii
with : op9_16=0b0000011 {
r_opc:"CMPIS" is epsilon {}
r_opp:acf8, SImm8 is SImm8 & acf8 {
	FLAGS_SUB40(acf8, sext(SImm8) << 16);
}
}

# 0000 1ddd iiii iiii
with : op11_16=0b00001 {
r_opc:"LRIS" is epsilon {}
r_opp:ac8_11, SImm8 is SImm8 & ac8_11 & sign_extend_ac8_11_after {
	ac8_11 = SImm8;
	build sign_extend_ac8_11_after;
}
}

# 0001 0000 iiii iiii
with : op8_16=0b00010000 {
r_opc:"LOOPI" is epsilon {}
r_opp:Imm8 is Imm8 & CurSt3 & AfterLoopWrapper [
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = inst_start + 2;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopcheck);
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopcheck = 0;
	hasloopjumpback = 0;
	loopskipaddr = 0;
	loopjumpbackaddr = 0;
] {
	CurSt3 = Imm8;
}
}

# 0001 0001 iiii iiii aaaa aaaa aaaa aaaa
r_opc:"BLOOPI" is op8_16=0b00010001; imm16 {}
@ifndef BLOOP_ONE_AFTER
r_opp:Imm8, Addr16 is Imm8 & op8_16=0b00010001 & CurSt3; Addr16 & Addr16After & imm16
@else
r_opp:Imm8, Addr16After is Imm8 & op8_16=0b00010001 & CurSt3; Addr16 & Addr16After & imm16
@endif
[
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = imm16 + 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(Addr16After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopcheck);
	globalset(Addr16, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(Addr16, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopcheck = 0;
	hasloopjumpback = 0;
	loopskipaddr = 0;
	loopjumpbackaddr = 0;
] {
	CurSt3 = Imm8;
}

# 0001 0010 xxxx xiii
# op3_8 is marked as xxxxx in the table but shown as 0s for the instruction itself
with : op3_8=0 & op8_16=0b00010010 {
r_opc:"SBCLR" is epsilon {}
r_opp:srbit is srbit {
@ifdef USE_REAL_SR_REGISTER
	sr = sr | 1 << (6 + srbit);
@else
	srbit = 1;
@endif
}
}

# 0001 0011 xxxx xiii
with : op3_8=0 & op8_16=0b00010011 {
r_opc:"SBSET" is epsilon {}
r_opp:srbit is srbit {
@ifdef USE_REAL_SR_REGISTER
	sr = sr & ~(1 << (6 + srbit));
@else
	srbit = 0;
@endif
}
}

# 0001 010r 00ii iiii
# The manual is written such that it implies LSL/LSR and ASL/ASR are the same instruction with a 7-bit signed immediate value,
# though it treats them as 2 pairs of instructions with a 6-bit value (allegedly somehow sign-extended for the right-shift)
with : op6_8=0b00 & op9_16=0b0001010 {
r_opc:"LSL" is Imm6 & acf8 {}
r_opp:acf8, Imm6 is Imm6 & acf8 {
	acf8 = acf8 << Imm6;
	FLAGS40(acf8);
}
}

# 0001 010r 01ii iiii
# To handle right shifts correctly, we subtract 64 and then negate.
# Dolphin decodes (well, used to; there's a regression with fmt currently) 1479 as "lsr $ACC0, #-7" which we change to "LSR acc0, #7".
# Without manual handling, you get "LSR acc0,#0x39" instead.
# Note that if the immediate value is 0, then a shift of 0 still occurs.  Imm6Right handles this.
with : op6_8=0b01 & op9_16=0b0001010 {
r_opc:"LSR" is epsilon {}
r_opp:acf8, Imm6Right is Imm6Right & acf8 {
	acf8 = acf8 >> Imm6Right;
	FLAGS40(acf8);
}
}

# 0001 010r 10ii iiii
with : op6_8=0b10 & op9_16=0b0001010 {
r_opc:"ASL" is epsilon {}
r_opp:acf8, Imm6 is Imm6 & acf8 {
	# This doesn't do anything different, does it?
	acf8 = acf8 << Imm6;
	FLAGS40(acf8);
}
}

# 0001 010r 11ii iiii
with : op6_8=0b11 & op9_16=0b0001010 {
r_opc:"ASR" is epsilon {}
r_opp:acf8, Imm6Right is Imm6Right & acf8 {
	acf8 = acf8 s>> Imm6Right;
	FLAGS40(acf8);
}
}

# 0001 0110 mmmm mmmm iiii iiii iiii iiii
r_opc:"SI" is op8_16=0b00010110; imm16 {}
r_opp:Mem8FF, Imm16 is Mem8FF & op8_16=0b00010110; Imm16 {
	Mem8FF = Imm16;
}

# 0001 0111 rrr0 cccc
with : op5=0 & op8_16=0b00010111 {
r_opc:"JR"^cc is cc {}
r_opp:reg5_8 is cc & reg5_8 {
	if (!cc) goto inst_next;
	goto [reg5_8];
}
}

# 0001 0111 rrr1 cccc
with : op5=1 & op8_16=0b00010111 {
r_opc:"CALLR"^cc is cc {}
r_opp:reg5_8 is cc & reg5_8 {
	if (!cc) goto inst_next;
	# TODO: Update stack
	call [reg5_8];
}
}

# 0001 0111 rrr0 1111
with : cc0_4=0b1111 & op5=0 & op8_16=0b00010111 {
r_opc:"JMPR" is epsilon {}
r_opp:reg5_8 is reg5_8 {
	goto [reg5_8];
}
}

# 0001 0111 rrr1 1111
with : cc0_4=0b1111 & op5=1 & op8_16=0b00010111 {
r_opc:"CALLR" is epsilon {}
r_opp:reg5_8 is reg5_8 {
	# TODO: Update stack
	call [reg5_8];
}
}

# 0001 1000 0ssd dddd
with : op7_9=0b00 & op9_16=0b0001100 {
r_opc:"LRR" is epsilon {}
r_opp:reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	build sign_extend_reg0_5_after;
}
}

# 0001 1000 1ssd dddd
with : op7_9=0b01 & op9_16=0b0001100 {
r_opc:"LRRD" is epsilon {}
r_opp:reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 - 1;
	build sign_extend_reg0_5_after;
}
}

# 0001 1001 0ssd dddd
with : op7_9=0b10 & op9_16=0b0001100 {
r_opc:"LRRI" is epsilon {}
r_opp:reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 + 1;
	build sign_extend_reg0_5_after;
}
}

# 0001 1001 1ssd dddd
with : op7_9=0b11 & op9_16=0b0001100 {
r_opc:"LRRN" is epsilon {}
r_opp:reg0_5, "@"^ar5_7, ix5_7 is reg0_5 & ar5_7 & ix5_7 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 + ix5_7;  # ar5_7 and ix5_7 are the same bits in the instruction.  I've included it in the disassembly, but it's not like that in the manual.
	build sign_extend_reg0_5_after;
}
}

# 0001 1010 0dds ssss
with : op7_9=0b00 & op9_16=0b0001101 {
r_opc:"SRR" is epsilon {}
r_opp:"@"^ar5_7, reg0_5 is reg0_5 & ar5_7 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
}
}

# 0001 1010 1dds ssss
with : op7_9=0b01 & op9_16=0b0001101 {
r_opc:"SRRD" is epsilon {}
r_opp:"@"^ar5_7, reg0_5 is reg0_5 & ar5_7 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
	ar5_7 = ar5_7 - 1;
}
}

# 0001 1011 0dds ssss
with : op7_9=0b10 & op9_16=0b0001101 {
r_opc:"SRRI" is epsilon {}
r_opp:"@"^ar5_7, reg0_5 is reg0_5 & ar5_7 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
	ar5_7 = ar5_7 + 1;
}
}

# 0001 1011 1dds ssss
with : op7_9=0b11 & op9_16=0b0001101 {
r_opc:"SRRN" is epsilon {}
r_opp:"@"^ar5_7, reg0_5, ix5_7 is reg0_5 & ar5_7 & ix5_7 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
	ar5_7 = ar5_7 + ix5_7;  # ar5_7 and ix5_7 are the same bits in the instruction.  I've included it in the disassembly, but it's not like that in the manual.
}
}

# 0001 11dd ddds ssss
with : op10_16=0b000111 {
r_opc:"MRR" is epsilon {}
r_opp:reg5_10, reg0_5 is reg0_5 & reg5_10 & sign_extend_reg5_10_after & saturated_reg0_5 {
	reg5_10 = saturated_reg0_5;
	build sign_extend_reg5_10_after;
}
}

# 0010 0ddd mmmm mmmm
with : op11_16=0b00100 {
r_opc:"LRS" is epsilon {}
r_opp:ac8_11, Mem8CR is ac8_11 & Mem8CR & sign_extend_ac8_11_after {
	ac8_11 = Mem8CR;
	build sign_extend_ac8_11_after;
}
}

# 0010 100s mmmm mmmm
with : op9_16=0b0010100 {
r_opc:"SRSH" is epsilon {}
r_opp:Mem8CR, ach8display is Mem8CR & ach8display & ach8 {
	Mem8CR = sext(ach8);
}
}

# 0010 101x mmmm mmmm is unused and seems to do nothing

# 0010 11ss mmmm mmmm
with : op10_16=0b001011 {
r_opc:"SRS" is epsilon {}
r_opp:Mem8CR, ac8_10 is Mem8CR & ac8_10 & saturated_ac8_10 {
	Mem8CR = saturated_ac8_10;
}
}

#---------------------------------------------------------------------------------------------------
# Define arithmetic opcodes and opcode parameters.
# We define them separately to match the format in the manual
# (OPC'EXOPC <opcode parameters> : <extended opcode parameters>).
# At first it looks like it would also be possible to have regular arithmetic instructions and
# extension instructions treated as two single-byte instructions by Ghirda, but in practice that's
# not possible because when aop4_8=0b0011, the arithmetic opcode is 9 bits and the extension is 7!
#
# In this section, bits are numbered like this:
# 7654 3210 Xxxx xxxx
# where the X bit (axbit) is only used for aop4_8=0b0011 (3).
#---------------------------------------------------------------------------------------------------

# 0011 00sd 0xxx xxxx
with : aop2_4=0 & aop4_8=0b0011 & axbit=0 {
a_opc:"XORR" is epsilon {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aacf0 {
	aacm0 = aacm0 ^ aaxh1;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 01sd 0xxx xxxx
with : aop2_4=1 & aop4_8=0b0011 & axbit=0 {
a_opc:"ANDR" is epsilon {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aacf0 {
	aacm0 = aacm0 & aaxh1;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 10sd 0xxx xxxx
with : aop2_4=2 & aop4_8=0b0011 & axbit=0 {
a_opc:"ORR" is epsilon {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aacf0 {
	aacm0 = aacm0 | aaxh1;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 110d 0xxx xxxx
with : aop1=0 & aop2_4=3 & aop4_8=0b0011 & axbit=0 {
a_opc:"ANDC" is epsilon {}
a_opp:aacm0, aacm0_other is aacm0 & aacm0_other & aacf0 {
	aacm0 = aacm0 & aacm0_other;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 111d 0xxx xxxx
with : aop1=1 & aop2_4=3 & aop4_8=0b0011 & axbit=0 {
a_opc:"ORC" is epsilon {}
a_opp:aacm0, aacm0_other is aacm0 & aacm0_other & aacf0 {
	aacm0 = aacm0 | aacm0_other;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 000d 1xxx xxxx
with : aop1=0 & aop2_4=0 & aop4_8=0b0011 & axbit=1 {
a_opc:"XORC" is epsilon {}
a_opp:aacm0, aacm0_other is aacm0 & aacm0_other & aacf0 {
	aacm0 = aacm0 ^ aacm0_other;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 001d 1xxx xxxx
with : aop1=1 & aop2_4=0 & aop4_8=0b0011 & axbit=1 {
a_opc:"NOT" is epsilon {}
a_opp:aacm0 is aacm0 & aacf0 {
	aacm0 = ~aacm0;
	FLAGS16(aacm0, aacf0);
}
}

# 0011 01sd 1xxx xxxx
with : aop2_4=1 & aop4_8=0b0011 & axbit=1 {
a_opc:"LSRNRX" is epsilon {}
a_opp:aacf0, aaxh1 is aacf0 & aaxh1 {
	TwoWayLogicalShift(aacf0, aaxh1[0,6]);
}
}

# 0011 10sd 1xxx xxxx
with : aop2_4=2 & aop4_8=0b0011 & axbit=1 {
a_opc:"ASRNRX" is epsilon {}
a_opp:aacf0, aaxh1 is aacf0 & aaxh1 {
	TwoWayArithmeticShift(aacf0, aaxh1[0,6]);
}
}

# 0011 110d 1xxx xxxx
with : aop1=0 & aop2_4=3 & aop4_8=0b0011 & axbit=1 {
a_opc:"LSRNR" is epsilon {}
a_opp:aacf0, aacm0_other is aacf0 & aacm0_other {
	TwoWayLogicalShift(aacf0, aacm0_other);
}
}

# 0011 111d 1xxx xxxx
with : aop1=1 & aop2_4=3 & aop4_8=0b0011 & axbit=1 {
a_opc:"ASRNR" is epsilon {}
a_opp:aacf0, aacm0_other is aacf0 & aacm0_other {
	TwoWayArithmeticShift(aacf0, aacm0_other);
}
}

# Remaining arithmetic instructions, where aop4_8 != 0b0011:
# 0100 0ssd xxxx xxxx
with : aop3=0 & aop4_8=0b0100 {
a_opc:"ADDR" is epsilon {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 {
	FLAGS_ADD40(aacf0, sext(aax1_2));
	aacf0 = aacf0 + sext(aax1_2);
}
}

# 0100 10sd xxxx xxxx
with : aop2_4=2 & aop4_8=0b0100 {
a_opc:"ADDAX" is epsilon {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 {
	FLAGS_ADD40(aacf0, sext(aaxf1));
	aacf0 = aacf0 + sext(aaxf1);
}
}

# 0100 110d xxxx xxxx
with : aop1=0 & aop2_4=3 & aop4_8=0b0100 {
a_opc:"ADD" is epsilon {}
a_opp:aacf0, aacf0_other is aacf0 & aacf0_other {
	FLAGS_ADD40(aacf0, aacf0_other);
	aacf0 = aacf0 + aacf0_other;
}
}

# 0100 111d xxxx xxxx
with : aop1=1 & aop2_4=3 & aop4_8=0b0100 {
a_opc:"ADDP" is epsilon {}
a_opp:aacf0 is aacf0 {
	FLAGS_ADD40(aacf0, prod);
	aacf0 = aacf0 + prod;
}
}

# 0101 0ssd xxxx xxxx
with : aop3=0 & aop4_8=0b0101 {
a_opc:"SUBR" is epsilon {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 {
	FLAGS_SUB40(aacf0, sext(aax1_2));
	aacf0 = aacf0 - sext(aax1_2);
}
}

# 0101 10sd xxxx xxxx
with : aop2_4=2 & aop4_8=0b0101 {
a_opc:"SUBAX" is epsilon {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 {
	FLAGS_SUB40(aacf0, sext(aaxf1));
	aacf0 = aacf0 - sext(aaxf1);
}
}

# 0101 110d xxxx xxxx
with : aop1=0 & aop2_4=3 & aop4_8=0b0101 {
a_opc:"SUB" is epsilon {}
a_opp:aacf0, aacf0_other is aacf0 & aacf0_other {
	FLAGS_SUB40(aacf0, aacf0_other);
	aacf0 = aacf0 - aacf0_other;
}
}

# 0101 111d xxxx xxxx
with : aop1=1 & aop2_4=3 & aop4_8=0b0101 {
a_opc:"SUBP" is epsilon {}
a_opp:aacf0 is aacf0 {
	FLAGS_SUB40(aacf0, prod);
	aacf0 = aacf0 - prod;
}
}

# 0110 0ssd xxxx xxxx
with : aop3=0 & aop4_8=0b0110 {
a_opc:"MOVR" is epsilon {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 {
	# high bits sign-extended, middle bits based on value, low bits zeroed
	# TODO: Use aacs0?
	aacf0 = sext(aax1_2) << 16;
	FLAGS40(aacf0);
}
}

# 0110 10sd xxxx xxxx
with : aop2_4=2 & aop4_8=0b0110 {
a_opc:"MOVAX" is epsilon {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 {
	aacf0 = sext(aaxf1);
	FLAGS40(aacf0);
}
}

# 0110 110d xxxx xxxx
with : aop1=0 & aop2_4=3 & aop4_8=0b0110 {
a_opc:"MOV" is epsilon {}
a_opp:aacf0, aacf0_other is aacf0 & aacf0_other {
	aacf0 = aacf0_other;
	FLAGS40(aacf0);
}
}

# 0110 111d xxxx xxxx
with : aop1=1 & aop2_4=3 & aop4_8=0b0110 {
a_opc:"MOVP" is epsilon {}
a_opp:aacf0 is aacf0 {
	aacf0 = prod;
	FLAGS40(aacf0);
}
}

# 0111 00sd xxxx xxxx
with : aop2_4=0 & aop4_8=0b0111 {
a_opc:"ADDAXL" is epsilon {}
a_opp:aacf0, aaxl1 is aacf0 & aaxl1 {
	FLAGS_ADD40(aacf0, zext(aaxl1));
	aacf0 = aacf0 + zext(aaxl1);  # Note: unsigned extension
}
}

# 0111 010d xxxx xxxx
with : aop1=0 & aop2_4=1 & aop4_8=0b0111 {
a_opc:"INCM" is epsilon {}
a_opp:aacs0 is aacs0 & aacf0 {
	FLAGS_ADD40(aacf0, 0x10000);
	aacs0 = aacs0 + 1;
}
}

# 0111 011d xxxx xxxx
with : aop1=1 & aop2_4=1 & aop4_8=0b0111 {
a_opc:"INC" is epsilon {}
a_opp:aacf0 is aacf0 {
	FLAGS_ADD40(aacf0, 1);
	aacf0 = aacf0 + 1;
}
}

# 0111 100d xxxx xxxx
with : aop1=0 & aop2_4=2 & aop4_8=0b0111 {
a_opc:"DECM" is epsilon {}
a_opp:aacs0 is aacs0 & aacf0 {
	FLAGS_SUB40(aacf0, 0x10000);
	aacs0 = aacs0 - 1;
}
}

# 0111 101d xxxx xxxx
with : aop1=1 & aop2_4=2 & aop4_8=0b0111 {
a_opc:"DEC" is epsilon {}
a_opp:aacf0 is aacf0 {
	FLAGS_SUB40(aacf0, 1);
	aacf0 = aacf0 - 1;
}
}

# 0111 110d xxxx xxxx
with : aop1=0 & aop2_4=3 & aop4_8=0b0111 {
a_opc:"NEG" is epsilon {}
a_opp:aacf0 is aacf0 {
	FLAGS_SUB40(0, aacf0);
	aacf0 = -aacf0;
}
}

# 0111 111d xxxx xxxx
with : aop1=1 & aop2_4=3 & aop4_8=0b0111 {
a_opc:"MOVNP" is epsilon {}
a_opp:aacf0 is aacf0 {
	aacf0 = -prod;
	FLAGS40(aacf0);
}
}

# 1000 x000 xxxx xxxx
# A NOP that is used to specify only an extended opcode.  Bit 3 can be either 0 or 1.
with : aop0_3=0 & aop4_8=0b1000 {
a_opc:"NX" is epsilon {}
a_opp:""   is epsilon {}
}

# 1000 r001 xxxx xxxx
with : aop0_3=1 & aop4_8=0b1000 {
a_opc:"CLR" is epsilon {}
a_opp:aacf3 is aacf3 {
	aacf3 = 0;
	FLAGS40(aacf3);
}
}

# 1000 0010 xxxx xxxx
with : aop0_3=0b010 & aop3=0 & aop4_8=0b1000 {
a_opc:"CMP" is epsilon {}
a_opp:""    is epsilon {
	FLAGS_SUB40(acc0, acc1);
}
}

# 1000 0011 xxxx xxxx
with : aop0_3=0b011 & aop3=0 & aop4_8=0b1000 {
a_opc:"MULAXH" is epsilon {}
a_opp:         is epsilon {
	prod = zext(ax0.h) * zext(ax0.h);
}
}

# 1000 0100 xxxx xxxx
with : aop0_3=0b100 & aop3=0 & aop4_8=0b1000 {
a_opc:"CLRP" is epsilon {}
a_opp:""     is epsilon {
	prod.l  = 0x0000;
	prod.m1 = 0xfff0;
	prod.h  = 0x00ff;
	prod.m2 = 0x0010;
	prod = 0;
}
}

# 1000 0101 xxxx xxxx
with : aop0_3=0b101 & aop3=0 & aop4_8=0b1000 {
a_opc:"TSTPROD" is epsilon {}
a_opp:          is epsilon {
	FLAGS40(prod);
}
}

# 1000 011r xxxx xxxx
with : aop1_4=0b011 & aop4_8=0b1000 {
a_opc:"TSTAXH" is epsilon {}
a_opp:aaxh0 is aaxh0 {
	FLAGS16X(aaxh0, 0, 0, 0);
}
}

# Note: there isn't a gap here; NX (theoretically) has a 1000 1000 form,
# and CLR $acc1 uses 1000 1001.

# 1000 1010 xxxx xxxx
with : aop0_8=0b10001010 {
a_opc:"M2" is epsilon {}
a_opp:""   is epsilon { $(SR_MUL_MODIFY) = 0; }  # 0 indicates modified behavior here
}

# 1000 1011 xxxx xxxx
with : aop0_8=0b10001011 {
a_opc:"M0" is epsilon {}
a_opp:""   is epsilon { $(SR_MUL_MODIFY) = 1; }
}

# 1000 1100 xxxx xxxx
with : aop0_8=0b10001100 {
a_opc:"CLR15" is epsilon {}
a_opp:""      is epsilon { $(SR_MUL_UNSIGNED) = 0; }
}

# 1000 1101 xxxx xxxx
with : aop0_8=0b10001101 {
a_opc:"SET15" is epsilon {}
a_opp:""      is epsilon { $(SR_MUL_UNSIGNED) = 1; }
}

# 1000 1110 xxxx xxxx
with : aop0_8=0b10001110 {
a_opc:"SET16" is epsilon {}
a_opp:""      is epsilon { $(SR_40_MODE) = 0; }
}

# 1000 1111 xxxx xxxx
with : aop0_8=0b10001111 {
a_opc:"SET40" is epsilon {}
a_opp:""      is epsilon { $(SR_40_MODE) = 1; }
}

# 1001 s000 xxxx xxxx
# TODO: "$sr.AM bit affects multiply result"
with : aop0_3=0b000 & aop4_8=0b1001 {
a_opc:"MUL" is epsilon {}
a_opp:aaxl3, aaxh3 is aaxl3 & aaxh3 { prod = sext(aaxl3) * sext(aaxh3); }
}

# 1001 r001 xxxx xxxx
with : aop0_3=0b001 & aop4_8=0b1001 {
a_opc:"ASR16" is epsilon {}
a_opp:aacf3 is aacf3 {
	aacf3 = aacf3 s>> 16;
	FLAGS40(aacf3);
}
}

# 1001 s01r xxxx xxxx
with : aop1_3=0b01 & aop4_8=0b1001 {
a_opc:"MULMVZ" is epsilon {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aaxl3 & aaxh3 {
	aacf0 = prod & 0xffffffff0000;
	prod = sext(aaxl3) * sext(aaxh3);
	FLAGS40(aacf0);
}
}

# 1001 s10r xxxx xxxx
with : aop1_3=0b10 & aop4_8=0b1001 {
a_opc:"MULAC" is epsilon {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aaxl3 & aaxh3 {
	aacf0 = aacf0 + prod;
	prod = sext(aaxl3) * sext(aaxh3);
	FLAGS40(aacf0);
}
}

# 1001 s11r xxxx xxxx
with : aop1_3=0b11 & aop4_8=0b1001 {
a_opc:"MULMV" is epsilon {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aaxl3 & aaxh3 {
	aacf0 = prod;
	prod = sext(aaxl3) * sext(aaxh3);
	FLAGS40(aacf0);
}
}

# 101s t000 xxxx xxxx
with : aop0_3=0b000 & aop5_8=0b101 {
a_opc:"MULX" is epsilon {}
a_opp:aax0lh4, aax1lh3 is aax1lh3 & aax0lh4 & aaxh3 {
	prod = sext(aax0lh4) * sext(aax1lh3);
}
}

# 1010 d001 xxxx xxxx
with : aop0_3=0b001 & aop4_8=0b1010 {
a_opc:"ABS" is epsilon {}
a_opp:aacf3 is aacf3 {
	if (aacf3 s>= 0) goto <nonnegative>;
	aacf3 = -aacf3;
	<nonnegative>
	FLAGS40(aacf3);
}
}

# 1011 r001 xxxx xxxx
with : aop0_3=0b001 & aop4_8=0b1011 {
a_opc:"TST" is epsilon {}
a_opp:aacf3 is aacf3 {
	FLAGS40(aacf3);
}
}

# 1011 r001 xxxx xxxx
with : aop1_3=0b01 & aop5_8=0b101 {
a_opc:"MULXMVZ" is epsilon {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aax1lh3 & aax0lh4 {
	aacf0 = prod & 0xffffffff0000;
	prod = sext(aax0lh4) * sext(aax1lh3);
	FLAGS40(aacf0);
}
}

# 101s t10r xxxx xxxx
with : aop1_3=0b10 & aop5_8=0b101 {
a_opc:"MULXAC" is epsilon {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aax1lh3 & aax0lh4 {
	aacf0 = aacf0 + prod;
	prod = sext(aax0lh4) * sext(aax1lh3);
	FLAGS40(aacf0);
}
}

# 101s t11r xxxx xxxx
with : aop1_3=0b11 & aop5_8=0b101 {
a_opc:"MULXMV" is epsilon {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aax1lh3 & aax0lh4 {
	aacf0 = prod;
	prod = sext(aax0lh4) * sext(aax1lh3);
	FLAGS40(aacf0);
}
}

# 110s t000 xxxx xxxx
with : aop0_3=0b000 & aop5_8=0b110 {
a_opc:"MULC" is epsilon {}
a_opp:aacm4, aaxh3 is aaxh3 & aacm4 {
	prod = sext(aacm4) * sext(aaxh3);
}
}

# 110r s001 xxxx xxxx
with : aop0_3=0b001 & aop5_8=0b110 {
a_opc:"CMPAXH" is epsilon {}
a_opp:aacf3, aaxh4 is aacf3 & aaxh4 {
	FLAGS_SUB40(aacf3, (sext(aaxh4) << 16));
}
}

# 110s t01r xxxx xxxx
with : aop1_3=0b01 & aop5_8=0b110 {
a_opc:"MULCMVZ" is epsilon {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aaxh3 & aacm4 {
	aacf0 = prod & 0xffffffff0000;
	prod = sext(aacm4) * sext(aaxh3);
	FLAGS40(aacf0);
}
}

# 110s t10r xxxx xxxx
with : aop1_3=0b10 & aop5_8=0b110 {
a_opc:"MULCAC" is epsilon {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aaxh3 & aacm4 {
	aacf0 = aacf0 + prod;
	prod = sext(aacm4) * sext(aaxh3);
	FLAGS40(aacf0);
}
}

# 110s t11r xxxx xxxx
with : aop1_3=0b11 & aop5_8=0b110 {
a_opc:"MULCMV" is epsilon {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aaxh3 & aacm4 {
	aacf0 = prod;
	prod = sext(aacm4) * sext(aaxh3);
	FLAGS40(aacf0);
}
}

# 1110 00st xxxx xxxx
with : aop2_4=0b00 & aop4_8=0b1110 {
a_opc:"MADDX" is epsilon {}
a_opp:aax0lh1, aax1lh0 is aax1lh0 & aax0lh1 {
	prod = prod + (sext(aax0lh1) * sext(aax1lh0));
}
}

# 1110 01st xxxx xxxx
with : aop2_4=0b01 & aop4_8=0b1110 {
a_opc:"MSUBX" is epsilon {}
a_opp:aax0lh1, aax1lh0 is aax1lh0 & aax0lh1 {
	prod = prod - (sext(aax0lh1) * sext(aax1lh0));
}
}

# 1110 10st xxxx xxxx
with : aop2_4=0b10 & aop4_8=0b1110 {
a_opc:"MADDC" is epsilon {}
a_opp:aacm1, aaxh0 is aaxh0 & aacm1 {
	prod = prod + (sext(aacm1) * sext(aaxh0));
}
}

# 1110 11st xxxx xxxx
with : aop2_4=0b11 & aop4_8=0b1110 {
a_opc:"MSUBC" is epsilon {}
a_opp:aacm1, aaxh0 is aaxh0 & aacm1 {
	prod = prod - (sext(aacm1) * sext(aaxh0));
}
}

# 1111 000r xxxx xxxx
with : aop1_4=0b000 & aop4_8=0b1111 {
a_opc:"LSL16" is epsilon {}
a_opp:aacf0 is aacf0 {
	aacf0 = aacf0 << 16;
	FLAGS40(aacf0);
}
}

# 1111 001s xxxx xxxx
with : aop1_4=0b001 & aop4_8=0b1111 {
a_opc:"MADD" is epsilon {}
a_opp:aaxl0, aaxh0 is aaxl0 & aaxh0 {
	prod = prod + (sext(aaxl0) * sext(aaxh0));
}
}

# 1111 010r xxxx xxxx
with : aop1_4=0b010 & aop4_8=0b1111 {
a_opc:"LSR16" is epsilon {}
a_opp:aacf0   is aacf0 {
	aacf0 = aacf0 >> 16;
	FLAGS40(aacf0);
}
}

# 1111 011s xxxx xxxx
with : aop1_4=0b011 & aop4_8=0b1111 {
a_opc:"MSUB" is epsilon {}
a_opp:aaxl0, aaxh0 is aaxl0 & aaxh0 {
	prod = prod - (sext(aaxl0) * sext(aaxh0));
}
}

# 1111 10sd xxxx xxxx
with : aop2_4=0b10 & aop4_8=0b1111 {
a_opc:"ADDPAXZ" is epsilon {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 {
	oldprod:5 = prod;
	# TODO: Does the masking happen before or after?
	# i.e. do prod.l and ax0.l/ax1.l affect the result?
	aacf0 = (prod + sext(aaxf1)) & 0xffffffff0000;
	# TODO: Why doesn't this set the overflow bit?
	FLAGS40X(aacf0, oldprod > aacf0, 0);
}
}

# 1111 110r xxxx xxxx
with : aop1_4=0b110 & aop4_8=0b1111 {
a_opc:"CLRL" is epsilon {}
a_opp:aacl0 is aacl0 & aacf0 {
	# TODO: This should be round-to-even
	aacl0 = 0;
	FLAGS40(aacf0);
}
}

# 1111 111d xxxx xxxx
with : aop1_4=0b111 & aop4_8=0b1111 {
a_opc:"MOVPZ" is epsilon {}
a_opp:aacf0 is aacf0 {
	aacf0 = prod & 0xffffffff0000;
	FLAGS40(aacf0);
}
}

#---------------------------------------------------------------------------------------------------
# Define extension opcodes and opcode parameters.
# We use two tables: ext_opc0 for bit 7 (axbit) being set to 0, and ext_opc1 for bit 7 being 1.
# This is so that arithmetic opcodes with aop4_8=0b0011 can be implemented correctly;
# they only have 7 bits of the extension opcode and treat the top bit as 0.
#
# Extension opcodes are executed in parallel with arithmetic opcodes; they both receive the input
# state (and weird behavior happens if they both write to the same register, which is only possible
# with 'L or 'LN). This is not currently emulated; instead, we execute the arithmetic opcode
# followed by the extension opcode.
#
# In this section, bits are numbered like this:
# xxxx xxxx X654 3210
# where the X bit is used to choose between ext_opc0 and ext_opc1, but not directly used otherwise.
#---------------------------------------------------------------------------------------------------

# xxxx xxxx 0000 00xx
# xop2_4=0 and xop4_8=0 encodes 'NOP, but we don't explicitly show that because it would result in
# a lot of noise for no gain. Note that the bottom two bits are unrestricted, though.

# xxxx xxxx 0000 01rr
with : xop2_4=1 & xop4_7=0 {
ext_opc0:"DR" is epsilon {}
ext_opp0:xar0_2 is xar0_2 { xar0_2 = xar0_2 - 1; }
}

# xxxx xxxx 0000 10rr
with : xop2_4=2 & xop4_7=0 {
ext_opc0:"IR" is epsilon {}
ext_opp0:xar0_2 is xar0_2 { xar0_2 = xar0_2 + 1; }
}

# xxxx xxxx 0000 11rr
# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
with : xop2_4=3 & xop4_7=0 {
ext_opc0:"NR" is epsilon {}
ext_opp0:xar0_2, xix0_2 is xar0_2 & xix0_2 { xar0_2 = xar0_2 + xix0_2; }
}

# xxxx xxxx 0001 ddss
with : xop4_7=1 {
ext_opc0:"MV" is epsilon {}
ext_opp0:xax2_4, xac0_2 is xac0_2 & xax2_4 & saturated_xac0_2 { xax2_4 = saturated_xac0_2; }
}

# xxxx xxxx 01dd d0ss
with : xop2=0 & xop6=1 {
ext_opc0:"L" is epsilon {}
ext_opp0:xac3_6, "@"^xar0_2 is xar0_2 & xac3_6 & sign_extend_xac3_6_after { xac3_6 = *:2 xar0_2; xar0_2 = xar0_2 + 1; build sign_extend_xac3_6_after; }
}

# xxxx xxxx 01dd d1ss
# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
with : xop2=1 & xop6=1 {
ext_opc0:"LN" is epsilon {}
ext_opp0:xac3_6, "@"^xar0_2, xix0_2 is xar0_2 & xix0_2 & xac3_6 & sign_extend_xac3_6_after { xac3_6 = *:2 xar0_2; xar0_2 = xar0_2 + xix0_2; build sign_extend_xac3_6_after; }
}

# xxxx xxxx 10dd 000s
with : xop1=0 & xop2_4=0 & xop6=0 {
ext_opc1:"LS" is epsilon {}
ext_opp1:xax4_6, xacm0 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 10dd 010s
with : xop1=0 & xop2_4=1 & xop6=0 {
ext_opc1:"LSN" is epsilon {}
ext_opp1:xax4_6, xacm0 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 10dd 100s
with : xop1=0 & xop2_4=2 & xop6=0 {
ext_opc1:"LSM" is epsilon {}
ext_opp1:xax4_6, xacm0 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 10dd 110s
with : xop1=0 & xop2_4=3 & xop6=0 {
ext_opc1:"LSNM" is epsilon {}
ext_opp1:xax4_6, xacm0 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 001s s0dd
with : xop2=0 & xop5=1 & xop6=0 {
ext_opc0:"S" is epsilon {}
ext_opp0:"@"^xar0_2, xac3_5 is xar0_2 & xac3_5 & saturated_xac3_5 { *:2 xar0_2 = saturated_xac3_5; xar0_2 = xar0_2 + 1; }
}

# xxxx xxxx 001s s1dd
# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
with : xop2=1 & xop5=1 & xop6=0 {
ext_opc0:"SN" is epsilon {}
ext_opp0:"@"^xar0_2, xac3_5, xix0_2 is xar0_2 & xac3_5 & xix0_2 & saturated_xac3_5 { *:2 xar0_2 = saturated_xac3_5; xar0_2 = xar0_2 + xix0_2; }
}

# xxxx xxxx 10dd 001s
with : xop1=1 & xop2_4=0 & xop6=0 {
ext_opc1:"SL" is epsilon {}
ext_opp1:xacm0, xax4_6 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 10dd 011s
with : xop1=1 & xop2_4=1 & xop6=0 {
ext_opc1:"SLN" is epsilon {}
ext_opp1:xacm0, xax4_6 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 10dd 101s
with : xop1=1 & xop2_4=2 & xop6=0 {
ext_opc1:"SLM" is epsilon {}
ext_opp1:xacm0, xax4_6 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 10dd 111s
with : xop1=1 & xop2_4=3 & xop6=0 {
ext_opc1:"SLNM" is epsilon {}
ext_opp1:xacm0, xax4_6 is xacm0 & xax4_6 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 11dr 00ss
# LD loads to both AX0 and AX1, with the instruction choosing separately for AX0.l vs AX0.h and AX1.l vs AX1.h.
# ax0 is set to the memory value pointed by a choice of AR0/1/2, while ax1 is set to the memory value pointed by AR3.
# AR3 cannot be used for the first value, as that encodes LDAX instead.  The address registers are increased by 1 or
# the corresponding index register (depending on M/N like the other extension instructions).
with : xop2_4=0 & xop6=1 {
ext_opc1:"LD" is epsilon {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xax1lh4 & xax0lh5 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + 1;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 11sr 0011
# LDAX sets ax0.h or ax1.h to the memory value pointed by either AR0 or AR1, and
# ax0.l or ax1.l to the memory value pointed by AR3.  The choice is either both
# ax0.h and ax0.l or ax1.h and ax1.l.  AR2 cannot be used.  M/N exist like normal.
with : xop0_2=3 & xop2_4=0 & xop6=1 {
ext_opc1:"LDAX" is epsilon {}
ext_opp1:xax4, "@"^xar5 is xax4 & xar5 & xaxl4 & xaxh4 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + 1;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 11dr 01ss
# xar0_2 and xix0_2 are the same bits in the instruction.  I haven't included it here (or in LDNM).
with : xop2_4=1 & xop6=1 {
ext_opc1:"LDN" is epsilon {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xax1lh4 & xax0lh5 & xix0_2 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + xix0_2;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 11sr 0111
with : xop0_2=3 & xop2_4=1 & xop6=1 {
ext_opc1:"LDAXN" is epsilon {}
ext_opp1:xax4, "@"^xar5 is xax4 & xar5 & xaxl4 & xaxh4 & xix5 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + xix5;
	ar3 = ar3 + 1;
}
}

# xxxx xxxx 11dr 10ss
with : xop2_4=2 & xop6=1 {
ext_opc1:"LDM" is epsilon {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xax1lh4 & xax0lh5 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + 1;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 11sr 1011
with : xop0_2=3 & xop2_4=2 & xop6=1 {
ext_opc1:"LDAXM" is epsilon {}
ext_opp1:xax4, "@"^xar5 is xax4 & xar5 & xaxl4 & xaxh4 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + 1;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 11dr 11ss
with : xop2_4=3 & xop6=1 {
ext_opc1:"LDNM" is epsilon {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xax1lh4 & xax0lh5 & xix0_2 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + xix0_2;
	ar3 = ar3 + ix3;
}
}

# xxxx xxxx 11dr 1111
with : xop0_2=3 & xop2_4=3 & xop6=1 {
ext_opc1:"LDAXNM" is epsilon{}
ext_opp1:xax4, "@"^xar5 is xax4 & xar5 & xaxl4 & xaxh4 & xix5 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + xix5;
	ar3 = ar3 + ix3;
}
}

#---------------------------------------------------------------------------------------------------
# Final opcode combination logic
#
# We build an opc table for opcodes, and an opp table for parameters. This is so that extension
# opcodes can be merged with the arithmetic opcode in the form MAIN'EXT main_param : ext_param.
# We also need this for regular instructions so that we can include loop data in the parameters.
# Otherwise, when loop data is present, everything gets treated as part of the mnemonic.
#
# All semantic actions are performed by the opp table.
#---------------------------------------------------------------------------------------------------

# First, deal with axbit's behavior for choosing extension opcodes:
ext_opc:^ext_opc0 is ext_opc0 & (axbit=0 | aop4_8=0b0011) {}
ext_opp:^ext_opp0 is ext_opp0 & (axbit=0 | aop4_8=0b0011) { build ext_opp0; }

ext_opc:^ext_opc1 is ext_opc1 & (axbit=1 & aop4_8!=0b0011) {}
ext_opp:^ext_opp1 is ext_opp1 & (axbit=1 & aop4_8!=0b0011) { build ext_opp1; }

# Regular opcodes are used directly:
opc:^r_opc is r_opc & (op12_16<0b0011 ...) {}
opp:^r_opp is r_opp & (op12_16<0b0011 ...) { build r_opp; }

# Combine arithmetic ops and extension ops:
with : (aop4_8>0b0010) {
opc:^a_opc^"'"^ext_opc is a_opc & ext_opc {}
opp:^a_opp ":" ext_opp is a_opp & ext_opp { build a_opp; build ext_opp; }

# If the extension opcode is set to 0, it indicates 'NOP.
# We could explicitly show 'NOP here, but that just adds noise for no benefit.
opc:^a_opc is a_opc & (axbit=0 | aop4_8=0b0011) & xop0_7=0 {}
opp:^a_opp is a_opp & (axbit=0 | aop4_8=0b0011) & xop0_7=0 { build a_opp; }
}
@endif
