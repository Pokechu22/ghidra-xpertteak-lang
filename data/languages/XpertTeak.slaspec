# sleigh specification file for GameCube DSP

# untested with this disabled, probably incorrect currently
@define TEAK_LITE_2

# Directly mutate the st0 register instead of a set of fake registers
# The fake registers provide better decompilation
#@define USE_REAL_ST0_REGISTER

@define NOCASH_SYNTAX

# Opening/closing brackets
@ifdef NOCASH_SYNTAX
@define OB "["
@define CB "]"
@else
@define OB "("
@define CB ")"
@endif

define endian=little;
define alignment=2;

define space code     type=ram_space      size=2 wordsize=2;
define space data     type=ram_space      size=2 wordsize=2 default;
define space register type=register_space size=1 wordsize=2;

# http://problemkaputt.de/gbatek.htm#dsiteakcpuregisters

define register offset=0x00 size=2 [ r0 r1 r2 r3 r4 r5 ];
@ifdef TEAK_LITE_2
define register offset=0x0c size=2 [ r6 ];
@endif
define register offset=0x0e size=2 [ r7 ]; # AKA rb

define register offset=0x10 size=2 [ x0 y0 ];
@ifdef TEAK_LITE_2
define register offset=0x14 size=2 [ x1 y1 ];
@endif

# Swapped by banke
define register offset=0x18 size=2 [ r0b r1b r4b ];
@ifdef TEAK_LITE_2
define register offset=0x1e size=2 [ r7b ];
@endif

# 33 bits (one of which is in stt1), at least on TL2.
define register offset=0x20 size=5 [ p0 p1 ];
# 2 bytes in p0
define register offset=0x22 size=2 [ p0h ];

# 18-bit PC, not encoding this directly
define register offset=0x2c size=3 [ pc_full ];
define register offset=0x2d size=2 [ pc ];

define register offset=0x30 size=2 [ sp sv mixp lc repc dvm ];
@ifdef TEAK_LITE_2
define register offset=0x3c size=2 [ vtr0 vtr1 ];
# 4 bits; not meaningful on the DSi
define register offset=0x40 size=2 [ prpage ];
@endif

# custom hardware extensions (e.g. I/O ports, not used here?)
define register offset=0x42 size=2 [ ext0 ext1 ext2 ext3 ];

define register offset=0x4a size=2 [ st0 st1 st2 ];
define register offset=0x50 size=2 [ icr ];
@ifdef TEAK_LITE_2
define register offset=0x52 size=2 [ stt0 stt1 stt2 ];
define register offset=0x58 size=2 [ mod0 mod1 mod2 mod3 ];
define register offset=0x60 size=2 [ ar0 ar1 arp0 arp1 arp2 arp3 ];
@endif
define register offset=0x6c size=2 [ cfgi cfgj ];
@ifdef TEAK_LITE_2
define register offset=0x70 size=2 [ stepi stepj cfgib cfgjb stepi0 stepj0 ];
@endif

# a0e and a1e are 4-bit instead of 8-bit on teak lite 1, and b0e and b1e don't exist
define register offset=0x81 size=1 [ a0e ];
define register offset=0x82 size=2 [ a0h a0l ];
define register offset=0x81 size=5 [ a0 ];
define register offset=0x91 size=1 [ a1e ];
define register offset=0x92 size=2 [ a1h a1l ];
define register offset=0x91 size=5 [ a1 ];
define register offset=0xa1 size=1 [ b0e ];
define register offset=0xa2 size=2 [ b0h b0l ];
define register offset=0xa1 size=5 [ b0 ];
define register offset=0xb1 size=1 [ b1e ];
define register offset=0xb2 size=2 [ b1h b1l ];
define register offset=0xb1 size=5 [ b1 ];

# Fake register for extra-fake purposes; hardware uses some of the stacks for this
define register offset=0xF0 size=8 [ loopcontext ];

# Magic to make loops work
define context loopcontext
	loopstackdepth = (16,19)
	loopjumpbackaddr = (32,47) noflow
	hasloopjumpback = (48,48) noflow
;

# Loop stack for the current loop counter. We don't currently have lc directly reflect this value,
# because doing so would be a bit difficult.
# Real hardware has a depth of 4, but more is used here to avoid emulating bkrepsto and to
# allow rep to use the same registers as bkrep.
define register offset=0xD0 size=2 [ lc_0 lc_1 lc_2 lc_3 lc_4 lc_5 lc_6 lc_7 ];
# Note: The outermost loop increments loopstackdepth and then uses CurSt3, so index 1 is the first.
# Although we could reset loopstackdepth for the loop instruction, it needs to be changed for
# the next instruction for flowing to work, and that instruction might need to check looping.
CurLC:lc_0 is loopstackdepth=1 & lc_0 { export lc_0; }
CurLC:lc_1 is loopstackdepth=2 & lc_1 { export lc_1; }
CurLC:lc_2 is loopstackdepth=3 & lc_2 { export lc_2; }
CurLC:lc_3 is loopstackdepth=4 & lc_3 { export lc_3; }
CurLC:lc_4 is loopstackdepth=5 & lc_4 { export lc_4; }
CurLC:lc_5 is loopstackdepth=6 & lc_5 { export lc_5; }
CurLC:lc_6 is loopstackdepth=7 & lc_6 { export lc_6; }
CurLC:lc_7 is loopstackdepth=8 & lc_7 { export lc_7; }

CurLC_Even_Not_In_Loop:CurLC is CurLC { export CurLC; }
CurLC_Even_Not_In_Loop:lc_0 is loopstackdepth=0 & lc_0 { export lc_0; }

# Regular and hacky implementation of status register
@ifdef USE_REAL_ST0_REGISTER
# TODO: st0 and stt0 both exist, what to do with that?
@define FLAG_R "st0[4,1]" # stt1[4,1]
# TODO: how do we handle writes to this?
@define FLAG_L "st0[5,1]" # stt0[0,1] | stt0[1,1]
@define FLAG_LM "stt0[0,0]"
@define FLAG_VL "stt0[1,0]"
@define FLAG_E "st0[6,1]" # stt0[2,1]
@define FLAG_C "st0[7,1]" # stt0[3,1]
@define FLAG_V "st0[8,1]" # stt0[4,1]
@define FLAG_N "st0[9,1]" # stt0[5,1]
@define FLAG_M "st0[10,1]" # stt0[6,1]
@define FLAG_Z "st0[11,1]" # stt0[7,1]
@define FLAG_C1 "stt0[11,1]"
@else
define space hack_register type=ram_space size=1;
define hack_register offset=0 size=1 [ FLAG_R_ FLAG_LM_ FLAG_VL_ FLAG_E_ FLAG_C_ FLAG_V_ FLAG_N_ FLAG_M_ FLAG_Z_ FLAG_C1_ ];
# Note: forcing to only a single bit.  Also, we need to use macros in both cases for consistent syntax.
@define FLAG_R "FLAG_R_[0,1]"
# TODO: how do we handle writes to this?
@define FLAG_L "(FLAG_LM_[0,1] | FLAG_VL_[0,1])"
@define FLAG_LM "FLAG_LM_[0,1]"
@define FLAG_VL "FLAG_VL_[0,1]"
@define FLAG_E "FLAG_E_[0,1]"
@define FLAG_C "FLAG_C_[0,1]"
@define FLAG_V "FLAG_V_[0,1]"
@define FLAG_N "FLAG_N_[0,1]"
@define FLAG_M "FLAG_M_[0,1]"
@define FLAG_Z "FLAG_Z_[0,1]"
@define FLAG_C1 "FLAG_C1_[0,1]"
@endif

define token opcode (16)
	opcode_0_0   = (0, 0)
	opcode_0_1   = (0, 1)
	opcode_0_2   = (0, 2)
	opcode_0_3   = (0, 3)
	opcode_0_4   = (0, 4)
	opcode_0_7   = (0, 7)
	opcode_0_9   = (0, 9)
	opcode_0_15  = (0, 15)
	opcode_1_1   = (1, 1)
	opcode_1_4   = (1, 4)
	opcode_1_5   = (1, 5)
	opcode_1_7   = (1, 7)
	opcode_1_9   = (1, 9)
	opcode_1_15  = (1, 15)
	opcode_2_2   = (2, 2)
	opcode_2_3   = (2, 3)
	opcode_2_4   = (2, 4)
	opcode_2_5   = (2, 5)
	opcode_2_7   = (2, 7)
	opcode_2_9   = (2, 9)
	opcode_2_15  = (2, 15)
	opcode_3_3   = (3, 3)
	opcode_3_4   = (3, 4)
	opcode_3_7   = (3, 7)
	opcode_3_9   = (3, 9)
	opcode_3_15  = (3, 15)
	opcode_4_4   = (4, 4)
	opcode_4_7   = (4, 7)
	opcode_4_11  = (4, 11)
	opcode_4_15  = (4, 15)
	opcode_5_5   = (5, 5)
	opcode_5_7   = (5, 7)
	opcode_5_10  = (5, 10)
	opcode_5_15  = (5, 15)
	opcode_6_6   = (6, 6)
	opcode_6_10  = (6, 10)
	opcode_6_15  = (6, 15)
	opcode_6_7   = (6, 7)
	opcode_7_7   = (7, 7)
	opcode_7_8   = (7, 8)
	opcode_7_9   = (7, 9)
	opcode_7_10  = (7, 10)
	opcode_7_15  = (7, 15)
	opcode_8_8   = (8, 8)
	opcode_8_9   = (8, 9)
	opcode_8_10  = (8, 10)
	opcode_8_11  = (8, 11)
	opcode_8_15  = (8, 15)
	opcode_9_9   = (9, 9)
	opcode_9_15  = (9, 15)
	opcode_10_15 = (10, 15)
	opcode_11_15 = (11, 15)
	opcode_12_15 = (12, 15)
	opcode_13_15 = (13, 15)

	# Nocash documentation indicates these explicitly (as otherwise you can't tell just looking at
	# the hex). Sleigh simply requires that no constraint act on those bits. So, these unused fields
	# aren't strictly needed, but are included in instruction constructors for completeness and to
	# make it easier to compare with nocash.
	unused_0_0   = (0, 0)
	unused_0_1   = (0, 1)
	unused_0_2   = (0, 2)
	unused_5_5   = (5, 5)
	unused_10_10 = (10, 10)

	imm2u_0 = (0, 1)
	imm2u_1 = (1, 2)
	imm4u_0 = (0, 3)
	imm4_8  = (8, 11)
	imm5u_0 = (0, 4)
	imm5s_0 = (0, 4) signed
	imm6s_0 = (0, 5) signed
	imm7s_0 = (0, 6) signed
	imm7s_4 = (4, 10) signed
	imm8_0  = (0, 7)
	imm8s_0 = (0, 7) signed
	imm8u_0 = (0, 7)
	imm9u_0 = (0, 8)

	Register_0_ = (0, 4)
	Register_5_ = (5, 9)

	Ax_0  = (0, 0)
	Ax_1  = (1, 1)
	Ax_3  = (3, 3)
	Ax_4  = (4, 4)
	Ax_5  = (5, 5)
	Ax_6  = (6, 6)
	Ax_8  = (8, 8)
	Ax_10 = (10, 10)
	Ax_11 = (11, 11)
	Ax_12 = (12, 12)
	Ax_Not0  = (0, 0)
	Ax_Not8  = (8, 8)
	Ax_Not12 = (12, 12)

	Axl_0  = (0, 0)
	Axl_1  = (1, 1)
	Axl_3  = (3, 3)
	Axl_4  = (4, 4)
	Axl_5  = (5, 5)
	Axl_6  = (6, 6)
	Axl_8  = (8, 8)
	Axl_11 = (11, 11)
	Axl_12 = (12, 12)
	Axl_Not0  = (0, 0)
	Axl_Not3  = (3, 3)
	Axl_Not4  = (4, 4)
	Axl_Not6  = (6, 6)
	Axl_Not8  = (8, 8)
	Axl_Not11 = (11, 11)

	Axh_0  = (0, 0)
	Axh_1  = (1, 1)
	Axh_3  = (3, 3)
	Axh_4  = (4, 4)
	Axh_6  = (6, 6)
	Axh_8  = (8, 8)
	Axh_9  = (9, 9)
	Axh_11 = (11, 11)
	Axh_12 = (12, 12)
	Axh_Not0  = (0, 0)
	Axh_Not3  = (3, 3)
	Axh_Not4  = (4, 4)
	Axh_Not6  = (6, 6)
	Axh_Not8  = (8, 8)
	Axh_Not11 = (11, 11)

	Px_0 = (0, 0)
	Px_1 = (1, 1)
	Px_4 = (4, 4)

	Bx_0 = (0, 0)
	Bx_1 = (1, 1)
	Bx_2 = (2, 2)
	Bx_3 = (3, 3)
	Bx_4 = (4, 4)
	Bx_5 = (5, 5)
	Bx_8 = (8, 8)
	Bx_10 = (10, 10)
	Bx_12 = (12, 12)

	Bxl_0 = (0, 0)
	Bxl_1 = (1, 1)
	Bxl_3 = (3, 3)
	Bxl_4 = (4, 4)
	Bxl_5 = (5, 5)
	Bxl_10 = (10, 10)
	Bxl_Not4 = (4, 4)

	Bxh_0 = (0, 0)
	Bxh_1 = (1, 1)
	Bxh_2 = (2, 2)
	Bxh_3 = (3, 3)
	Bxh_4 = (4, 4)
	Bxh_5 = (5, 5)
	Bxh_8 = (8, 8)
	Bxh_10 = (10, 10)
	Bxh_Not4 = (4, 4)

	Ab_0  = (0, 1)
	Ab_2  = (2, 3)
	Ab_3  = (3, 4)
	Ab_4  = (4, 5)
	Ab_5  = (5, 6)
	Ab_6  = (6, 7)
	Ab_7  = (7, 8)
	Ab_8  = (8, 9)
	Ab_10 = (10, 11)
	Ab_11 = (11, 12)

	Abl_0  = (0, 1)
	Abl_2  = (2, 3)
	Abl_3  = (3, 4)
	Abl_4  = (4, 5)
	Abl_10 = (10, 11)

	Abh_2  = (2, 3)
	Abh_3  = (3, 4)
	Abh_4  = (4, 5)
	Abh_8  = (8, 9)
	Abh_10 = (10, 11)

	Abe_0  = (0, 1)
	Abe_1  = (1, 2)

	Ablh_9  = (9, 11)
	Ablh_10 = (10, 12)

	cond_0 = (0, 3)

	R0123457y0_9  = (9, 11)
	R0123457y0_10 = (10, 12)

	Rn_0 = (0, 2)

	R01_0 = (0, 0)
	R01_2 = (2, 2)
	R01_3 = (3, 3)
	R01_4 = (4, 4)
	R01_5 = (5, 5)
	R01_8 = (8, 8)
	R01_9 = (9, 9)

	R04_1 = (1, 1)
	R04_3 = (3, 3)
	R04_4 = (4, 4)
	R04_8 = (8, 8)

	R45_0 = (0, 0)
	R45_2 = (2, 2)
	R45_3 = (3, 3)
	R45_4 = (4, 4)
	R45_5 = (5, 5)
	R45_8 = (8, 8)
	R45_9 = (9, 9)

	R0123_0  = (0, 1)
	R0123_4  = (4, 5)
	R0123_5  = (5, 6)
	R0123_8  = (8, 9)
	R0123_10 = (10, 11)

	R0425_0  = (0, 1)
	R0425_2  = (2, 3)
	R0425_3  = (3, 4)
	R0425_4  = (4, 5)
	R0425_7  = (7, 8)
	R0425_8  = (8, 9)
	R0425_10 = (10, 11)

	R4567_4  = (4, 5)
	R4567_5  = (5, 6)
	R4567_8  = (8, 9)
	R4567_10 = (10, 11)

	ArArpSttMod_0 = (0, 3)
	ArArpSttMod_8 = (8, 11)

	ArArp_0 = (0, 2)
	ArArp_8 = (8, 10)
	SttMod_0 = (0, 2)
	SttMod_8 = (8, 10)

	Ar_0 = (0, 0)
	Ar_2 = (2, 2)

	Arp_0 = (0, 1)

	BankFlags_cfgi = (0, 0)
	BankFlags_r4 = (1, 1)
	BankFlags_r1 = (2, 2)
	BankFlags_r0 = (3, 3)
	BankFlags_r7 = (4, 4)
	BankFlags_cfgj = (5, 5)

	SwapTypes_0 = (0, 3)

	address18_2bits_0 = (0, 1)
	address18_2bits_4 = (4, 5)
	address18_2bits_5 = (5, 6)

	stepZIDS_0 = (0, 1)
	stepZIDS_3 = (3, 4)
	stepZIDS_5 = (5, 6)
	stepZIDS_7 = (7, 8)

	stepII2_0 = (0, 0)
	stepII2_1 = (1, 1)
	stepII2_2 = (2, 2)
	stepII2_3 = (3, 3)
	stepII2_4 = (4, 4)
	stepII2_5 = (5, 5)
	stepII2_6 = (6, 6)
	stepII2_8 = (8, 8)
	stepII2_9 = (9, 9)

	modrstepII2D2S0_0 = (0, 1)
	modrstepII2D2S0_1 = (1, 2)
	modrstepII2D2S0_3 = (3, 4)
	modrstepII2D2S0_5 = (5, 6)

	offsZI_0 = (0, 0)
	offsZI_1 = (1, 1)
	offsZI_2 = (2, 2)
	offsZI_3 = (3, 3)
	offsZI_4 = (4, 4)
	offsZI_6 = (6, 6)
	offsZI_8 = (8, 8)
	offsZI_9 = (9, 9)

	offsZIDZ_0 = (0, 1)
	offsZIDZ_2 = (2, 3)
	offsZIDZ_5 = (5, 6)

	stepII2D2S_0 = (0, 1)
	stepII2D2S_2 = (2, 3)
	stepII2D2S_5 = (5, 6)
	stepII2D2S_8 = (8, 9)

	stepD2S_3 = (3, 3)

	step_Rn_0 = (2, 2)
;

define token expanded (16)
	expanded_imm = (0, 15)
	expanded_imm4_16 = (0, 3)
	expanded_unused_20_31 = (4, 15)
;

# http://problemkaputt.de/gbatek.htm#dsiteakliteiioperandencoding

attach variables [ Ax_0 Ax_1 Ax_3 Ax_4 Ax_5 Ax_6 Ax_8 Ax_10 Ax_11 Ax_12 ] [ a0 a1 ];
attach variables [ Ax_Not0 Ax_Not8 Ax_Not12 ] [ a1 a0 ];

attach variables [ Axl_0 Axl_1 Axl_3 Axl_4 Axl_5 Axl_6 Axl_8 Axl_11 Axl_12 ] [ a0l a1l ];
attach variables [ Axl_Not0 Axl_Not3 Axl_Not4 Axl_Not6 Axl_Not8 Axl_Not11 ] [ a1l a0l ];

attach variables [ Axh_0 Axh_1 Axh_3 Axh_4 Axh_6 Axh_8 Axh_9 Axh_11 Axh_12 ] [ a0h a1h ];
attach variables [ Axh_Not0 Axh_Not3 Axh_Not4 Axh_Not6 Axh_Not8 Axh_Not11 ] [ a1h a0h ];

attach variables [ Px_0 Px_1 Px_4 ] [ p0 p1 ];

attach variables [ Bx_0 Bx_1 Bx_2 Bx_3 Bx_4 Bx_5 Bx_8 Bx_10 Bx_12 ] [ b0 b1 ];

attach variables [ Bxl_0 Bxl_1 Bxl_3 Bxl_4 Bxl_5 Bxl_10 ] [ b0l b1l ];
attach variables [ Bxl_Not4 ] [ b1l b0l ];

attach variables [ Bxh_0 Bxh_1 Bxh_2 Bxh_3 Bxh_4 Bxh_5 Bxh_8 Bxh_10 ] [ b0h b1h ];
attach variables [ Bxh_Not4 ] [ b1h b0h ];

attach variables [ Ab_0 Ab_2 Ab_3 Ab_4 Ab_5 Ab_6 Ab_7 Ab_8 Ab_10 Ab_11 ] [ b0 b1 a0 a1 ];
attach variables [ Abl_0 Abl_2 Abl_3 Abl_4 Abl_10 ] [ b0l b1l a0l a1l ];
attach variables [ Abh_2 Abh_3 Abh_4 Abh_8 Abh_10 ] [ b0h b1h a0h a1h ];
attach variables [ Abe_0 Abe_1 ] [ b0e b1e a0e a1e ];
attach variables [ Ablh_9 Ablh_10 ] [ b0l b0h b1l b1h a0l a0h a1l a1h ];

attach variables [ R0123457y0_9 R0123457y0_10 ] [ r0 r1 r2 r3 r4 r5 r7 y0 ];
attach variables [ Rn_0 ] [ r0 r1 r2 r3 r4 r5 r6 r7 ];

attach variables [ R01_0 R01_2 R01_3 R01_4 R01_5 R01_8 R01_9 ] [ r0 r1 ];
attach variables [ R04_1 R04_3 R04_4 R04_8 ] [ r0 r4 ];
attach variables [ R45_0 R45_2 R45_3 R45_4 R45_5 R45_8 R45_9 ] [ r4 r5 ];
attach variables [ R0123_0 R0123_4 R0123_5 R0123_8 R0123_10 ] [ r0 r1 r2 r3 ];
attach variables [ R0425_0 R0425_2 R0425_3 R0425_4 R0425_7 R0425_8 R0425_10 ] [ r0 r4 r2 r5 ];
attach variables [ R4567_4 R4567_5 R4567_8 R4567_10 ] [ r4 r5 r6 r7 ];

@ifdef TEAK_LITE_2
attach variables [ ArArpSttMod_0 ArArpSttMod_8 ] [
	ar0 ar1
	arp0 arp1 arp2 arp3
	_ _
	stt0 stt1 stt2 _
	mod0 mod1 mod2 mod3
];
@endif

attach variables [ ArArp_0 ArArp_8 ] [ ar0 ar1 arp0 arp1 arp2 arp3 _ _ ];
attach variables [ SttMod_0 SttMod_8 ] [ stt0 stt1 stt2 _ mod0 mod1 mod2 mod3 ];
attach variables [ Ar_0 Ar_2 ] [ ar0 ar1 ];
attach variables [ Arp_0 ] [ arp0 arp1 arp2 arp3 ];

# TODO: Nocash explicitly says it's unclear whether opcodes that use Rn_0 use
# stepi or stepj in all cases, or if they use stepi for r0-r3 and stepj for r4-r7.
# So unlike the others, there's a chance that this actually is implemented like this:
# attach variables [ step_Rn_0 ] [ stepi stepj ];
# For now I've just used stepi in both cases though.
# See http://problemkaputt.de/gbatek-dsi-teaklite-ii-operand-encoding.htm
attach variables [ step_Rn_0 ] [ stepi stepi ];

attach values [ stepII2_0 stepII2_1 stepII2_2 stepII2_3 stepII2_4 stepII2_5 stepII2_6 stepII2_8 stepII2_9 ] [ 1 2 ]; # Increment either once or twice

# Operands can only appear in the display section once, or else the errors
# "Duplicate symbol name" and "Redefining operand" will appear. Unfortunately,
# we have actual duplicate symbols because many instructions are horrible messes.
# This can be worked around either by providing copies of the operands in the token
# section, or by creating tables for those copies. Tables are nicer because then
# there's no need to worry about forgetting to attach variables to the copy.
# These should not appear in the semantic section.
Abl_2_copy:Abl_2 is Abl_2 {}
Abh_4_copy:Abh_4 is Abh_4 {}
sv_copy:sv is sv {}
sv_copy_2:sv is sv {}
Axh_4_copy:Axh_4 is Axh_4 {}
Axh_6_copy:Axh_6 is Axh_6 {}

# Always
# Excluded because this makes analysis messy - instead specialize every instruction that uses conditions
#Cond_0:"true" is cond_0=0x0 { local always:1 = 1; export always; }
# Equal to zero             (Z=1)
Cond_0:"eq"   is cond_0=0x1 { local c:1 = $(FLAG_Z); export c; }
# Not equal to zero         (Z=0)
Cond_0:"neq"  is cond_0=0x2 { local c:1 = !$(FLAG_Z); export c; }
# Greater than zero         (M=0 and Z=0)
Cond_0:"gt"   is cond_0=0x3 { local c:1 = !$(FLAG_M) && !$(FLAG_Z); export c; }
# Greater or equal to zero  (M=0)
Cond_0:"ge"   is cond_0=0x4 { local c:1 = !$(FLAG_M); export c; }
# Less than zero            (M=1)
Cond_0:"lt"   is cond_0=0x5 { local c:1 = $(FLAG_M); export c; }
# Less or equal to zero     (M=1 or Z=1)
Cond_0:"le"   is cond_0=0x6 { local c:1 = $(FLAG_M) || $(FLAG_Z); export c; }
# Normalize flag is cleared (N=0)
Cond_0:"nn"   is cond_0=0x7 { local c:1 = !$(FLAG_N); export c; }
# Carry flag is set         (C=1)
Cond_0:"c"    is cond_0=0x8 { local c:1 = $(FLAG_C); export c; }
# Overflow flag is set      (V=1)
Cond_0:"v"    is cond_0=0x9 { local c:1 = $(FLAG_V); export c; }
# Extension flag is set     (E=1)
Cond_0:"e"    is cond_0=0xa { local c:1 = $(FLAG_E); export c; }
# Limit flag is set         (L=1)
Cond_0:"l"    is cond_0=0xb { local c:1 = $(FLAG_L); export c; }
# R flag is cleared         (R=0)
Cond_0:"nr"   is cond_0=0xc { local c:1 = !$(FLAG_R); export c; }
# Input user pin 0 cleared  (IUSER0=0)
define pcodeop read_user_input_0;
Cond_0:"niu0" is cond_0=0xd { local in:1 = read_user_input_0(); local c:1 = !in; export c; }
# Input user pin 0 set      (IUSER0=1)
Cond_0:"iu0"  is cond_0=0xe { local c:1 = read_user_input_0(); export c; }
define pcodeop read_user_input_1;
# Input user pin 1 set      (IUSER1=1)
Cond_0:"iu1"  is cond_0=0xf { local c:1 = read_user_input_1(); export c; }

MemRn_0:$(OB)Rn_0$(CB) is Rn_0 { export *[data]:2 Rn_0; }
MemSp:$(OB)sp$(CB) is sp { export *[data]:2 sp; }

@ifdef NOCASH_SYNTAX
ProgMemRn_0:[^"code:movpd":Rn_0] is Rn_0
@else
ProgMemRn_0:(Rn_0) is Rn_0
@endif
{
	# TODO: this uses the same upper bits as pcmhi
	export *[code]:2 Rn_0;
}

@ifdef NOCASH_SYNTAX
ProgMemAxl_5:[^"code:movpd":Axl_5] is Axl_5
@else
ProgMemAxl_5:(Axl_5) is Axl_5
@endif
{
	# TODO: this uses the same upper bits as pcmhi
	export *[code]:2 Axl_5;
}

@ifdef NOCASH_SYNTAX
ProgMemAx_5:[^"code:movpd":Ax_5] is Ax_5
@else
ProgMemAx_5:(Ax_5) is Ax_5
@endif
{
	# This does not experience saturation
	local address:5 = Ax_5 & 0x3FFFF;
	export *[code]:2 address;
}

@ifdef NOCASH_SYNTAX
ProgMemAx_8:[^"code:movpd":Ax_8] is Ax_8
@else
ProgMemAx_8:(Ax_8) is Ax_8
@endif
{
	# This does not experience saturation
	local address:5 = Ax_8 & 0x3FFFF;
	export *[code]:2 address;
}

# offsI doesn't seem to be configurable
@ifdef NOCASH_SYNTAX
ProgMemAx_8_offsI:[^"code:movpd":Ax_8+] is Ax_8
@else
ProgMemAx_8_offsI:(Ax_8+) is Ax_8
@endif
{
	# This does not experience saturation
	local address:5 = (Ax_8 + 1) & 0x3FFFF;
	export *[code]:2 address;
}

@ifdef NOCASH_SYNTAX
ProgMemR45_2:[^"code:movpd":R45_2] is R45_2
@else
ProgMemR45_2:(R45_2) is R45_2
@endif
{
	# TODO: this uses the same upper bits as pcmhi
	export *[code]:2 R45_2;
}


@ifdef NOCASH_SYNTAX
MemImm8_0:[^"page":imm8_0] is imm8_0
@else
MemImm8_0:imm8_0 is imm8_0
@endif
{
	# TODO: handle page
	addr:2 = imm8_0;
	export *[data]:2 addr;
}

@ifdef NOCASH_SYNTAX
MemImm16:[expanded_imm] is expanded_imm
@else
MemImm16:[##expanded_imm] is expanded_imm
@endif
{
	export *[data]:2 expanded_imm;
}

@ifdef NOCASH_SYNTAX
MemR7Imm7s_0:[r7+imm7s_0] is r7 & imm7s_0
@else
MemR7Imm7s_0:(r7+#imm7s_0) is r7 & imm7s_0
@endif
{
	addr:2 = r7 + imm7s_0;
	export *[data]:2 addr;
}

@ifdef NOCASH_SYNTAX
MemR7Imm16:[r7+expanded_imm] is expanded_imm & r7
@else
MemR7Imm16:(r7+##expanded_imm) is expanded_imm & r7
@endif
{
	addr:2 = r7 + expanded_imm;
	export *[data]:2 addr;
}

# TODO: is this the intended way for this to be displayed?
Imm4bitno_8:shifted_bit is imm4_8 [ shifted_bit = 1 << imm4_8; ] { export *[data]:2 shifted_bit; }
Imm4bitno_16:shifted_bit is expanded_imm4_16 [ shifted_bit = 1 << expanded_imm4_16; ] { export *[data]:2 shifted_bit; }

CodeAddress18_16and0:full_addr is address18_2bits_0; expanded_imm
[ full_addr = (address18_2bits_0 << 16) + expanded_imm; ]
{
	export *[code]:2 full_addr;
}
CodeAddress18_16and4:full_addr is address18_2bits_4; expanded_imm
[ full_addr = (address18_2bits_4 << 16) + expanded_imm; ]
{
	export *[code]:2 full_addr;
}
CodeAddress18_16and5:full_addr is address18_2bits_5; expanded_imm
[ full_addr = (address18_2bits_5 << 16) + expanded_imm; ]
{
	export *[code]:2 full_addr;
}

CodeAddress18_16and0After:full_addr is address18_2bits_0; expanded_imm
[ full_addr = (address18_2bits_0 << 16) + expanded_imm + 1; ]
{
	export *[code]:2 full_addr;
}

CodeAddress18_16and5After:full_addr is address18_2bits_5; expanded_imm
[ full_addr = (address18_2bits_5 << 16) + expanded_imm + 1; ]
{
	export *[code]:2 full_addr;
}

CodeAddress16:expanded_imm is expanded_imm
{
	export *[code]:2 expanded_imm;
}

CodeAddress16After:new_imm is expanded_imm [ new_imm = expanded_imm + 1; ]
{
	export *[code]:2 new_imm;
}

RelCodeAddr7_4:full_addr is imm7s_4
[ full_addr = inst_next + imm7s_4; ]  # TODO: inst_next or inst_start?
{
	export *[code]:2 full_addr;  # TODO: do we want to dereference this?
}

MemR0:$(OB)r0$(CB) is r0 { export *[data]:2 r0; }

# Notepad++ regexes for these:
# ^MemR(\d+)@(\d+)$
# MemR\1_\2:        $\(OB\)R\1_\2$\(CB\)  is R\1_\2              { export *[data]:2 R\1_\2; }
# ^MemR(\d+)@(\d+)offsZI@(\d+)$
# MemR\1_\2_offsZI_\3:$\(OB\)R\1_\2$\(CB\)  is R\1_\2 & offsZI_\3=0 { export *[data]:2 R\1_\2; }\r\nMemR\1_\2_offsZI_\3:$\(OB\)R\1_\2+$\(CB\) is R\1_\2 & offsZI_\3=1 { addr = R\1_\2 + 1; export *[data]:2 addr; }

MemR01_0:         $(OB)R01_0$(CB)  is R01_0              { export *[data]:2 R01_0; }
MemR01_0_offsZI_8:$(OB)R01_0$(CB)  is R01_0 & offsZI_8=0 { export *[data]:2 R01_0; }
MemR01_0_offsZI_8:$(OB)R01_0+$(CB) is R01_0 & offsZI_8=1 { addr = R01_0 + 1; export *[data]:2 addr; }
MemR01_2:         $(OB)R01_2$(CB)  is R01_2              { export *[data]:2 R01_2; }
MemR01_2_offsZI_0:$(OB)R01_2$(CB)  is R01_2 & offsZI_0=0 { export *[data]:2 R01_2; }
MemR01_2_offsZI_0:$(OB)R01_2+$(CB) is R01_2 & offsZI_0=1 { addr = R01_2 + 1; export *[data]:2 addr; }
MemR01_3:         $(OB)R01_3$(CB)  is R01_3              { export *[data]:2 R01_3; }
MemR01_3_offsZI_1:$(OB)R01_3$(CB)  is R01_3 & offsZI_1=0 { export *[data]:2 R01_3; }
MemR01_3_offsZI_1:$(OB)R01_3+$(CB) is R01_3 & offsZI_1=1 { addr = R01_3 + 1; export *[data]:2 addr; }
MemR01_4:         $(OB)R01_4$(CB)  is R01_4              { export *[data]:2 R01_4; }
MemR01_4_offsZI_2:$(OB)R01_4$(CB)  is R01_4 & offsZI_2=0 { export *[data]:2 R01_4; }
MemR01_4_offsZI_2:$(OB)R01_4+$(CB) is R01_4 & offsZI_2=1 { addr = R01_4 + 1; export *[data]:2 addr; }
MemR01_5:         $(OB)R01_5$(CB)  is R01_5              { export *[data]:2 R01_5; }
MemR01_5_offsZI_3:$(OB)R01_5$(CB)  is R01_5 & offsZI_3=0 { export *[data]:2 R01_5; }
MemR01_5_offsZI_3:$(OB)R01_5+$(CB) is R01_5 & offsZI_3=1 { addr = R01_5 + 1; export *[data]:2 addr; }
MemR01_8:         $(OB)R01_8$(CB)  is R01_8              { export *[data]:2 R01_8; }
MemR01_8_offsZI_0:$(OB)R01_8$(CB)  is R01_8 & offsZI_0=0 { export *[data]:2 R01_8; }
MemR01_8_offsZI_0:$(OB)R01_8+$(CB) is R01_8 & offsZI_0=1 { addr = R01_8 + 1; export *[data]:2 addr; }
MemR01_9:         $(OB)R01_9$(CB)  is R01_9              { export *[data]:2 R01_9; }
# no offsZI variant exists for MemR01_9

MemR45_0:         $(OB)R45_0$(CB)  is R45_0              { export *[data]:2 R45_0; }
MemR45_0_offsZI_9:$(OB)R45_0$(CB)  is R45_0 & offsZI_9=0 { export *[data]:2 R45_0; }
MemR45_0_offsZI_9:$(OB)R45_0+$(CB) is R45_0 & offsZI_9=1 { addr = R45_0 + 1; export *[data]:2 addr; }
MemR45_2:         $(OB)R45_2$(CB)  is R45_2              { export *[data]:2 R45_2; }
MemR45_2_offsZI_1:$(OB)R45_2$(CB)  is R45_2 & offsZI_1=0 { export *[data]:2 R45_2; }
MemR45_2_offsZI_1:$(OB)R45_2+$(CB) is R45_2 & offsZI_1=1 { addr = R45_2 + 1; export *[data]:2 addr; }
MemR45_3:         $(OB)R45_3$(CB)  is R45_3              { export *[data]:2 R45_3; }
MemR45_3_offsZI_2:$(OB)R45_3$(CB)  is R45_3 & offsZI_2=0 { export *[data]:2 R45_3; }
MemR45_3_offsZI_2:$(OB)R45_3+$(CB) is R45_3 & offsZI_2=1 { addr = R45_3 + 1; export *[data]:2 addr; }
MemR45_4:         $(OB)R45_4$(CB)  is R45_4              { export *[data]:2 R45_4; }
MemR45_4_offsZI_3:$(OB)R45_4$(CB)  is R45_4 & offsZI_3=0 { export *[data]:2 R45_4; }
MemR45_4_offsZI_3:$(OB)R45_4+$(CB) is R45_4 & offsZI_3=1 { addr = R45_4 + 1; export *[data]:2 addr; }
MemR45_5:         $(OB)R45_5$(CB)  is R45_5              { export *[data]:2 R45_5; }
MemR45_5_offsZI_4:$(OB)R45_5$(CB)  is R45_5 & offsZI_4=0 { export *[data]:2 R45_5; }
MemR45_5_offsZI_4:$(OB)R45_5+$(CB) is R45_5 & offsZI_4=1 { addr = R45_5 + 1; export *[data]:2 addr; }
MemR45_8:         $(OB)R45_8$(CB)  is R45_8              { export *[data]:2 R45_8; }
MemR45_8_offsZI_1:$(OB)R45_8$(CB)  is R45_8 & offsZI_1=0 { export *[data]:2 R45_8; }
MemR45_8_offsZI_1:$(OB)R45_8+$(CB) is R45_8 & offsZI_1=1 { addr = R45_8 + 1; export *[data]:2 addr; }
MemR45_9:         $(OB)R45_9$(CB)  is R45_9              { export *[data]:2 R45_9; }
# no offsZI variant exists for MemR45_9

MemR04_1:         $(OB)R04_1$(CB)  is R04_1              { export *[data]:2 R04_1; }
MemR04_1_copy:    $(OB)R04_1$(CB)  is R04_1              { export *[data]:2 R04_1; }
MemR04_1_offsZI_0:$(OB)R04_1$(CB)  is R04_1 & offsZI_0=0 { export *[data]:2 R04_1; }
MemR04_1_offsZI_0:$(OB)R04_1+$(CB) is R04_1 & offsZI_0=1 { addr = R04_1 + 1; export *[data]:2 addr; }
MemR04_3:         $(OB)R04_3$(CB)  is R04_3              { export *[data]:2 R04_3; }
MemR04_3_copy:    $(OB)R04_3$(CB)  is R04_3              { export *[data]:2 R04_3; }
MemR04_3_offsZI_2:$(OB)R04_3$(CB)  is R04_3 & offsZI_2=0 { export *[data]:2 R04_3; }
MemR04_3_offsZI_2:$(OB)R04_3+$(CB) is R04_3 & offsZI_2=1 { addr = R04_3 + 1; export *[data]:2 addr; }
MemR04_4:         $(OB)R04_4$(CB)  is R04_4              { export *[data]:2 R04_4; }
MemR04_4_copy:    $(OB)R04_4$(CB)  is R04_4              { export *[data]:2 R04_4; }
MemR04_4_offsZI_3:$(OB)R04_4$(CB)  is R04_4 & offsZI_3=0 { export *[data]:2 R04_4; }
MemR04_4_offsZI_3:$(OB)R04_4+$(CB) is R04_4 & offsZI_3=1 { addr = R04_4 + 1; export *[data]:2 addr; }
MemR04_8:         $(OB)R04_8$(CB)  is R04_8              { export *[data]:2 R04_8; }
MemR04_8_copy:    $(OB)R04_8$(CB)  is R04_8              { export *[data]:2 R04_8; }
# no offsZI variant exists for MemR04_8

MemR0123_0:  $(OB)R0123_0$(CB)  is R0123_0  { export *[data]:2 R0123_0; }
MemR0123_4:  $(OB)R0123_4$(CB)  is R0123_4  { export *[data]:2 R0123_4; }
MemR0123_5:  $(OB)R0123_5$(CB)  is R0123_5  { export *[data]:2 R0123_5; }
MemR0123_8:  $(OB)R0123_8$(CB)  is R0123_8  { export *[data]:2 R0123_8; }
MemR0123_10: $(OB)R0123_10$(CB) is R0123_10 { export *[data]:2 R0123_10; }  # Only used by MemR0123_10_modrstepII2D2S0_1

# TODO: do we want to do something special with the brackets here? Right now it'd be [r0]+2 and maybe [r0+2] or just r0+2 would make more sense
# TODO: stepi0 or stepj0?
MemR0123_5_modrstepII2D2S0_1:MemR0123_5+       is MemR0123_5 & modrstepII2D2S0_1=0 & R0123_5          { R0123_5 = R0123_5 + 1; }
MemR0123_5_modrstepII2D2S0_1:MemR0123_5+2      is MemR0123_5 & modrstepII2D2S0_1=1 & R0123_5          { R0123_5 = R0123_5 + 2; }
MemR0123_5_modrstepII2D2S0_1:MemR0123_5-2      is MemR0123_5 & modrstepII2D2S0_1=2 & R0123_5          { R0123_5 = R0123_5 - 2; }
MemR0123_5_modrstepII2D2S0_1:MemR0123_5+stepi0 is MemR0123_5 & modrstepII2D2S0_1=3 & R0123_5 & stepi0 { R0123_5 = R0123_5 + stepi0; }

MemR0123_8_modrstepII2D2S0_0:MemR0123_8+       is MemR0123_8 & modrstepII2D2S0_0=0 & R0123_8          { R0123_8 = R0123_8 + 1; }
MemR0123_8_modrstepII2D2S0_0:MemR0123_8+2      is MemR0123_8 & modrstepII2D2S0_0=1 & R0123_8          { R0123_8 = R0123_8 + 2; }
MemR0123_8_modrstepII2D2S0_0:MemR0123_8-2      is MemR0123_8 & modrstepII2D2S0_0=2 & R0123_8          { R0123_8 = R0123_8 - 2; }
MemR0123_8_modrstepII2D2S0_0:MemR0123_8+stepi0 is MemR0123_8 & modrstepII2D2S0_0=3 & R0123_8 & stepi0 { R0123_8 = R0123_8 + stepi0; }

MemR0123_10_modrstepII2D2S0_0:MemR0123_10+       is MemR0123_10 & modrstepII2D2S0_0=0 & R0123_10          { R0123_10 = R0123_10 + 1; }
MemR0123_10_modrstepII2D2S0_0:MemR0123_10+2      is MemR0123_10 & modrstepII2D2S0_0=1 & R0123_10          { R0123_10 = R0123_10 + 2; }
MemR0123_10_modrstepII2D2S0_0:MemR0123_10-2      is MemR0123_10 & modrstepII2D2S0_0=2 & R0123_10          { R0123_10 = R0123_10 - 2; }
MemR0123_10_modrstepII2D2S0_0:MemR0123_10+stepi0 is MemR0123_10 & modrstepII2D2S0_0=3 & R0123_10 & stepi0 { R0123_10 = R0123_10 + stepi0; }

# Note: offsZIDZ has two instances of zero, but they are always paired with a stepII2D2S using the same bits which disambiguates
MemR0123_4_offsZIDZ_0:$(OB)R0123_4$(CB)  is R0123_4 & offsZIDZ_0=0 { export *[data]:2 R0123_4; }
MemR0123_4_offsZIDZ_0:$(OB)R0123_4+$(CB) is R0123_4 & offsZIDZ_0=1 { addr = R0123_4 + 1; export *[data]:2 addr; }
MemR0123_4_offsZIDZ_0:$(OB)R0123_4-$(CB) is R0123_4 & offsZIDZ_0=2 { addr = R0123_4 - 1; export *[data]:2 addr; }
MemR0123_4_offsZIDZ_0:$(OB)R0123_4$(CB)  is R0123_4 & offsZIDZ_0=3 { export *[data]:2 R0123_4; }

# TODO: stepi/stepj?
R0123_4_stepII2D2S_0:R0123_4+1      is R0123_4 & stepII2D2S_0=0          { R0123_4 = R0123_4 + 1; }
R0123_4_stepII2D2S_0:R0123_4+2      is R0123_4 & stepII2D2S_0=1          { R0123_4 = R0123_4 + 2; }
R0123_4_stepII2D2S_0:R0123_4-2      is R0123_4 & stepII2D2S_0=2          { R0123_4 = R0123_4 - 2; }
R0123_4_stepII2D2S_0:R0123_4+stepi0 is R0123_4 & stepII2D2S_0=3 & stepi0 { R0123_4 = R0123_4 + stepi0; }

R0123_8_stepII2D2S_0:R0123_8+1      is R0123_8 & stepII2D2S_0=0          { R0123_8 = R0123_8 + 1; }
R0123_8_stepII2D2S_0:R0123_8+2      is R0123_8 & stepII2D2S_0=1          { R0123_8 = R0123_8 + 2; }
R0123_8_stepII2D2S_0:R0123_8-2      is R0123_8 & stepII2D2S_0=2          { R0123_8 = R0123_8 - 2; }
R0123_8_stepII2D2S_0:R0123_8+stepi0 is R0123_8 & stepII2D2S_0=3 & stepi0 { R0123_8 = R0123_8 + stepi0; }

MemR0425_0:  $(OB)R0425_0$(CB)  is R0425_0  { export *[data]:2 R0425_0; }
MemR0425_2:  $(OB)R0425_2$(CB)  is R0425_2  { export *[data]:2 R0425_2; }
MemR0425_3:  $(OB)R0425_3$(CB)  is R0425_3  { export *[data]:2 R0425_3; }
MemR0425_4:  $(OB)R0425_4$(CB)  is R0425_4  { export *[data]:2 R0425_4; }
MemR0425_7:  $(OB)R0425_7$(CB)  is R0425_7  { export *[data]:2 R0425_7; }
MemR0425_8:  $(OB)R0425_8$(CB)  is R0425_8  { export *[data]:2 R0425_8; }
MemR0425_10: $(OB)R0425_10$(CB) is R0425_10 { export *[data]:2 R0425_10; }

# Note: offsZIDZ has two instances of zero, but they are always paired with a stepII2D2S using the same bits which disambiguates
MemR0425_2_offsZIDZ_0: $(OB)R0425_2$(CB)  is R0425_2 & offsZIDZ_0=0 { export *[data]:2 R0425_2; }
MemR0425_2_offsZIDZ_0: $(OB)R0425_2+$(CB) is R0425_2 & offsZIDZ_0=1 { addr = R0425_2 + 1; export *[data]:2 addr; }
MemR0425_2_offsZIDZ_0: $(OB)R0425_2-$(CB) is R0425_2 & offsZIDZ_0=2 { addr = R0425_2 - 1; export *[data]:2 addr; }
MemR0425_2_offsZIDZ_0: $(OB)R0425_2$(CB)  is R0425_2 & offsZIDZ_0=3 { export *[data]:2 R0425_2; }

MemR0425_4_offsZIDZ_2: $(OB)R0425_4$(CB)  is R0425_4 & offsZIDZ_2=0 { export *[data]:2 R0425_4; }
MemR0425_4_offsZIDZ_2: $(OB)R0425_4+$(CB) is R0425_4 & offsZIDZ_2=1 { addr = R0425_4 + 1; export *[data]:2 addr; }
MemR0425_4_offsZIDZ_2: $(OB)R0425_4-$(CB) is R0425_4 & offsZIDZ_2=2 { addr = R0425_4 - 1; export *[data]:2 addr; }
MemR0425_4_offsZIDZ_2: $(OB)R0425_4$(CB)  is R0425_4 & offsZIDZ_2=3 { export *[data]:2 R0425_4; }

MemR0425_8_offsZIDZ_2: $(OB)R0425_8$(CB)  is R0425_8 & offsZIDZ_2=0 { export *[data]:2 R0425_8; }
MemR0425_8_offsZIDZ_2: $(OB)R0425_8+$(CB) is R0425_8 & offsZIDZ_2=1 { addr = R0425_8 + 1; export *[data]:2 addr; }
MemR0425_8_offsZIDZ_2: $(OB)R0425_8-$(CB) is R0425_8 & offsZIDZ_2=2 { addr = R0425_8 - 1; export *[data]:2 addr; }
MemR0425_8_offsZIDZ_2: $(OB)R0425_8$(CB)  is R0425_8 & offsZIDZ_2=3 { export *[data]:2 R0425_8; }

MemR0425_10_offsZIDZ_5: $(OB)R0425_10$(CB)  is R0425_10 & offsZIDZ_5=0 { export *[data]:2 R0425_10; }
MemR0425_10_offsZIDZ_5: $(OB)R0425_10+$(CB) is R0425_10 & offsZIDZ_5=1 { addr = R0425_10 + 1; export *[data]:2 addr; }
MemR0425_10_offsZIDZ_5: $(OB)R0425_10-$(CB) is R0425_10 & offsZIDZ_5=2 { addr = R0425_10 - 1; export *[data]:2 addr; }
MemR0425_10_offsZIDZ_5: $(OB)R0425_10$(CB)  is R0425_10 & offsZIDZ_5=3 { export *[data]:2 R0425_10; }

# TODO: stepi/stepj?
R0425_2_stepII2D2S_0:R0425_2+1      is R0425_2 & stepII2D2S_0=0          { R0425_2 = R0425_2 + 1; }
R0425_2_stepII2D2S_0:R0425_2+2      is R0425_2 & stepII2D2S_0=1          { R0425_2 = R0425_2 + 2; }
R0425_2_stepII2D2S_0:R0425_2-2      is R0425_2 & stepII2D2S_0=2          { R0425_2 = R0425_2 - 2; }
R0425_2_stepII2D2S_0:R0425_2+stepi0 is R0425_2 & stepII2D2S_0=3 & stepi0 { R0425_2 = R0425_2 + stepi0; }

R0425_3_stepII2D2S_0:R0425_3+1      is R0425_3 & stepII2D2S_0=0          { R0425_3 = R0425_3 + 1; }
R0425_3_stepII2D2S_0:R0425_3+2      is R0425_3 & stepII2D2S_0=1          { R0425_3 = R0425_3 + 2; }
R0425_3_stepII2D2S_0:R0425_3-2      is R0425_3 & stepII2D2S_0=2          { R0425_3 = R0425_3 - 2; }
R0425_3_stepII2D2S_0:R0425_3+stepi0 is R0425_3 & stepII2D2S_0=3 & stepi0 { R0425_3 = R0425_3 + stepi0; }

R0425_4_stepII2D2S_2:R0425_4+1      is R0425_4 & stepII2D2S_2=0          { R0425_4 = R0425_4 + 1; }
R0425_4_stepII2D2S_2:R0425_4+2      is R0425_4 & stepII2D2S_2=1          { R0425_4 = R0425_4 + 2; }
R0425_4_stepII2D2S_2:R0425_4-2      is R0425_4 & stepII2D2S_2=2          { R0425_4 = R0425_4 - 2; }
R0425_4_stepII2D2S_2:R0425_4+stepi0 is R0425_4 & stepII2D2S_2=3 & stepi0 { R0425_4 = R0425_4 + stepi0; }

R0425_8_stepII2D2S_2:R0425_8+1      is R0425_8 & stepII2D2S_2=0          { R0425_8 = R0425_8 + 1; }
R0425_8_stepII2D2S_2:R0425_8+2      is R0425_8 & stepII2D2S_2=1          { R0425_8 = R0425_8 + 2; }
R0425_8_stepII2D2S_2:R0425_8-2      is R0425_8 & stepII2D2S_2=2          { R0425_8 = R0425_8 - 2; }
R0425_8_stepII2D2S_2:R0425_8+stepi0 is R0425_8 & stepII2D2S_2=3 & stepi0 { R0425_8 = R0425_8 + stepi0; }

R0425_10_stepII2D2S_5:R0425_10+1      is R0425_10 & stepII2D2S_5=0          { R0425_10 = R0425_10 + 1; }
R0425_10_stepII2D2S_5:R0425_10+2      is R0425_10 & stepII2D2S_5=1          { R0425_10 = R0425_10 + 2; }
R0425_10_stepII2D2S_5:R0425_10-2      is R0425_10 & stepII2D2S_5=2          { R0425_10 = R0425_10 - 2; }
R0425_10_stepII2D2S_5:R0425_10+stepi0 is R0425_10 & stepII2D2S_5=3 & stepi0 { R0425_10 = R0425_10 + stepi0; }

R0425_10_stepII2D2S_8:R0425_10+1      is R0425_10 & stepII2D2S_8=0          { R0425_10 = R0425_10 + 1; }
R0425_10_stepII2D2S_8:R0425_10+2      is R0425_10 & stepII2D2S_8=1          { R0425_10 = R0425_10 + 2; }
R0425_10_stepII2D2S_8:R0425_10-2      is R0425_10 & stepII2D2S_8=2          { R0425_10 = R0425_10 - 2; }
R0425_10_stepII2D2S_8:R0425_10+stepi0 is R0425_10 & stepII2D2S_8=3 & stepi0 { R0425_10 = R0425_10 + stepi0; }

MemR4567_4:  $(OB)R4567_4$(CB)  is R4567_4  { export *[data]:2 R4567_4; }
MemR4567_5:  $(OB)R4567_5$(CB)  is R4567_5  { export *[data]:2 R4567_5; }
MemR4567_8:  $(OB)R4567_8$(CB)  is R4567_8  { export *[data]:2 R4567_8; }
MemR4567_10: $(OB)R4567_10$(CB) is R4567_10 { export *[data]:2 R4567_10; }

# TODO: brackets; stepi0 or stepj0?
MemR4567_5_modrstepII2D2S0_3:MemR4567_5+       is MemR4567_5 & modrstepII2D2S0_3=0 & R4567_5          { R4567_5 = R4567_5 + 1; }
MemR4567_5_modrstepII2D2S0_3:MemR4567_5+2      is MemR4567_5 & modrstepII2D2S0_3=1 & R4567_5          { R4567_5 = R4567_5 + 2; }
MemR4567_5_modrstepII2D2S0_3:MemR4567_5-2      is MemR4567_5 & modrstepII2D2S0_3=2 & R4567_5          { R4567_5 = R4567_5 - 2; }
MemR4567_5_modrstepII2D2S0_3:MemR4567_5+stepj0 is MemR4567_5 & modrstepII2D2S0_3=3 & R4567_5 & stepj0 { R4567_5 = R4567_5 + stepj0; }

MemR4567_8_modrstepII2D2S0_3:MemR4567_8+       is MemR4567_8 & modrstepII2D2S0_3=0 & R4567_8          { R4567_8 = R4567_8 + 1; }
MemR4567_8_modrstepII2D2S0_3:MemR4567_8+2      is MemR4567_8 & modrstepII2D2S0_3=1 & R4567_8          { R4567_8 = R4567_8 + 2; }
MemR4567_8_modrstepII2D2S0_3:MemR4567_8-2      is MemR4567_8 & modrstepII2D2S0_3=2 & R4567_8          { R4567_8 = R4567_8 - 2; }
MemR4567_8_modrstepII2D2S0_3:MemR4567_8+stepj0 is MemR4567_8 & modrstepII2D2S0_3=3 & R4567_8 & stepj0 { R4567_8 = R4567_8 + stepj0; }

MemR4567_10_modrstepII2D2S0_5:MemR4567_10+       is MemR4567_10 & modrstepII2D2S0_5=0 & R4567_10          { R4567_10 = R4567_10 + 1; }
MemR4567_10_modrstepII2D2S0_5:MemR4567_10+2      is MemR4567_10 & modrstepII2D2S0_5=1 & R4567_10          { R4567_10 = R4567_10 + 2; }
MemR4567_10_modrstepII2D2S0_5:MemR4567_10-2      is MemR4567_10 & modrstepII2D2S0_5=2 & R4567_10          { R4567_10 = R4567_10 - 2; }
MemR4567_10_modrstepII2D2S0_5:MemR4567_10+stepj0 is MemR4567_10 & modrstepII2D2S0_5=3 & R4567_10 & stepj0 { R4567_10 = R4567_10 + stepj0; }

# Note: offsZIDZ has two instances of zero, but they are always paired with a stepII2D2S using the same bits which disambiguates
MemR4567_4_offsZIDZ_2:$(OB)R4567_4$(CB)  is R4567_4 & offsZIDZ_2=0 { export *[data]:2 R4567_4; }
MemR4567_4_offsZIDZ_2:$(OB)R4567_4+$(CB) is R4567_4 & offsZIDZ_2=1 { addr = R4567_4 + 1; export *[data]:2 addr; }
MemR4567_4_offsZIDZ_2:$(OB)R4567_4-$(CB) is R4567_4 & offsZIDZ_2=2 { addr = R4567_4 + 1; export *[data]:2 addr; }
MemR4567_4_offsZIDZ_2:$(OB)R4567_4$(CB)  is R4567_4 & offsZIDZ_2=3 { export *[data]:2 R4567_4; }

# TODO: stepi/stepj?
R4567_4_stepII2D2S_2:R4567_4+1      is R4567_4 & stepII2D2S_2=0          { R4567_4 = R4567_4 + 1; }
R4567_4_stepII2D2S_2:R4567_4+2      is R4567_4 & stepII2D2S_2=1          { R4567_4 = R4567_4 + 2; }
R4567_4_stepII2D2S_2:R4567_4-2      is R4567_4 & stepII2D2S_2=2          { R4567_4 = R4567_4 - 2; }
R4567_4_stepII2D2S_2:R4567_4+stepj0 is R4567_4 & stepII2D2S_2=3 & stepj0 { R4567_4 = R4567_4 + stepj0; }

R4567_8_stepII2D2S_2:R4567_8+1      is R4567_8 & stepII2D2S_2=0          { R4567_8 = R4567_8 + 1; }
R4567_8_stepII2D2S_2:R4567_8+2      is R4567_8 & stepII2D2S_2=1          { R4567_8 = R4567_8 + 2; }
R4567_8_stepII2D2S_2:R4567_8-2      is R4567_8 & stepII2D2S_2=2          { R4567_8 = R4567_8 - 2; }
R4567_8_stepII2D2S_2:R4567_8+stepj0 is R4567_8 & stepII2D2S_2=3 & stepj0 { R4567_8 = R4567_8 + stepj0; }

# Note: original formatting for these uses +s for stepZIDS=3;
# I've replaced it with +stepi (or +stepj when applicable).
# Also, when stepZIDS=0, these can be omitted, but doing that is difficult since
# there are cases where there are two of them (for instance,
# movd MemR0123@0,ProgMemR45@2 || R0123@0stepZIDS@3, R45@2stepZIDS@5),
# in which case the comma would need to be handled intelligently. It's easier to
# just always show it.

R0_stepZIDS_0:r0       is stepZIDS_0=0 & r0         {}
R0_stepZIDS_0:r0+1     is stepZIDS_0=1 & r0         { r0 = r0 + 1; }
R0_stepZIDS_0:r0-1     is stepZIDS_0=2 & r0         { r0 = r0 - 1; }
R0_stepZIDS_0:r0+stepi is stepZIDS_0=3 & r0 & stepi { r0 = r0 + stepi; }

R0_stepZIDS_3:r0       is stepZIDS_3=0 & r0         {}
R0_stepZIDS_3:r0+1     is stepZIDS_3=1 & r0         { r0 = r0 + 1; }
R0_stepZIDS_3:r0-1     is stepZIDS_3=2 & r0         { r0 = r0 - 1; }
R0_stepZIDS_3:r0+stepi is stepZIDS_3=3 & r0 & stepi { r0 = r0 + stepi; }

# Note: R0123@0stepZIDS@3 is always combined with R45@2stepZIDS@5, so bits 0-6 are always used (there's no gap).
R0123_0_stepZIDS_3:R0123_0       is stepZIDS_3=0 & R0123_0         {}
R0123_0_stepZIDS_3:R0123_0+1     is stepZIDS_3=1 & R0123_0         { R0123_0 = R0123_0 + 1; }
R0123_0_stepZIDS_3:R0123_0-1     is stepZIDS_3=2 & R0123_0         { R0123_0 = R0123_0 - 1; }
R0123_0_stepZIDS_3:R0123_0+stepi is stepZIDS_3=3 & R0123_0 & stepi { R0123_0 = R0123_0 + stepi; }

R0123_5_stepZIDS_7:R0123_5       is stepZIDS_7=0 & R0123_5         {}
R0123_5_stepZIDS_7:R0123_5+1     is stepZIDS_7=1 & R0123_5         { R0123_5 = R0123_5 + 1; }
R0123_5_stepZIDS_7:R0123_5-1     is stepZIDS_7=2 & R0123_5         { R0123_5 = R0123_5 - 1; }
R0123_5_stepZIDS_7:R0123_5+stepi is stepZIDS_7=3 & R0123_5 & stepi { R0123_5 = R0123_5 + stepi; }

R45_2_stepZIDS_5:R45_2       is stepZIDS_5=0 & R45_2         {}
R45_2_stepZIDS_5:R45_2+1     is stepZIDS_5=1 & R45_2         { R45_2 = R45_2 + 1; }
R45_2_stepZIDS_5:R45_2-1     is stepZIDS_5=2 & R45_2         { R45_2 = R45_2 - 1; }
R45_2_stepZIDS_5:R45_2+stepi is stepZIDS_5=3 & R45_2 & stepi { R45_2 = R45_2 + stepi; }

Rn_0_stepZIDS_3:Rn_0           is stepZIDS_3=0 & Rn_0             {}
Rn_0_stepZIDS_3:Rn_0+1         is stepZIDS_3=1 & Rn_0             { Rn_0 = Rn_0 + 1; }
Rn_0_stepZIDS_3:Rn_0-1         is stepZIDS_3=2 & Rn_0             { Rn_0 = Rn_0 - 1; }
# See note on step_Rn_0
Rn_0_stepZIDS_3:Rn_0+step_Rn_0 is stepZIDS_3=3 & Rn_0 & step_Rn_0 { Rn_0 = Rn_0 + step_Rn_0; }

# Nocash says modr seems to be just increment/decrement with optional modulo,
# though the official documentation has syntax as if they are memory accesses.
# http://problemkaputt.de/gbatek-dsi-teaklite-ii-operand-encoding.htm
MemRn_0_stepZIDS_3:$(OB)Rn_0$(CB)   is stepZIDS_3=0 & Rn_0 {}
MemRn_0_stepZIDS_3:$(OB)Rn_0+1$(CB) is stepZIDS_3=1 & Rn_0 { Rn_0 = Rn_0 + 1; }
MemRn_0_stepZIDS_3:$(OB)Rn_0-1$(CB) is stepZIDS_3=2 & Rn_0 { Rn_0 = Rn_0 - 1; }
MemRn_0_stepZIDS_3:$(OB)Rn_0+step_Rn_0$(CB) is stepZIDS_3=3 & Rn_0 & step_Rn_0 { Rn_0 = Rn_0 + step_Rn_0; }

# Note: we attach values 1 and 2 to stepII2 above

# ^R(\d+)@(\d+)stepII2@(\d+)$
# R\1_\2_stepII2_\3:R\1_\2+stepII2_\3 is R\1_\2 & stepII2_\3 { R\1_\2 = R\1_\2 + stepII2_\3; }
R01_2_stepII2_0:R01_2+stepII2_0 is R01_2 & stepII2_0 { R01_2 = R01_2 + stepII2_0; }
R01_5_stepII2_0:R01_5+stepII2_0 is R01_5 & stepII2_0 { R01_5 = R01_5 + stepII2_0; }
R01_8_stepII2_0:R01_8+stepII2_0 is R01_8 & stepII2_0 { R01_8 = R01_8 + stepII2_0; }
R01_9_stepII2_0:R01_9+stepII2_0 is R01_9 & stepII2_0 { R01_9 = R01_9 + stepII2_0; }
R01_3_stepII2_1:R01_3+stepII2_1 is R01_3 & stepII2_1 { R01_3 = R01_3 + stepII2_1; }
R01_4_stepII2_2:R01_4+stepII2_2 is R01_4 & stepII2_2 { R01_4 = R01_4 + stepII2_2; }
R01_5_stepII2_3:R01_5+stepII2_3 is R01_5 & stepII2_3 { R01_5 = R01_5 + stepII2_3; }
R01_0_stepII2_8:R01_0+stepII2_8 is R01_0 & stepII2_8 { R01_0 = R01_0 + stepII2_8; }

R45_2_stepII2_1:R45_2+stepII2_1 is R45_2 & stepII2_1 { R45_2 = R45_2 + stepII2_1; }
R45_5_stepII2_1:R45_5+stepII2_1 is R45_5 & stepII2_1 { R45_5 = R45_5 + stepII2_1; }
R45_8_stepII2_1:R45_8+stepII2_1 is R45_8 & stepII2_1 { R45_8 = R45_8 + stepII2_1; }
R45_3_stepII2_2:R45_3+stepII2_2 is R45_3 & stepII2_2 { R45_3 = R45_3 + stepII2_2; }
R45_4_stepII2_3:R45_4+stepII2_3 is R45_4 & stepII2_3 { R45_4 = R45_4 + stepII2_3; }
R45_5_stepII2_4:R45_5+stepII2_4 is R45_5 & stepII2_4 { R45_5 = R45_5 + stepII2_4; }
R45_9_stepII2_8:R45_9+stepII2_8 is R45_9 & stepII2_8 { R45_9 = R45_9 + stepII2_8; }
R45_0_stepII2_9:R45_0+stepII2_9 is R45_0 & stepII2_9 { R45_0 = R45_0 + stepII2_9; }

R04_1_stepII2_0:R04_1+stepII2_0 is R04_1 & stepII2_0 { R04_1 = R04_1 + stepII2_0; }
R04_3_stepII2_2:R04_3+stepII2_2 is R04_3 & stepII2_2 { R04_3 = R04_3 + stepII2_2; }
R04_4_stepII2_3:R04_4+stepII2_3 is R04_4 & stepII2_3 { R04_4 = R04_4 + stepII2_3; }
R04_8_stepII2_3:R04_8+stepII2_3 is R04_8 & stepII2_3 { R04_8 = R04_8 + stepII2_3; }
R04_8_stepII2_5:R04_8+stepII2_5 is R04_8 & stepII2_5 { R04_8 = R04_8 + stepII2_5; }

# TODO: stepi/stepj? Also nocash doc has a stray quote here
R04_4_stepD2S_3:R04_3-2     is R04_3 & stepD2S_3=0         { R04_3 = R04_3 - 2; }
R04_4_stepD2S_3:R04_3+stepi is R04_3 & stepD2S_3=1 & stepi { R04_3 = R04_3 + stepi; }

MemR0425_7_offsZI_6: $(OB)R0425_7$(CB)  is R0425_7 & offsZI_6=0 { export *[data]:2 R0425_7; }
MemR0425_7_offsZI_6: $(OB)R0425_7+$(CB) is R0425_7 & offsZI_6=1 { addr = R0425_7; export *[data]:2 addr; }

R0425_7_stepII2_6:R0425_7+stepII2_6 is R0425_7 & stepII2_6 { R0425_7 = R0425_7 + stepII2_6; }

Imm2u_0:imm2u_0 is imm2u_0 { local tmp:2 = imm2u_0; export tmp; }
Imm2u_1:imm2u_1 is imm2u_1 { local tmp:2 = imm2u_1; export tmp; }
Imm4u_0:imm4u_0 is imm4u_0 { local tmp:2 = imm4u_0; export tmp; }
Imm5u_0:imm5u_0 is imm5u_0 { local tmp:2 = imm5u_0; export tmp; }
Imm5s_0:imm5s_0 is imm5s_0 { local tmp:2 = imm5s_0; export tmp; }
Imm6s_0:imm6s_0 is imm6s_0 { local tmp:2 = imm6s_0; export tmp; }
Imm7s_0:imm7s_0 is imm7s_0 { local tmp:2 = imm7s_0; export tmp; }
Imm8s_0:imm8s_0 is imm8s_0 { local tmp:2 = imm8s_0; export tmp; }
Imm8u_0:imm8u_0 is imm8u_0 { local tmp:2 = imm8u_0; export tmp; }
Imm9u_0:imm9u_0 is imm9u_0 { local tmp:2 = imm9u_0; export tmp; }
Imm16:expanded_imm is expanded_imm { local tmp:2 = expanded_imm; export tmp; }

macro FLAGS40(result) {
	# Based on teakra SetAccFlag
	local tmp:5 = result;  # requires 5-byte input
	$(FLAG_Z) = (tmp == 0);
	$(FLAG_M) = (tmp s< 0);
	$(FLAG_E) = (tmp != sext(tmp:4));
	# Interestingly, this is the same as GCDSP operation xB, which uses SR_TOP2BITS.
	# There must be some common use for this operation, then...
	local top2equal:1 = ((tmp & 0xc0000000) == 0) || ((tmp & 0xc0000000) == 0xc0000000);
	$(FLAG_N) = $(FLAG_Z) || (!$(FLAG_E) && !top2equal);
}

# Interestingly, based on teakra's AddSub, this is the same logic as FLAGS_ADD40 and FLAGS_SUB40
# for GCDSP. (teakra does write it using more bit shifting, though, but I'm pretty sure they're equivalent.)
macro FLAGS_ADD40(a, b) {
	FLAGS40(a + b);
	$(FLAG_V) = (a > (a + b));
	$(FLAG_VL) = $(FLAG_VL) | $(FLAG_V);
	$(FLAG_C) = scarry(a, b);
}

macro ADD40_3(dest, a, b) {
	FLAGS_ADD40(a, b);
	# TODO: saturation would happen here (except for add3 and similar...)
	dest = a + b;
}

macro ADD40(a, b) {
	ADD40_3(a, a, b);
}

macro FLAGS_SUB40(a, b) {
	FLAGS40(a - b);
	$(FLAG_V) = (a >= (a - b));
	$(FLAG_VL) = $(FLAG_VL) | $(FLAG_V);
	$(FLAG_C) = scarry(a, -b);
}

macro SUB40_3(dest, a, b) {
	FLAGS_SUB40(a, b);
	# TODO: saturation would happen here (except for sub3 and similar...)
	dest = a - b;
}

macro SUB40(a, b) {
	SUB40_3(a, a, b);
}

macro ADD16(dest, a, b) {
	# TODO: this is a weird operation. Perhaps the builtin carry and such checks would work,
	# but I'm not sure of it.
	local result_unsigned:4 = zext(a) + zext(b);
	local result_signed:4 = sext(a) + sext(b);
	local result:2 = result_unsigned:2;
	$(FLAG_C) = (result_unsigned >> 16) != 0;
	$(FLAG_M) = result_signed s< 0;  # 32-bit operation, which is weird... does this actually differ for sign-extended values?
	$(FLAG_Z) = result == 0;
	dest = result;
}

macro FLAGS_SUB16(a, b) {
	# TODO: this is a weird operation. Perhaps the builtin carry and such checks would work,
	# but I'm not sure of it.
	local result_unsigned:4 = zext(a) + zext(b);
	local result_signed:4 = sext(a) + sext(b);
	local result:2 = result_unsigned:2;
	$(FLAG_C) = (result_unsigned >> 16) != 0;
	$(FLAG_M) = result_signed s< 0;  # 32-bit operation, which is weird... does this actually differ for sign-extended values?
	$(FLAG_Z) = result == 0;
}

macro SUB16(dest, a, b) {
	FLAGS_SUB16(a, b);
	dest = a - b;
}

macro FLAGS16(result) {
	# This applies to set/rst/chng. It would apply to subv and addv, except that those seem to use 32-bit sign extension. That may still be equivalent though.
	$(FLAG_M) = result s< 0;
	$(FLAG_Z) = result == 0;
}

# teakra ProductSum for the following 8 macros
macro PRODUCT_ADD3(dest, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	ADD40(dest, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	ADD40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) | tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) | tmp_flag_v;
}

macro PRODUCT_SUB3(dest, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	SUB40(dest, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	SUB40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) | tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) | tmp_flag_v;
}

macro PRODUCT_ADD_SUB(dest, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	ADD40(dest, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	SUB40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) ^ tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) ^ tmp_flag_v;
}

macro PRODUCT_SUB_ADD(dest, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	ADD40(dest, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	ADD40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) ^ tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) ^ tmp_flag_v;
}

macro PRODUCT_ADD3_SV(dest, possibly_rounded_sv, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	ADD40_3(dest, possibly_rounded_sv, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	ADD40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) | tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) | tmp_flag_v;
}

macro PRODUCT_SUB3_SV(dest, possibly_rounded_sv, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	SUB40_3(dest, possibly_rounded_sv, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	SUB40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) | tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) | tmp_flag_v;
}

macro PRODUCT_ADD_SUB_SV(dest, possibly_rounded_sv, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	ADD40_3(dest, possibly_rounded_sv, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	SUB40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) ^ tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) ^ tmp_flag_v;
}

macro PRODUCT_SUB_ADD_SV(dest, possibly_rounded_sv, possibly_shifted_p0, possibly_shifted_p1) {
	# TODO: this means that we can't implement saturation in ADD40_3 since the intermediate value shouldn't be saturated here (probably)
	SUB40_3(dest, possibly_rounded_sv, possibly_shifted_p0);
	local tmp_flag_c = $(FLAG_C);
	local tmp_flag_v = $(FLAG_V);
	ADD40(dest, possibly_shifted_p1);
	# TODO: saturate here
	# TODO: teakra marks this as a TODO for different behavior regarding add/subtract
	$(FLAG_C) = $(FLAG_C) ^ tmp_flag_c;
	$(FLAG_V) = $(FLAG_V) ^ tmp_flag_v;
}

# This would be a mess due to the shift-mode flag and sv and stuff (see teakra ShiftBus40). For now don't implement it.
define pcodeop shift_overflows; # TODO: this probably isn't needed
macro SHIFT_OVERFLOW_FLAGS(value, shift) {
	local value_tmp:5 = value;
	local shift_tmp:2 = shift;
	local overflows:1 = shift_overflows(value_tmp, shift_tmp);
	$(FLAG_V) = overflows;
	$(FLAG_VL) = $(FLAG_VL) | $(FLAG_V);
}
define pcodeop shift_40;
macro SHIFT_40(dest, value, shift) {
	SHIFT_OVERFLOW_FLAGS(value, shift);
	local value_tmp:5 = value;
	local shift_tmp:2 = shift;
	dest = shift_40(value_tmp, shift_tmp);
	# TODO: saturation, only for arithmetic shifts
	FLAGS40(dest);
}

# These exist to handle hwm later
Y0_input:y0 is y0 { export y0; } # hwm = 0
Y1_input:y1 is y1 { export y1; }
# Y0_input:y0 is y0 { local tmp:2 = y0 >> 8; export tmp; } # hwm = 1
# Y1_input:y1 is y1 { local tmp:2 = y1 >> 8; export tmp; } # hwm = 1
# Y0_input:y0 is y0 { local tmp:2 = y0 & 0xff; export tmp; } # hwm = 2
# Y1_input:y1 is y1 { local tmp:2 = y1 & 0xff; export tmp; } # hwm = 2
# Y0_input:y0 is y0 { local tmp:2 = y0 >> 8; export tmp; } # hwm = 3
# Y1_input:y1 is y1 { local tmp:2 = y1 & 0xff; export tmp; } # hwm = 3
macro MULTIPLY(x, y, p) {
	local x_in:5 = x;
	local y_in:5 = y;
	p = x_in * y_in;
	# If x_in and y_in are already 40-bit sign-extended, I don't think we need to do anything after this
	# (teakra's DoMultiplication does need to set pe if values are signed or not)
}

macro VTRSHR() {
	# TODO: teakra says: "This instruction has one cycle delay on vtr0, but not on vtr1"
	vtr0 = (vtr0 >> 1) | (zext($(FLAG_C)) << 15);
	vtr1 = (vtr1 >> 1) | (zext($(FLAG_C)) << 15);
}

# NOTE: nocash is inconsistent with RegisterP0@0 and Register@0 - teakra's RegToBus16 and RegFromBus16
# indicate that p0h is always read from and writes always affect all of p0, but nocash e.g.
# uses Register_0 when reading in addl (94A0h) and addh (92A0h) but Register_0 in add (86A0h).
# I've used p0h for all reads and p0 for writes here (I don't think teakra's disassembler uses p0h
# at all for Register_0).
attach variables [ Register_0_ Register_5_ ] [
       r0 r1 r2 r3
       r4 r5 r7 y0 # NOTE: no r6
       # 08
       st0 st1 st2 _ # TODO: might need special logic here for st0/st1/st2 too
       _ sp cfgi cfgj
       # 10
       _ _ _ _
       _ _ _ _
       # 18
       _ _ _ _
       _ _ _ sv
];

# For registers in the "attach variables" statement above that don't need any special behavior:
Register_0_Read_Impl:Register_0_ is Register_0_ { export Register_0_; }
Register_5_Read_Impl:Register_5_ is Register_5_ { export Register_5_; }
Register_0_Write:Register_0_ is Register_0_ { export Register_0_; }
Register_5_Write:Register_5_ is Register_5_ { export Register_5_; }
Register_0_Write_After:Register_0_ is Register_0_ {}
Register_5_Write_After:Register_5_ is Register_5_ {}

# ... and the rest, which are a lot messier

Register_0_Read_Impl:p0h is Register_0_=0x0B & p0h { export p0h; }
Register_5_Read_Impl:p0h is Register_5_=0x0B & p0h { export p0h; }
Register_0_Write:p0 is Register_0_=0x0B & p0 { export p0h; }
Register_5_Write:p0 is Register_5_=0x0B & p0 { export p0h; }
Register_0_Write_After:p0 is Register_0_=0x0B & p0 { p0 = sext(p0h) << 16; }
Register_5_Write_After:p0 is Register_5_=0x0B & p0 { p0 = sext(p0h) << 16; }

# Marked as UNREACHABLE() in teakra, even though it definitely exists...
Register_0_Read_Impl:pc is Register_0_=0x0C & pc unimpl
Register_5_Read_Impl:pc is Register_5_=0x0C & pc unimpl
Register_0_Write:pc is Register_0_=0x0C & pc unimpl
Register_5_Write:pc is Register_5_=0x0C & pc unimpl
Register_0_Write_After:pc is Register_0_=0x0C & pc unimpl
Register_5_Write_After:pc is Register_5_=0x0C & pc unimpl

# Reads from [ab][01][lh] experience saturation on some instructions.
# Writes will saturate on ALL instructions.

Register_0_Read_No_Saturate:b0h is Register_0_=0x10 & b0h { export b0h; }
Register_0_Read_No_Saturate:b1h is Register_0_=0x11 & b1h { export b1h; }
Register_0_Read_No_Saturate:b0l is Register_0_=0x12 & b0l { export b0l; }
Register_0_Read_No_Saturate:b1l is Register_0_=0x13 & b1l { export b1l; }

# TODO: actually conditionally saturate
Register_0_Read_Saturate:b0h is Register_0_=0x10 & b0h { export b0h; }
Register_5_Read_Saturate:b0h is Register_5_=0x10 & b0h { export b0h; }
Register_0_Read_Saturate:b1h is Register_0_=0x11 & b1h { export b1h; }
Register_5_Read_Saturate:b1h is Register_5_=0x11 & b1h { export b1h; }
Register_0_Read_Saturate:b0l is Register_0_=0x12 & b0l { export b0l; }
Register_5_Read_Saturate:b0l is Register_5_=0x12 & b0l { export b0l; }
Register_0_Read_Saturate:b1l is Register_0_=0x13 & b1l { export b1l; }
Register_5_Read_Saturate:b1l is Register_5_=0x13 & b1l { export b1l; }

Register_0_Write:b0h is Register_0_=0x10 & b0h { export b0h; }
Register_5_Write:b0h is Register_5_=0x10 & b0h { export b0h; }
Register_0_Write:b1h is Register_0_=0x11 & b1h { export b1h; }
Register_5_Write:b1h is Register_5_=0x11 & b1h { export b1h; }
Register_0_Write:b0l is Register_0_=0x12 & b0l { export b0l; }
Register_5_Write:b0l is Register_5_=0x12 & b0l { export b0l; }
Register_0_Write:b1l is Register_0_=0x13 & b1l { export b1l; }
Register_5_Write:b1l is Register_5_=0x13 & b1l { export b1l; }

Register_0_Write_After:b0h is Register_0_=0x10 & b0h { b0 = sext(b0h) << 16; FLAGS40(b0); }
Register_5_Write_After:b0h is Register_5_=0x10 & b0h { b0 = sext(b0h) << 16; FLAGS40(b0); }
Register_0_Write_After:b1h is Register_0_=0x11 & b1h { b1 = sext(b1h) << 16; FLAGS40(b1); }
Register_5_Write_After:b1h is Register_5_=0x11 & b1h { b1 = sext(b1h) << 16; FLAGS40(b1); }
Register_0_Write_After:b0l is Register_0_=0x12 & b0l { b0 = zext(b0l); FLAGS40(b0); }
Register_5_Write_After:b0l is Register_5_=0x12 & b0l { b0 = zext(b0l); FLAGS40(b0); }
Register_0_Write_After:b1l is Register_0_=0x13 & b1l { b1 = zext(b1l); FLAGS40(b1); }
Register_5_Write_After:b1l is Register_5_=0x13 & b1l { b1 = zext(b1l); FLAGS40(b1); }

define pcodeop read_ext0;
define pcodeop write_ext0;
Register_0_Read_Impl:ext0 is Register_0_=0x14 & ext0 { ext0 = read_ext0(); export ext0; }
Register_5_Read_Impl:ext0 is Register_5_=0x14 & ext0 { ext0 = read_ext0(); export ext0; }
Register_0_Write:ext0 is Register_0_=0x14 & ext0 { export ext0; }
Register_5_Write:ext0 is Register_5_=0x14 & ext0 { export ext0; }
Register_0_Write_After:ext0 is Register_0_=0x14 & ext0 { write_ext0(ext0); }
Register_5_Write_After:ext0 is Register_5_=0x14 & ext0 { write_ext0(ext0); }
define pcodeop read_ext1;
define pcodeop write_ext1;
Register_0_Read_Impl:ext1 is Register_0_=0x15 & ext1 { ext1 = read_ext1(); export ext1; }
Register_5_Read_Impl:ext1 is Register_5_=0x15 & ext1 { ext1 = read_ext1(); export ext1; }
Register_0_Write:ext1 is Register_0_=0x15 & ext1 { export ext1; }
Register_5_Write:ext1 is Register_5_=0x15 & ext1 { export ext1; }
Register_0_Write_After:ext1 is Register_0_=0x15 & ext1 { write_ext0(ext1); }
Register_5_Write_After:ext1 is Register_5_=0x15 & ext1 { write_ext0(ext1); }
define pcodeop read_ext2;
define pcodeop write_ext2;
Register_0_Read_Impl:ext2 is Register_0_=0x16 & ext2 { ext2 = read_ext2(); export ext2; }
Register_5_Read_Impl:ext2 is Register_5_=0x16 & ext2 { ext2 = read_ext2(); export ext2; }
Register_0_Write:ext2 is Register_0_=0x16 & ext2 { export ext2; }
Register_5_Write:ext2 is Register_5_=0x16 & ext2 { export ext2; }
Register_0_Write_After:ext2 is Register_0_=0x16 & ext2 { write_ext0(ext2); }
Register_5_Write_After:ext2 is Register_5_=0x16 & ext2 { write_ext0(ext2); }
define pcodeop read_ext3;
define pcodeop write_ext3;
Register_0_Read_Impl:ext3 is Register_0_=0x17 & ext3 { ext3 = read_ext3(); export ext3; }
Register_5_Read_Impl:ext3 is Register_5_=0x17 & ext3 { ext3 = read_ext3(); export ext3; }
Register_0_Write:ext3 is Register_0_=0x17 & ext3 { export ext3; }
Register_5_Write:ext3 is Register_5_=0x17 & ext3 { export ext3; }
Register_0_Write_After:ext3 is Register_0_=0x17 & ext3 { write_ext3(ext3); }
Register_5_Write_After:ext3 is Register_5_=0x17 & ext3 { write_ext3(ext3); }

# Note: a0/a1 never saturate on read
# ... but I think there are some special cases where mov uses the whole a0/a1...
Register_0_Read_Impl:a0 is Register_0_=0x18 & a0 { export a0l; }
Register_5_Read_Impl:a0 is Register_5_=0x18 & a0 { export a0l; }
Register_0_Read_Impl:a1 is Register_0_=0x19 & a1 { export a1l; }
Register_5_Read_Impl:a1 is Register_5_=0x19 & a1 { export a1l; }

Register_0_Write:a0 is Register_0_=0x18 & a0 { export a0l; }
Register_5_Write:a0 is Register_5_=0x18 & a0 { export a0l; }
Register_0_Write:a1 is Register_0_=0x19 & a1 { export a1l; }
Register_5_Write:a1 is Register_5_=0x19 & a1 { export a1l; }

Register_0_Write_After:a0 is Register_0_=0x18 & a0 { a0 = sext(a0l); FLAGS40(a0); }
Register_5_Write_After:a0 is Register_5_=0x18 & a0 { a0 = sext(a0l); FLAGS40(a0); }
Register_0_Write_After:a1 is Register_0_=0x19 & a1 { a1 = sext(a1l); FLAGS40(a1); }
Register_5_Write_After:a1 is Register_5_=0x19 & a1 { a1 = sext(a1l); FLAGS40(a1); }

Register_0_Read_No_Saturate:a0h is Register_0_=0x1A & a0h { export a0h; }
Register_0_Read_No_Saturate:a1h is Register_0_=0x1B & a1h { export a1h; }
Register_0_Read_No_Saturate:a0l is Register_0_=0x1C & a0l { export a0l; }
Register_0_Read_No_Saturate:a1l is Register_0_=0x1D & a1l { export a1l; }

# TODO: actually conditionally saturate
Register_0_Read_Saturate:a0h is Register_0_=0x1A & a0h { export a0h; }
Register_5_Read_Saturate:a0h is Register_5_=0x1A & a0h { export a0h; }
Register_0_Read_Saturate:a1h is Register_0_=0x1B & a1h { export a1h; }
Register_5_Read_Saturate:a1h is Register_5_=0x1B & a1h { export a1h; }
Register_0_Read_Saturate:a0l is Register_0_=0x1C & a0l { export a0l; }
Register_5_Read_Saturate:a0l is Register_5_=0x1C & a0l { export a0l; }
Register_0_Read_Saturate:a1l is Register_0_=0x1D & a1l { export a1l; }
Register_5_Read_Saturate:a1l is Register_5_=0x1D & a1l { export a1l; }

Register_0_Write:a0h is Register_0_=0x1A & a0h { export a0h; }
Register_5_Write:a0h is Register_5_=0x1A & a0h { export a0h; }
Register_0_Write:a1h is Register_0_=0x1B & a1h { export a1h; }
Register_5_Write:a1h is Register_5_=0x1B & a1h { export a1h; }
Register_0_Write:a0l is Register_0_=0x1C & a0l { export a0l; }
Register_5_Write:a0l is Register_5_=0x1C & a0l { export a0l; }
Register_0_Write:a1l is Register_0_=0x1D & a1l { export a1l; }
Register_5_Write:a1l is Register_5_=0x1D & a1l { export a1l; }

Register_0_Write_After:a0h is Register_0_=0x1A & a0h { a0 = sext(a0h) << 16; FLAGS40(a0); }
Register_5_Write_After:a0h is Register_5_=0x1A & a0h { a0 = sext(a0h) << 16; FLAGS40(a0); }
Register_0_Write_After:a1h is Register_0_=0x1B & a1h { a1 = sext(a1h) << 16; FLAGS40(a1); }
Register_5_Write_After:a1h is Register_5_=0x1B & a1h { a1 = sext(a1h) << 16; FLAGS40(a1); }
Register_0_Write_After:a0l is Register_0_=0x1C & a0l { a0 = zext(a0l); FLAGS40(a0); }
Register_5_Write_After:a0l is Register_5_=0x1C & a0l { a0 = zext(a0l); FLAGS40(a0); }
Register_0_Write_After:a1l is Register_0_=0x1D & a1l { a1 = zext(a1l); FLAGS40(a1); }
Register_5_Write_After:a1l is Register_5_=0x1D & a1l { a1 = zext(a1l); FLAGS40(a1); }

# NOTE: CurLC_Even_Not_In_Loop is a table based on context, so we can't use it in attach variables.
Register_0_Read_Impl:CurLC_Even_Not_In_Loop is Register_0_=0x1E & CurLC_Even_Not_In_Loop { export CurLC_Even_Not_In_Loop; }
Register_5_Read_Impl:CurLC_Even_Not_In_Loop is Register_5_=0x1E & CurLC_Even_Not_In_Loop { export CurLC_Even_Not_In_Loop; }
Register_0_Write:CurLC_Even_Not_In_Loop is Register_0_=0x1E & CurLC_Even_Not_In_Loop { export CurLC_Even_Not_In_Loop; }
Register_5_Write:CurLC_Even_Not_In_Loop is Register_5_=0x1E & CurLC_Even_Not_In_Loop { export CurLC_Even_Not_In_Loop; }
Register_0_Write_After:CurLC_Even_Not_In_Loop is Register_0_=0x1E & CurLC_Even_Not_In_Loop {}
Register_5_Write_After:CurLC_Even_Not_In_Loop is Register_5_=0x1E & CurLC_Even_Not_In_Loop {}

# Ignore saturation/no saturation for registers where it doesn't matter
Register_0_Read_Saturate:Register_0_Read_Impl is Register_0_Read_Impl { export Register_0_Read_Impl; }
Register_5_Read_Saturate:Register_5_Read_Impl is Register_5_Read_Impl { export Register_5_Read_Impl; }
Register_0_Read_No_Saturate:Register_0_Read_Impl is Register_0_Read_Impl { export Register_0_Read_Impl; }

# Comments are from http://problemkaputt.de/gbatek.htm#dsiteakliteiiinstructionsetencoding
# Note that "add  MemRn@0, Ax@8 || Rn@0stepZIDS@3" means two actions are performed by the instruction:
# First, it adds; then it applies a step (which is optional). The || does NOT indicate a choice of
# one action or the other; for instance 6FA0 always adds the high parts and subtracts the low parts.

# Base  Ver Opcode (with parameter bits located at @bitnumber and up)

# D4FBh TL  add  MemImm16@16, Ax@8
op:"add" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xFB; MemImm16 { ADD40(Ax_8, sext(MemImm16)); }
# A600h TL  add  MemImm8@0, Ax@8
op:"add" MemImm8_0, Ax_8 is opcode_9_15=(0xA6>>1) & Ax_8 & MemImm8_0 { ADD40(Ax_8, sext(MemImm8_0)); }
# 86C0h TL  add  Imm16@16, Ax@8
op:"add" Imm16, Ax_8 is opcode_9_15=(0x86>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { ADD40(Ax_8, sext(Imm16)); }
# C600h TL  add  Imm8u@0, Ax@8
op:"add" Imm8u_0, Ax_8 is opcode_9_15=(0xC6>>1) & Ax_8 & Imm8u_0 { ADD40(Ax_8, zext(Imm8u_0)); }
# D4DBh TL  add  MemR7Imm16@16, Ax@8
op:"add" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDB; MemR7Imm16 { ADD40(Ax_8, sext(MemR7Imm16)); }
# 4600h TL  add  MemR7Imm7s@0, Ax@8
op:"add" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x46>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { ADD40(Ax_8, sext(MemR7Imm7s_0)); }
# 8680h TL  add  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"add" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x86>>1) & Ax_8 & opcode_5_7=(0x80>>5) & Rn_0_stepZIDS_3 & MemRn_0 { ADD40(Ax_8, sext(MemRn_0)); build Rn_0_stepZIDS_3; }
# 86A0h TL  add  RegisterP0@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"add" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x86>>1) & Ax_8 & opcode_5_7=(0xA0>>5) & Register_0_Read_No_Saturate { ADD40(Ax_8, sext(Register_0_Read_No_Saturate)); }
@ifdef TEAK_LITE_2
# D2DAh TL2 add  Ab@10, Bx@0
op:"add" Ab_10, Bx_0 is opcode_12_15=0xD & Ab_10 & opcode_1_9=(0x2DA>>1) & Bx_0 { ADD40(Bx_0, Ab_10); }
# 5DF0h TL2 add  Bx@1, Ax@0
op:"add" Bx_1, Ax_0 is opcode_2_15=(0x5DF0>>2) & Bx_1 & Ax_0 { ADD40(Ax_0, Bx_1); }
# 9070h TL2 add  MemR01@8, sv, Abh@2 || sub MemR01@8offsZI@0, sv, Abl@2
#            || mov Abl@2, MemR45@8 || R01@8stepII2@0, R45@8stepII2@1
op:"add" MemR01_8, sv, Abh_2 || "sub" MemR01_8_offsZI_0, sv_copy, Abl_2 || "mov" Abl_2_copy, MemR45_8 || R01_8_stepII2_0, R45_8_stepII2_1
	is opcode_9_15=(0x90>>1) & MemR01_8 & opcode_3_7=(0x70>>3) & Abh_2 & R45_8_stepII2_1 & R01_8_stepII2_0
	& MemR45_8 & Abl_2 & MemR01_8_offsZI_0 & sv & sv_copy & Abl_2_copy & Ab_2
{
	# teakra add_sub_i_mov_j - no flags
	local high:5 = sext(MemR01_8) + sext(sv);
	local low:5 = zext(MemR01_8_offsZI_0 - sv);
	MemR45_8 = Abl_2;  # TODO: saturation
	Ab_2 = (high << 16) | low;
	build R01_8_stepII2_0;
	build R45_8_stepII2_1;
}
# 5DB0h TL2 add  MemR04@1, sv, Abh@2 || sub MemR04@1offsZI@0, sv, Abl@2
#            || R04@1stepII2@0
op:"add" MemR04_1, sv, Abh_2 || "sub" MemR04_1_offsZI_0, sv_copy, Abl_2 || R04_1_stepII2_0
	is opcode_3_15=(0x5DB0>>3) & Abh_2 & MemR04_1 & MemR04_1_offsZI_0 & Ab_2
	& Abl_2 & R04_1_stepII2_0 & sv & sv_copy
{
	# teakra add_sub_sv - no flags
	local high:5 = sext(MemR04_1) + sext(sv);
	local low:5 = zext(MemR04_1_offsZI_0 - sv);
	Ab_2 = (high << 16) | low;
	build R04_1_stepII2_0;
}
# 6F80h TL2 add  MemR45@2, MemR01@2, Abh@3
#            || add MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"add" MemR45_2, MemR01_2, Abh_3 || "add" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_4_15=0x6F8 & Abh_3 & MemR45_2 & MemR45_2_offsZI_1 & MemR01_2_offsZI_0
	& Abl_3 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 & Ab_2
{
	# teakra add_add - no flags
	local high:5 = sext(MemR45_2) + sext(MemR01_2);
	local low:5 = zext(MemR45_2_offsZI_1 + MemR01_2_offsZI_0);
	Ab_2 = (high << 16) | low;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 6FA0h TL2 add  MemR45@2, MemR01@2, Abh@3
#            || sub MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"add" MemR45_2, MemR01_2, Abh_3 || "sub" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_4_15=0x6FA & Abh_3 & MemR45_2 & MemR45_2_offsZI_1 & MemR01_2_offsZI_0
	& Abl_3 & MemR01_2 & R01_2_stepII2_0 & R45_2_stepII2_1 & Ab_2
{
	# teakra add_sub - no flags
	local high:5 = sext(MemR45_2) + sext(MemR01_2);
	local low:5 = zext(MemR45_2_offsZI_1 - MemR01_2_offsZI_0);
	Ab_2 = (high << 16) | low;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 5E30h TL2 add  MemR45@8, sv, Abh@2 || sub MemR45@8offsZI@1, sv, Abl@2
#            || mov Abl@2, MemR01@8 || R01@8stepII2@0, R45@8stepII2@1
op:"add" MemR45_8, sv, Abh_2 || "sub" MemR45_8_offsZI_1, sv_copy, Abl_2 || "mov" Abl_2_copy, MemR01_8 || R01_8_stepII2_0, R45_8_stepII2_1
	is opcode_9_15=(0x5E >> 1) & MemR45_8 & opcode_3_7=(0x30>>3) & Abh_2 & R01_8_stepII2_0 & R45_8_stepII2_1
	& MemR45_8_offsZI_1 & MemR01_8 & Abl_2 & Abl_2_copy & sv & sv_copy & Ab_2
{
	# teakra add_sub_j_mov_i - no flags
	local high:5 = sext(MemR45_8) + sext(sv);
	local low:5 = zext(MemR45_8_offsZI_1 - sv);
	MemR01_8 = Abl_2;  # TODO: saturation
	Ab_2 = (high << 16) | low;
	build R01_8_stepII2_0;
	build R45_8_stepII2_1;
}
# 5DC0h TL2 add  p0, p1, Ab@2
# TODO: better handling of product registers - there's some additional shift stuff that needs to happen
# NOTE: we don't need to do an ADD40(0, p0) call as that will never set FLAG_C or FLAG_V
# (teakra's ProductSum is just too generalized)
op:"add" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=0 & p0 & p1 { ADD40_3(Ab_2, p0, p1); }
# D782h TL2 add  p1, Ax@0
op:"add" p1, Ax_0 is opcode_1_15=(0xD782>>1) & Ax_0 & p1 { ADD40(Ax_0, p1); }
# 5DF8h TL2 add  Px@1, Bx@0
op:"add" Px_1, Bx_0 is opcode_2_15=(0x5DF8>>2) & Px_1 & Bx_0 { ADD40(Bx_0, Px_1); }
# D38Bh TL2 add  r6, Ax@4
op:"add" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xB & r6 { ADD40(Ax_4, sext(r6)); }
# 4590h TL2 add3 p0, p1, Ab@2
op:"add3" p0, p1, Ab_2 is opcode_4_15=0x459 & Ab_2 & opcode_0_1=0 & p0 & p1 { PRODUCT_ADD3(Ab_2, p0, p1); }
# 4592h TL2 add3a p0, p1, Ab@2
op:"add3a" p0, p1, Ab_2 is opcode_4_15=0x459 & Ab_2 & opcode_0_1=2 & p0 & p1 { PRODUCT_ADD3(Ab_2, p0, p1 s>> 16); }
# 4593h TL2 add3aa p0, p1, Ab@2
op:"add3aa" p0, p1, Ab_2 is opcode_4_15=0x459 & Ab_2 & opcode_0_1=3 & p0 & p1 { PRODUCT_ADD3(Ab_2, p0 s>> 16, p1 s>> 16); }
# 5DC1h TL2 adda p0, p1, Ab@2
op:"adda" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=1 & p0 & p1 { ADD40_3(Ab_2, p0, p1 s>> 16); }
@endif
# B200h TL  addh MemImm8@0, Ax@8
# per teakra ExtendOperandForAlm, addh shifts its operand by 16
op:"addh" MemImm8_0, Ax_8 is opcode_9_15=(0xB2>>1) & Ax_8 & MemImm8_0 { ADD40(Ax_8, sext(MemImm8_0) << 16); }
# 9280h TL  addh MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"addh" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x92>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { ADD40(Ax_8, sext(MemRn_0) << 16); build Rn_0_stepZIDS_3; }
# 92A0h TL  addh Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"addh" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x92>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { ADD40(Ax_8, sext(Register_0_Read_No_Saturate) << 16); }
@ifdef TEAK_LITE_2
# 9464h TL2 addh r6, Ax@0
op:"addh" r6, Ax_0 is opcode_1_15=(0x9464>>1) & Ax_0 & r6 { ADD40(Ax_0, sext(r6) << 16); }
# 90E0h TL2 addhp MemR0425@2, Px@4, Ax@8 || R0425@2stepII2D2S@0 ;p=ProgMem? Px?
op:"addhp" MemR0425_2, Px_4, Ax_8 || R0425_2_stepII2D2S_0 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0xE>>1) & Px_4 & MemR0425_2 & R0425_2_stepII2D2S_0 {
	# per teakra addhp
	ADD40_3(Ax_8, (sext(MemR0425_2) << 16) | 0x8000, Px_4);
	build R0425_2_stepII2D2S_0;
}
@endif
# B400h TL  addl MemImm8@0, Ax@8
# per teakra ExtendOperandForAlm (not having anything), addl zero-extends instead of sign-extending
op:"addl" MemImm8_0, Ax_8 is opcode_9_15=(0xB4>>1) & Ax_8 & MemImm8_0 { ADD40(Ax_8, zext(MemImm8_0)); }
# 9480h TL  addl MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"addl" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { ADD40(Ax_8, zext(MemRn_0)); build Rn_0_stepZIDS_3; }
# 94A0h TL  addl Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"addl" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { ADD40(Ax_8, zext(Register_0_Read_No_Saturate)); }
@ifdef TEAK_LITE_2
# 9466h TL2 addl r6, Ax@0
op:"addl" r6, Ax_0 is opcode_1_15=(0x9466>>1) & Ax_0 & r6 { ADD40(Ax_0, zext(r6)); }
# 906Ch TL2 addsub  p0, p1, Ab@0
op:"addsub" p0, p1, Ab_0 is opcode_2_15=(0x906C>>2) & Ab_0 & p0 & p1 { PRODUCT_ADD_SUB(Ab_0, p0, p1); }
# 49C2h TL2 addsub  p1, p0, Ab@4
op:"addsub" p1, p0, Ab_4 is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_0_3=2 & p1 & p0 { PRODUCT_SUB_ADD(Ab_4, p0, p1); }
# 916Ch TL2 addsuba p0, p1, Ab@0
op:"addsuba" p0, p1, Ab_0 is opcode_2_15=(0x916C>>2) & Ab_0 & p0 & p1 { PRODUCT_ADD_SUB(Ab_0, p0, p1 s>> 16); }
# 49C3h TL2 addsuba p1, p0, Ab@4
op:"addsuba" p1, p0, Ab_4 is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_0_3=3 & p1 & p0 { PRODUCT_SUB_ADD(Ab_4, p0, p1 s>> 16); }
@endif
# E700h TL  addv Imm16@16, MemImm8@0
op:"addv" Imm16, MemImm8_0 is opcode_8_15=0xE7 & MemImm8_0; Imm16 { ADD16(MemImm8_0, MemImm8_0, Imm16); }
# 86E0h TL  addv Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"addv" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x86E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { ADD16(MemRn_0, MemRn_0, Imm16); build Rn_0_stepZIDS_3; }
# 87E0h TL  addv Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 AND also weird behavior for writing to [ab][01][lh], not currently implemented
op:"addv" Imm16, Register_0_Write is opcode_5_15=(0x87E>>1) & Register_0_Read_No_Saturate & Register_0_Write & Register_0_Write_After; Imm16 { ADD16(Register_0_Write, Register_0_Read_No_Saturate, Imm16); build Register_0_Write_After; }
@ifdef TEAK_LITE_2
# 47BBh TL2 addv Imm16@16, r6
op:"addv" Imm16, r6 is opcode_0_15=0x47BB & r6; Imm16 { ADD16(r6, r6, Imm16); }
@endif
# D4F9h TL  and  MemImm16@16, Ax@8
# per teakra's ExtendOperandForAlm + AlmGeneric, and doesn't experience sign-extension (so this will kill most bits), nor does it experience saturation
op:"and" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xF9; MemImm16 { Ax_8 = Ax_8 & zext(MemImm16); FLAGS40(Ax_8); }
# A200h TL  and  MemImm8@0, Ax@8
op:"and" MemImm8_0, Ax_8 is opcode_9_15=(0xA2>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 & zext(MemImm8_0); FLAGS40(Ax_8); }
# 82C0h TL  and  Imm16@16, Ax@8
op:"and" Imm16, Ax_8 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 & zext(Imm16); FLAGS40(Ax_8); }
# C200h TL  and  Imm8u@0, Ax@8
op:"and" Imm8u_0, Ax_8 is opcode_9_15=(0xC2>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 & zext(Imm8u_0); FLAGS40(Ax_8); }
# D4D9h TL  and  MemR7Imm16@16, Ax@8
op:"and" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xD9; MemR7Imm16 { Ax_8 = Ax_8 & zext(MemR7Imm16); FLAGS40(Ax_8); }
# 4200h TL  and  MemR7Imm7s@0, Ax@8
op:"and" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x42>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 & zext(MemR7Imm7s_0); FLAGS40(Ax_8); }
# 8280h TL  and  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"and" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 & zext(MemRn_0); FLAGS40(Ax_8); build Rn_0_stepZIDS_3; }
# 82A0h TL  and  RegisterP0@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"and" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { Ax_8 = Ax_8 & zext(Register_0_Read_No_Saturate); FLAGS40(Ax_8); }
@ifdef TEAK_LITE_2
# 6770h TL2 and  Ab@2, Ab@0, Ax@12                ;TL2 only
op:"and" Ab_2, Ab_0, Ax_12 is opcode_13_15=(0x6>>1) & Ax_12 & opcode_4_11=0x77 & Ab_2 & Ab_0 { Ax_12 = Ab_2 & Ab_0; FLAGS40(Ax_12); }
# D389h TL2 and  r6, Ax@4
op:"and" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=9 & r6 { Ax_4 = Ax_4 & zext(r6); FLAGS40(Ax_4); }
@endif
# 4B80h TL  banke BankFlags6@0  ;{r0}{,r1}{,r4}{,cfgi}{,r7}{,cfgj}
# Simplified to joining with spaces instead of commas, as that'd require extra checking.
# Perhaps we should show r0b etc here, but eh.
BankFlag_r0:   is BankFlags_r0=0 {}
BankFlag_r0:r0 is BankFlags_r0=1 & r0 { local tmp = r0; r0 = r0b; r0b = tmp; }
BankFlag_r1:   is BankFlags_r1=0 {}
BankFlag_r1:r1 is BankFlags_r1=1 & r1 { local tmp = r1; r1 = r1b; r1b = tmp; }
BankFlag_r4:   is BankFlags_r4=0 {}
BankFlag_r4:r4 is BankFlags_r4=1 & r4 { local tmp = r4; r4 = r4b; r4b = tmp; }
BankFlag_cfgi:     is BankFlags_cfgi=0 {}
BankFlag_cfgi:cfgi is BankFlags_cfgi=1 & cfgi { local tmp = cfgi; cfgi = cfgib; cfgib = tmp; }
BankFlag_r7:   is BankFlags_r7=0 {}
BankFlag_r7:r7 is BankFlags_r7=1 & r7 { local tmp = r7; r7 = r7b; r7b = tmp; }
BankFlag_cfgj:     is BankFlags_cfgj=0 {}
BankFlag_cfgj:cfgj is BankFlags_cfgj=1 & cfgj { local tmp = cfgj; cfgj = cfgjb; cfgjb = tmp; }
op:"banke" BankFlag_r0 BankFlag_r1 BankFlag_r4 BankFlag_cfgi BankFlag_r7 BankFlag_cfgj is opcode_6_15=(0x4B8>>2) & BankFlag_r0 & BankFlag_r1 & BankFlag_r4 & BankFlag_cfgi & BankFlag_r7 & BankFlag_cfgj {
	build BankFlag_r0;
	build BankFlag_r1;
	build BankFlag_r4;
	build BankFlag_cfgi;
	build BankFlag_r7;
	build BankFlag_cfgj;
}
@ifdef TEAK_LITE_2
# 8CDFh TL2 bankr       ;without operand ?
op:"bankr" is opcode_0_15=0x8CDF unimpl # Note: 8CDE is undefined
# 8CDCh TL2 bankr Ar@0
op:"bankr" Ar_0 is opcode_1_15=(0x8CDC>>1) & Ar_0 unimpl
# 8CD0h TL2 bankr Ar@2, Arp@0
op:"bankr" Ar_2, Arp_0 is opcode_3_15=(0x8CD0>>3) & Ar_2 & Arp_0 unimpl
# 8CD8h TL2 bankr Arp@0
op:"bankr" Arp_0 is opcode_2_15=(0x8CD8>>2) & Arp_0 unimpl
# 5EB8h TL2 bitrev Rn@0
op:"bitrev" Rn_0 is opcode_3_15=(0x5EB8>>3) & Rn_0 unimpl
# D7E8h TL2 bitrev Rn@0, dbrv
op:"bitrev" Rn_0, "dbrv" is opcode_3_15=(0xD7E8>>3) & Rn_0 unimpl
# D7E0h TL2 bitrev Rn@0, ebrv
op:"bitrev" Rn_0, "ebrv" is opcode_3_15=(0xD7E0>>3) & Rn_0 unimpl
@endif
# 5C00h TL  bkrep NoReverse, Imm8u@0, Address16@16
op:"bkrep" Imm8u_0, CodeAddress16 is opcode_8_15=0x5C & Imm8u_0; CodeAddress16 & CodeAddress16After & CurLC
[
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(CodeAddress16After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(CodeAddress16, hasloopjumpback);
	globalset(CodeAddress16, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Imm8u_0;
}
# 5D00h TL  bkrep NoReverse, Register@0, Address18@16and5
op:"bkrep" Register_0_Read_No_Saturate, CodeAddress18_16and5 is opcode_7_15=(0x5D0>>3) ... & CodeAddress18_16and5 & CodeAddress18_16and5After & Register_0_Read_No_Saturate ... & CurLC
[
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(CodeAddress18_16and5After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(CodeAddress18_16and5, hasloopjumpback);
	globalset(CodeAddress18_16and5, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Register_0_Read_No_Saturate;
}
@ifdef TEAK_LITE_2
# 8FDCh TL2 bkrep NoReverse, r6, Address18@16and0
op:"bkrep" r6, CodeAddress18_16and0 is opcode_2_15=(0x8FDC>>2) ... & CodeAddress18_16and0 & CodeAddress18_16and0After & r6 & CurLC
[
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(CodeAddress18_16and0After, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(CodeAddress18_16and0, hasloopjumpback);
	globalset(CodeAddress18_16and0, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = r6;
}
# DA9Ch TL2 bkreprst MemR0425@0
# https://github.com/wwylele/teakra/blob/01db7cdd00aabcce559a8dddce8798dabb71949b/src/interpreter.h#L993-L1027
# This pushes to the bottom of the block repeat stack, but the top of the stack (the current loop) remains the same.
# So we don't need to mess with context variables or anything here.
define pcodeop bkreprst;
op:"bkreprst" MemR0425_0 is opcode_2_15=(0xDA9C>>2) & MemR0425_0 & R0425_0 {
	local flag:2 = MemR0425_0;
	R0425_0 = R0425_0 + 1;
	local end:3 = zext(MemR0425_0) | (((zext(flag) >> 8) & 3) << 16);
	R0425_0 = R0425_0 + 1;
	local start:3 = zext(MemR0425_0) | ((zext(flag) & 3) << 16);
	R0425_0 = R0425_0 + 1;
	local counter:2 = MemR0425_0;
	R0425_0 = R0425_0 + 1;

	bkreprst(flag, end, start, counter);
}
# 5F48h TL2 bkreprst MemSp, Unused2@0
op:"bkreprst" MemSp is MemSp & opcode_2_15=(0x5F48>>2) & unused_0_1 {
	local flag:2 = MemSp;
	sp = sp + 1;
	local end:3 = zext(MemSp) | (((zext(flag) >> 8) & 3) << 16);
	sp = sp + 1;
	local start:3 = zext(MemSp) | ((zext(flag) & 3) << 16);
	sp = sp + 1;
	local counter:2 = MemSp;
	sp = sp + 1;

	bkreprst(flag, end, start, counter);
}
define pcodeop bkrepsto_lp;
define pcodeop bkrepsto_end;
define pcodeop bkrepsto_start;
define pcodeop bkrepsto_counter;
# DADCh TL2 bkrepsto MemR0425@0, Unused1@10
op:"bkrepsto" MemR0425_0 is opcode_11_15=(0xDA>>3) & unused_10_10 & opcode_2_9=(0x2DC>>2) & MemR0425_0 & R0425_0 {
	local counter:2 = bkrepsto_counter();
	local start:3 = bkrepsto_start();
	local end:3 = bkrepsto_end();
	local start_end_bits = ((start >> 16) & 3) | (((end >> 16) & 3) << 8);
	local flag:2 = (bkrepsto_lp() << 15) | start_end_bits:2;

	R0425_0 = R0425_0 - 1;
	MemR0425_0 = counter;
	R0425_0 = R0425_0 - 1;
	MemR0425_0 = start:2;
	R0425_0 = R0425_0 - 1;
	MemR0425_0 = end:2;
	R0425_0 = R0425_0 - 1;
	MemR0425_0 = flag;
}
# 9468h TL2 bkrepsto MemSp, Unused3@0
op:"bkrepsto" MemSp is opcode_3_15=(0x9468>>3) & unused_0_2 & MemSp {
	local counter:2 = bkrepsto_counter();
	local start:3 = bkrepsto_start();
	local end:3 = bkrepsto_end();
	local start_end_bits = ((start >> 16) & 3) | (((end >> 16) & 3) << 8);
	local flag:2 = (bkrepsto_lp() << 15) | start_end_bits:2;

	sp = sp - 1;
	MemSp = counter;
	sp = sp - 1;
	MemSp = start:2;
	sp = sp - 1;
	MemSp = end:2;
	sp = sp - 1;
	MemSp = flag;
}
@endif
# 4180h TL  br   Address18@16and4, Cond@0
op:"br" CodeAddress18_16and4, Cond_0 is opcode_6_15=(0x418>>2) ... & Cond_0 ... & CodeAddress18_16and4 {
	if (Cond_0) goto CodeAddress18_16and4;
}
op:"br" CodeAddress18_16and4 is opcode_6_15=(0x418>>2) ... & cond_0=0 ... & CodeAddress18_16and4 { goto CodeAddress18_16and4; }
# D3C0h TL  break               ;break
# Only changes the loop stack depth; no jumping
# https://github.com/wwylele/teakra/blob/01db7cdd00aabcce559a8dddce8798dabb71949b/src/interpreter.h#L1111-L1116
op:"break" is opcode_0_15=0xD3C0 [
	loopstackdepth = loopstackdepth - 1;
	globalset(inst_next, loopstackdepth);
] {}
# 5000h TL  brr  RelAddr7@4, Cond@0
op:"brr" RelCodeAddr7_4, Cond_0 is opcode_11_15=(0x50>>3) & RelCodeAddr7_4 & Cond_0 {
	if (Cond_0) goto RelCodeAddr7_4;
}
op:"brr" RelCodeAddr7_4 is opcode_11_15=(0x50>>3) & RelCodeAddr7_4 & cond_0=0 { goto RelCodeAddr7_4; }
# 41C0h TL  call Address18@16and4, Cond@0
op:"call" CodeAddress18_16and4, Cond_0 is opcode_6_15=(0x41C>>2) ... & Cond_0 ... & CodeAddress18_16and4 {
	if (!Cond_0) goto inst_next;
	call CodeAddress18_16and4;
}
op:"call" CodeAddress18_16and4 is opcode_6_15=(0x41C>>2) ... & cond_0=0 ... & CodeAddress18_16and4 { call CodeAddress18_16and4; }
# D480h TL  calla Axl@8
op:"calla" Axl_8 is opcode_9_15=(0xD4>>1) & Axl_8 & opcode_0_7=0x80 {
	call [Axl_8];
}
@ifdef TEAK_LITE_2
# D381h TL2 calla Ax@4
op:"calla" Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=1 {
	call [Ax_4];
}
@endif
# 1000h TL  callr RelAddr7@4, Cond@0
op:"brr" RelCodeAddr7_4, Cond_0 is opcode_11_15=(0x10>>3) & RelCodeAddr7_4 & Cond_0 {
	if (!Cond_0) goto inst_next;
	call RelCodeAddr7_4;
}
op:"brr" RelCodeAddr7_4 is opcode_11_15=(0x10>>3) & RelCodeAddr7_4 & cond_0=0 { call RelCodeAddr7_4; }
@ifdef TEAK_LITE_2
# 9068h TL2 cbs  Axh@0, Axh@not0, r0, ge
op:"cbs" Axh_0, Axh_Not0, r0, "ge" is opcode_1_15=(0x9068>>1) & Axh_0 & Axh_Not0 & r0 unimpl
# 9168h TL2 cbs  Axh@0, Axh@not0, r0, gt
op:"cbs" Axh_0, Axh_Not0, r0, "gt" is opcode_1_15=(0x9168>>1) & Axh_0 & Axh_Not0 & r0 unimpl
# D49Eh TL2 cbs  Axh@8, Bxh@5, r0, ge
op:"cbs" Axh_8, Bxh_5, r0, "ge" is opcode_9_15=(0xD4>>1) & Axh_8 & opcode_6_7=(0x9>>2) & Bxh_5 & opcode_0_4=(0x1E) & r0 unimpl
# D49Fh TL2 cbs  Axh@8, Bxh@5, r0, gt
op:"cbs" Axh_8, Bxh_5, r0, "gt" is opcode_9_15=(0xD4>>1) & Axh_8 & opcode_6_7=(0x9>>2) & Bxh_5 & opcode_0_4=(0x1F) & r0 unimpl
# D5C0h TL2 cbs  MemR01@2, MemR45@2, ge || R01@2stepII2@0, R45@2stepII2@1
op:"cbs" MemR01_2, MemR45_2, "ge" || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_3_15=(0xD5C0>>3) & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
# D5C8h TL2 cbs  MemR01@2, MemR45@2, gt || R01@2stepII2@0, R45@2stepII2@1
op:"cbs" MemR01_2, MemR45_2, "gt" || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_3_15=(0xD5C8>>3) & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 unimpl
@endif
# E500h TL  chng Imm16@16, MemImm8@0
macro CHNG(dest, a, b) {
	local result:2 = a ^ b;
	FLAGS16(result);
	dest = result;
}
op:"chng" Imm16, MemImm8_0 is opcode_8_15=0xE5 & MemImm8_0; Imm16 { CHNG(MemImm8_0, MemImm8_0, Imm16); }
# 84E0h TL  chng Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"chng" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x84E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { CHNG(MemRn_0, MemRn_0, Imm16); build Rn_0_stepZIDS_3; }
# 85E0h TL  chng Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 AND also weird behavior for writing to [ab][01][lh], not currently implemented
op:"chng" Imm16, Register_0_Write is opcode_5_15=(0x85E>>1) & Register_0_Read_No_Saturate & Register_0_Write & Register_0_Write_After; Imm16 { CHNG(Register_0_Write, Register_0_Read_No_Saturate, Imm16); build Register_0_Write_After; }
@ifdef TEAK_LITE_2
# 47BAh TL2 chng Imm16@16, r6
op:"chng" Imm16, r6 is opcode_0_15=0x47BA & r6; Imm16 { CHNG(r6, r6, Imm16); }
# 0038h TL2 chng Imm16@16, SttMod@0
op:"chng" Imm16, SttMod_0 is opcode_3_15=(0x0038>>3) & SttMod_0; Imm16 { CHNG(SttMod_0, SttMod_0, Imm16); }
@endif
# 6760h TL  clr  Implied ConstZero, Ax@12, Cond@0  ;aX=0
op:"clr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x76) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = 0;
	FLAGS40(Ax_12);
}
op:"clr" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x76) & cond_0=0 { Ax_12 = 0; }
# 6F60h TL  clr  Implied ConstZero, Bx@12, Cond@0  ;bX=0
op:"clr" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF6) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = 0;
	FLAGS40(Bx_12);
}
op:"clr" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF6) & cond_0=0 { Bx_12 = 0; }
@ifdef TEAK_LITE_2
# 8ED0h TL2 clr  Implied ConstZero, Ab@2, Ab@0
# TODO: teakra FilterDoubleClr indicates some weird stuff happens for Ab_2=b0/b1 or a lot of other cases
op:"clr" Ab_2, Ab_0 is opcode_4_15=0x8ED & Ab_2 & Ab_0 {
	Ab_2 = 0;
	FLAGS40(Ab_2);
	Ab_0 = 0;
	FLAGS40(Ab_0);
}
# 5DFEh TL2 clrp p0
op:"clrp" p0 is opcode_0_15=0x5DFE & p0 {
	p0 = 0;
}
# 5DFFh TL2 clrp p0, p1
op:"clrp" p0, p1 is opcode_0_15=0x5DFF & p0 & p1 {
	p0 = 0;
	p1 = 0;
}
# 5DFDh TL2 clrp p1
op:"clrp" p1 is opcode_0_15=0x5DFD & p1 {
	p1 = 0;
}
@endif
# 67C0h TL  clrr Implied Const8000h, Ax@12, Cond@0 ;aX=8000h
op:"clrr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7C & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = 0x8000;
	FLAGS40(Ax_12);
}
op:"clrr" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7C & cond_0=0 { Ax_12 = 0x8000; }
@ifdef TEAK_LITE_2
# 6F70h TL2 clrr Implied Const8000h, Bx@12, Cond@0 ;bX=8000h
op:"clrr" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF7 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = 0x8000;
	FLAGS40(Bx_12);
}
op:"clrr" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF7 & cond_0=0 { Bx_12 = 0x8000; }
# 8DD0h TL2 clrr Implied Const8000h, Ab@2, Ab@0
# TODO: teakra FilterDoubleClr indicates some weird stuff happens for Ab_2=b0/b1 or a lot of other cases
op:"clrr" Ab_2, Ab_0 is opcode_4_15=0x8DD & Ab_2 & Ab_0 {
	Ab_2 = 0x8000;
	FLAGS40(Ab_2);
	Ab_0 = 0x8000;
	FLAGS40(Ab_0);
}
@endif
# D4FEh TL  cmp  MemImm16@16, Ax@8
op:"cmp" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xFE; MemImm16 { FLAGS_SUB40(Ax_8, sext(MemImm16)); }
# AC00h TL  cmp  MemImm8@0, Ax@8
op:"cmp" MemImm8_0, Ax_8 is opcode_9_15=(0xAC>>1) & Ax_8 & MemImm8_0 { FLAGS_SUB40(Ax_8, sext(MemImm8_0)); }
# 8CC0h TL  cmp  Imm16@16, Ax@8
op:"cmp" Imm16, Ax_8 is opcode_9_15=(0x8C>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { FLAGS_SUB40(Ax_8, sext(Imm16)); }
# CC00h TL  cmp  Imm8u@0, Ax@8
op:"cmp" Imm8u_0, Ax_8 is opcode_9_15=(0xCC>>1) & Ax_8 & Imm8u_0 { FLAGS_SUB40(Ax_8, zext(Imm8u_0)); }
# D4DEh TL  cmp  MemR7Imm16@16, Ax@8
op:"cmp" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDE; MemR7Imm16 { FLAGS_SUB40(Ax_8, sext(MemR7Imm16)); }
# 4C00h TL  cmp  MemR7Imm7s@0, Ax@8
op:"cmp" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x4C>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { FLAGS_SUB40(Ax_8, sext(MemR7Imm7s_0)); }
# 8C80h TL  cmp  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"cmp" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x8C>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { FLAGS_SUB40(Ax_8, sext(MemRn_0)); build Rn_0_stepZIDS_3; }
# 8CA0h TL  cmp  RegisterP0@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"cmp" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x8C)>>1 & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { FLAGS_SUB40(Ax_8, sext(Register_0_Read_No_Saturate)); }
@ifdef TEAK_LITE_2
# 4D8Ch TL2 cmp  Ax@1, Bx@0
op:"cmp" Ax_1, Bx_0 is opcode_2_15=(0x4D8C>>2) & Ax_1 & Bx_0 { FLAGS_SUB40(Bx_0, Ax_1); }
# D483h TL2 cmp  b0, b1
op:"cmp" b0, b1 is opcode_0_15=0xD483 & b0 & b1 { FLAGS_SUB40(b1, b0); }
# D583h TL2 cmp  b1, b0
op:"cmp" b1, b0 is opcode_0_15=0xD583 & b0 & b1 { FLAGS_SUB40(b0, b1); }
# DA9Ah TL2 cmp  Bx@10, Ax@0
op:"cmp" Bx_10, Ax_0 is opcode_11_15=(0xDA>>3) & Bx_10 & opcode_1_9=(0x29A>>1) & Ax_0 { FLAGS_SUB40(Ax_0, Bx_10); }
# 8B63h TL2 cmp  p1, Ax@4
op:"cmp" p1, Ax_4 is opcode_5_15=(0x8B6>>1) & Ax_4 & opcode_0_3=0x3 & p1 { FLAGS_SUB40(Ax_4, p1); }
# D38Eh TL2 cmp  r6, Ax@4
op:"cmp" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xE & r6 { FLAGS_SUB40(Ax_4, sext(r6)); }
@endif
# BE00h TL  cmpu MemImm8@0, Ax@8
op:"cmpu" MemImm8_0, Ax_8 is opcode_9_15=(0xBE>>1) & Ax_8 & MemImm8_0 { FLAGS_SUB40(Ax_8, zext(MemImm8_0)); }
# 9E80h TL  cmpu MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"cmpu" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x9E>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { FLAGS_SUB40(Ax_8, zext(MemRn_0)); build Rn_0_stepZIDS_3; }
# 9EA0h TL  cmpu Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"cmpu" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x9E>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { FLAGS_SUB40(Ax_8, zext(Register_0_Read_No_Saturate)); }
@ifdef TEAK_LITE_2
# 8A63h TL2 cmpu r6, Ax@3
op:"cmpu" r6, Ax_3 is opcode_4_15=0x8A6 & Ax_3 & opcode_0_2=3 & r6 { FLAGS_SUB40(Ax_3, zext(r6)); }
@endif
# ED00h TL  cmpv Imm16@16, MemImm8@0
op:"cmpv" Imm16, MemImm8_0 is opcode_8_15=0xED & MemImm8_0; Imm16 { FLAGS_SUB16(MemImm8_0, Imm16); }
# 8CE0h TL  cmpv Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"cmpv" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x8CE>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { FLAGS_SUB16(MemRn_0, Imm16); build Rn_0_stepZIDS_3; }
# 8DE0h TL  cmpv Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 (the weird behavior for writing to [ab][01][lh] doesn't apply since cmpv doesn't write)
op:"cmpv" Imm16, Register_0_Read_No_Saturate is opcode_5_15=(0x8DE>>1) & Register_0_Read_No_Saturate; Imm16 { FLAGS_SUB16(Register_0_Read_No_Saturate, Imm16); }
@ifdef TEAK_LITE_2
# 47BEh TL2 cmpv Imm16@16, r6
op:"cmpv" Imm16, r6 is opcode_0_15=0x47BE & r6; Imm16 { FLAGS_SUB16(r6, Imm16); }
@endif
# D390h TL  cntx r  ;restore shadows
op:"cntx" "r" is opcode_0_15=0xD390 unimpl
# D380h TL  cntx s  ;store shadows
op:"cntx" "s" is opcode_0_15=0xD380 unimpl
# 67F0h TL  copy Implied Ax@not12,   Ax@12, Cond@0 ;aX=aY
op:"copy" Ax_Not12, Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & Ax_Not12 & opcode_4_11=0x7F & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = Ax_Not12;
	FLAGS40(Ax_12);
	# TODO: saturation
}
op:"copy" Ax_Not12, Ax_12 is opcode_13_15=(6>>1) & Ax_12 & Ax_Not12 & opcode_4_11=0x7F & cond_0=0 {
	Ax_12 = Ax_Not12;
	FLAGS40(Ax_12);
	# TODO: saturation
}
# 67E0h TL  dec  Implied Const1,     Ax@12, Cond@0 ;aX=aX-1
op:"dec" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7E & Cond_0 {
	if (!Cond_0) goto inst_next;
	SUB40(Ax_12, 1);
}
op:"dec" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7E & cond_0=0 { SUB40(Ax_12, 1); }
# 43C0h TL  dint        ;IE=0, interrupt disable
define pcodeop disable_interrupts;
op:"dint" is opcode_0_15=0x43C0 { disable_interrupts(); }
# 0E00h TL  divs MemImm8@0, Ax@8
define pcodeop division_step;
op:"divs" MemImm8_0, Ax_8 is opcode_9_15=(0x0E>>1) & Ax_8 & MemImm8_0 {
	Ax_8 = division_step(Ax_8, MemImm8_0);
	FLAGS40(Ax_8);
}
# 4380h TL  eint        ;IE=1, interrupt enable
define pcodeop enable_interrupts;
op:"eint" is opcode_0_15=0x4380 { enable_interrupts(); }
# 9460h TL  exp  Bx@0, Implied sv
define pcodeop exp;
op:"exp" Bx_0, sv is opcode_1_15=(0x9460>>1) & Bx_0 & sv {
	sv = exp(Bx_0);
}
# 9060h TL  exp  Bx@0, Implied sv, Ax@8
op:"exp" Bx_0, sv, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_1_7=(0x60>>1) & Bx_0 & sv {
	sv = exp(Bx_0);
	Ax_8 = sext(sv);
}
# 9C40h TL  exp  MemRn@0, Implied sv || Rn@0stepZIDS@3
op:"exp" MemRn_0, sv || Rn_0_stepZIDS_3 is opcode_5_15=(0x9C4>>1) & Rn_0_stepZIDS_3 & MemRn_0 & sv {
	local tmp:5 = sext(MemRn_0) << 16;
	sv = exp(tmp);
	build Rn_0_stepZIDS_3;
}
# 9840h TL  exp  MemRn@0, Implied sv, Ax@8 || Rn@0stepZIDS@3
op:"exp" MemRn_0, sv, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(4>>1) & Rn_0_stepZIDS_3 & MemRn_0 & sv {
	local tmp:5 = sext(MemRn_0) << 16;
	sv = exp(tmp);
	Ax_8 = sext(sv);
	build Rn_0_stepZIDS_3;
}
# 9040h TL  exp  RegisterP0@0, Implied sv, Ax@8
# TODO: teakra exp indicates special behavior for Register_0 a0 and a1 (but not p)
op:"exp" Register_0_Read_No_Saturate, sv, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(4>>1) & Register_0_Read_No_Saturate & sv {
	local tmp:5 = sext(Register_0_Read_No_Saturate) << 16;
	sv = exp(tmp);
	Ax_8 = sext(sv);
}
# 9440h TL  exp  RegisterP0@0, Implied sv
# TODO: teakra exp indicates special behavior for Register_0 a0 and a1 (but not p)
op:"exp" Register_0_Read_No_Saturate, sv is opcode_5_15=(0x944>>1) & Register_0_Read_No_Saturate & sv {
	local tmp:5 = sext(Register_0_Read_No_Saturate) << 16;
	sv = exp(tmp);
}
@ifdef TEAK_LITE_2
# D7C1h TL2 exp  r6, Implied sv
op:"exp" r6, sv is opcode_0_15=0xD7C1 & r6 & sv {
	local tmp:5 = sext(r6) << 16;
	sv = exp(tmp);
}
# D382h TL2 exp  r6, Implied sv, Ax@4
op:"exp" r6, sv, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=2 & r6 & sv {
	local tmp:5 = sext(r6) << 16;
	sv = exp(tmp);
	Ax_4 = sext(sv);
}
@endif
# 67D0h TL  inc  Implied Const1,     Ax@12, Cond@0 ;aX=aX+1
op:"inc" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7D & Cond_0 {
	if (!Cond_0) goto inst_next;
	ADD40(Ax_12, 1);
}
op:"inc" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7D & cond_0=0 { ADD40(Ax_12, 1);}
# 49C0h TL  lim  a0     ;aka a0,a0
op:"lim" a0 is opcode_0_15=0x49C0 & a0 {
	# TODO: this should unconditionally saturate - not currently implemented
	a0 = a0;
}
# 49D0h TL  lim  a0, a1
op:"lim" a0, a1 is opcode_0_15=0x49D0 & a0 & a1 {
	# TODO: this should unconditionally saturate - not currently implemented
	a1 = a0;
}
# 49F0h TL  lim  a1     ;aka a1,a1
op:"lim" a1 is opcode_0_15=0x49F0 & a1 {
	# TODO: this should unconditionally saturate - not currently implemented
	a1 = a1;
}
# 49E0h TL  lim  a1, a0
op:"lim" a1, a0 is opcode_0_15=0x49E0 & a0 & a1 {
	# TODO: this should unconditionally saturate - not currently implemented
	a0 = a1;
}
# 4D80h TL  load Imm2u@0, ps               ;st1.bit11-10=imm2
op:"load" Imm2u_0, "ps" is opcode_2_15=(0x4D80>>2) & Imm2u_0 unimpl
# DB80h TL  load Imm7s@0, stepi            ;cfgi.LSB=imm7
op:"load" Imm7s_0, stepi is opcode_7_15=(0xDB8>>3) & Imm7s_0 & stepi {
	stepi = Imm7s_0;
}
# DF80h TL  load Imm7s@0, stepj            ;cfgj.LSB=imm7
op:"load" Imm7s_0, stepj is opcode_7_15=(0xDF8>>3) & Imm7s_0 & stepj {
	stepj = Imm7s_0;
}
# 0400h TL  load Imm8u@0, page             ;st1.LSBs=imm8 ;aka "lpg"
op:"load" Imm8u_0, "page" is opcode_8_15=0x04 & Imm8u_0 unimpl
# 0200h TL  load Imm9u@0, modi             ;cfgi.MSB=imm9
op:"load" Imm9u_0, "modi" is opcode_9_15=(0x02>>1) & Imm9u_0 unimpl
# 0A00h TL  load Imm9u@0, modj             ;cfgj.MSB=imm9
op:"load" Imm9u_0, "modj" is opcode_9_15=(0x0A>>1) & Imm9u_0 unimpl
@ifdef TEAK_LITE_2
# D7D8h TL2 load Imm2u@1, movpd, Unused1@0 ;stt2.bit6.7 (page for ProgMem)
op:"load" Imm2u_1, "movpd", unused_0_0 is opcode_3_15=(0xD7D8>>3) & Imm2u_1 & unused_0_0 unimpl
# 0010h TL2 load Imm4u@0, ps01             ;mod0.bit10-11,13-14 and st1.10-11 ?
op:"load" Imm4u_0, "ps01" is opcode_4_15=0x001 & Imm4u_0 unimpl
@endif
# D400h TL  maa  MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
# teakra DoMultiplication
op:"maa" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x40>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8400h TL  maa  MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"maa" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x40>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_11, p0 s>> 16);
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8420h TL  maa  y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"maa" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x42>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	x0 = MemRn_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8440h TL  maa  y0, Register@0, Ax@11
# teakra mul_y0 indicates no special behavior for Register_0
op:"maa" y0, Register_0_Read_No_Saturate, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x44>>2) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# E400h TL  maa  y0, MemImm8@0, Ax@11
op:"maa" y0, MemImm8_0, Ax_11 is opcode_12_15=0xE & Ax_11 & opcode_8_10=0x4 & MemImm8_0 & y0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	x0 = MemImm8_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EA8h TL2 maa  y0, r6, Ax@0
op:"maa" y0, r6, Ax_0 is opcode_1_15=(0x5EA8>>1) & Ax_0 & y0 & r6 & Y0_input {
	ADD40(Ax_0, p0 s>> 16);
	x0 = r6;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
@endif
# D700h TL  maasu MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"maasu" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x70>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8700h TL  maasu MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"maasu" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x70>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_11, p0 s>> 16);
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8720h TL  maasu y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"maasu" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x72>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	x0 = MemRn_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8740h TL  maasu y0, Register@0, Ax@11
op:"maasu" y0, Register_0_Read_No_Saturate, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x74>>2) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_11, p0 s>> 16);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EAEh TL2 maasu y0, r6, Ax@0
op:"maasu" y0, r6, Ax_0 is opcode_1_15=(0x5EAE>>1) & Ax_0 & y0 & r6 & Y0_input {
	ADD40(Ax_0, p0 s>> 16);
	x0 = r6;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
}
@endif
# D200h TL  mac  MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"mac" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x20>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_11, p0);
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8200h TL  mac  MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"mac" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x20>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_11, p0);
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8220h TL  mac  y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"mac" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x22>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = MemRn_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8240h TL  mac  y0, Register@0, Ax@11
op:"mac" y0, Register_0_Read_No_Saturate, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x24>>2) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# E200h TL  mac  y0, MemImm8@0, Ax@11
op:"mac" y0, MemImm8_0, Ax_11 is opcode_12_15=0xE & Ax_11 & opcode_8_10=0x2 & MemImm8_0 & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = MemImm8_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EA4h TL2 mac  y0, r6, Ax@0
op:"mac" y0, r6, Ax_0 is opcode_1_15=(0x5EA4>>1) & Ax_0 & y0 & r6 & Y0_input {
	ADD40(Ax_0, p0);
	x0 = r6;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# 4D84h TL2 mac  y0, x1, Ax@1, Unused1@0
op:"mac" y0, x1, Ax_1, unused_0_0 is opcode_2_15=(0x4D84>>2) & Ax_1 & unused_0_0 & y0 & x1 & Y0_input {
	ADD40(Ax_1, p0);
	x0 = x1;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# 5E28h TL2 mac1 MemR45@2, MemR01@2, Ax@8 || R01@2stepII2@0, R45@2stepII2@1
op:"mac1" MemR45_2, MemR01_2, Ax_8 || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_9_15=(0x5E>>1) & Ax_8 & opcode_3_7=(0x28>>3) & MemR45_2 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 & Y1_input {
	ADD40(Ax_8, p1);
	y1 = MemR45_2;
	x1 = MemR01_2;
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R45_2_stepII2_1;
	build R01_2_stepII2_0;
}
@endif
# D600h TL  macsu MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"macsu" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x60>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_11, p0);
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8600h TL  macsu MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"macsu" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x60>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_11, p0);
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8620h TL  macsu y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"macsu" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x62>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = MemRn_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8640h TL  macsu y0, Register@0, Ax@11
op:"macsu" y0, Register_0_Read_No_Saturate, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x64>>2) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
}
# E600h TL  macsu y0, MemImm8@0, Ax@11
# NOTE: was listed between 8600h and 8620h in nocash docs, unlike the other variants
op:"macsu" y0, MemImm8_0, Ax_11 is opcode_12_15=0xE & Ax_11 & opcode_8_10=0x6 & MemImm8_0 & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = MemImm8_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EACh TL2 macsu y0, r6, Ax@0
op:"macsu" y0, r6, Ax_0 is opcode_1_15=(0x5EAC>>1) & Ax_0 & y0 & r6 & Y0_input {
	ADD40(Ax_0, p0);
	x0 = r6;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
}
@endif
# D300h TL  macus MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"macus" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x30>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_11, p0);
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(sext(x0), zext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8300h TL  macus MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"macus" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x30>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_11, p0);
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(sext(x0), zext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8320h TL  macus y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"macus" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x32>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = MemRn_0;
	MULTIPLY(sext(x0), zext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8340h TL  macus y0, Register@0, Ax@11
op:"macus" y0, Register_0_Read_No_Saturate, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x34>>2) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(sext(x0), zext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EA6h TL2 macus y0, r6, Ax@0
op:"macus" y0, r6, Ax_0 is opcode_1_15=(0x5EA6>>1) & Ax_0 & y0 & r6 & Y0_input {
	ADD40(Ax_0, p0);
	x0 = r6;
	MULTIPLY(sext(x0), zext(Y0_input), p0);
}
@endif
# D500h TL  macuu MemR45@2, MemR0123@0, Ax@11
#            || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"macuu" MemR45_2, MemR0123_0, Ax_11 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_12_15=0xD & Ax_11 & opcode_7_10=(0x50>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_11, p0);
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(zext(x0), zext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8500h TL  macuu MemRn@0, Imm16@16, Ax@11 || Rn@0stepZIDS@3
op:"macuu" MemRn_0, Imm16, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x50>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_11, p0);
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(zext(x0), zext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8520h TL  macuu y0, MemRn@0, Ax@11 || Rn@0stepZIDS@3
op:"macuu" y0, MemRn_0, Ax_11 || Rn_0_stepZIDS_3 is opcode_12_15=0x8 & Ax_11 & opcode_5_10=(0x52>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = MemRn_0;
	MULTIPLY(zext(x0), zext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8540h TL  macuu y0, Register@0, Ax@11
op:"macuu" y0, Register_0_Read_No_Saturate, Ax_11 is opcode_12_15=0x8 & Ax_11 & opcode_6_10=(0x54>>2) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_11, p0);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(zext(x0), zext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EAAh TL2 macuu y0, r6, Ax@0
op:"macuu" y0, r6, Ax_0 is opcode_1_15=(0x5EAA>>1) & Ax_0 & y0 & r6 & Y0_input {
	ADD40(Ax_0, p0);
	x0 = r6;
	MULTIPLY(zext(x0), zext(Y0_input), p0);
}
@endif
# 8460h TL  max  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, ge,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY >= aX
op:"max" Ax_8, Ax_Not8, r0, "ge", mixp || R0_stepZIDS_3 is opcode_9_15=(0x84>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp {
	$(FLAG_M) = (Ax_Not8 s>= Ax_8);
	if (!$(FLAG_M)) goto <done>;
	Ax_8 = Ax_Not8;
	mixp = r0;
	<done>
	build R0_stepZIDS_3;
}
# 8660h TL  max  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, gt,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY > aX
op:"max" Ax_8, Ax_Not8, r0, "gt", mixp || R0_stepZIDS_3 is opcode_9_15=(0x86>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp {
	$(FLAG_M) = (Ax_Not8 s> Ax_8);
	if (!$(FLAG_M)) goto <done>;
	Ax_8 = Ax_Not8;
	mixp = r0;
	<done>
	build R0_stepZIDS_3;
}
@ifdef TEAK_LITE_2
# 5E21h TL2 max  a0h, a1h || max a0l, a1l || vtrshr
# 5F21h TL2 max  a1h, a0h || max a1l, a0l || vtrshr
# NOTE: nocash doesn't merge this, but it does merge 43C2h (the equivalent min instruction)
macro MAX_VTRSHR(a, b) {
	local a_high_tmp:5 = (a s>> 16);
	local b_high_tmp:5 = (b s>> 16);
	local a_high:3 = a_high_tmp:3;
	local b_high:3 = b_high_tmp:3;
	local a_low:2 = a:2;
	local b_low:2 = b:2;

	$(FLAG_C) = b_high s>= a_high;
	$(FLAG_C1) = b_low s>= a_low;

	local result_high:3 = b_high;
	if ($(FLAG_C)) goto <b_high_greater>;
	result_high = a_high;
	<b_high_greater>

	local result_low:2 = b_low;
	if ($(FLAG_C1)) goto <b_low_greater>;
	result_low = a_low;
	<b_low_greater>

	a = (sext(result_high) << 16) | zext(result_low);
	VTRSHR();
}
op:"max" Axh_8, Axh_Not8 || "max" Axl_8, Axl_Not8 || "vtrshr" is opcode_9_15=(0x5E>>1) & Axh_8 & Axh_Not8 & Axl_8 & Axl_Not8 & Ax_8 & Ax_Not8 & opcode_0_7=0x21 { MAX_VTRSHR(Ax_8, Ax_Not8); }
# D784h TL2 max  Axh@1, Bxh@0 || max Axl@1, Bxl@0 || vtrshr
op:"max" Axh_1, Bxh_0 || "max" Axl_1, Bxl_0 || "vtrshr" is opcode_2_15=(0xD784>>2) & Axh_1 & Axl_1 & Bxh_0 & Bxl_0 & Ax_1 & Bx_0 { MAX_VTRSHR(Ax_1, Bx_0); }
# 4A40h TL2 max  Axh@3, Bxh@4 || max Axl@3, Bxl@4 || mov Axl@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: bit 2 chooses between Axl_Not3 and Axh_Not3 - this could be merged (teakra doesn't though)
op:"max" Axh_3, Bxh_4 || "max" Axl_3, Bxl_4 || "mov" Axl_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A4>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axl_Not3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 & Ax_3 & Bx_4
{
	MAX_VTRSHR(Ax_3, Bx_4);
	MemR04_1 = Axl_Not3; # TODO: saturation
	build R04_1_stepII2_0;
}
# 4A44h TL2 max  Axh@3, Bxh@4 || max Axl@3, Bxl@4 || mov Axh@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
op:"max" Axh_3, Bxh_4 || "max" Axl_3, Bxl_4 || "mov" Axh_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A4>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axh_Not3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 & Ax_3 & Bx_4
{
	MAX_VTRSHR(Ax_3, Bx_4);
	MemR04_1 = Axh_Not3; # TODO: saturation
	build R04_1_stepII2_0;
}
# 45A0h TL2 max  Axh@4, Bxh@3 || max Axl@4, Bxl@3 || mov Axh@not4, MemR45@2
#            || mov Axl@not4, MemR01@2 || vtrshr
#            || R01@2stepII2@0, R45@2stepII2@1
op:"max" Axh_4, Bxh_3 || "max" Axl_4, Bxl_3 || "mov" Axh_Not4, MemR45_2 || "mov" Axl_Not4, MemR01_2 || "vtrshr" || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x45A>>1) & Axh_4 & Axl_4 & Axh_Not4 & Axl_Not4 & Bxh_3 & Bxl_3 & MemR45_2 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 & Ax_4 & Bx_3
{
	MAX_VTRSHR(Ax_4, Bx_3);
	MemR45_2 = Axh_Not4; # TODO: saturation
	MemR01_2 = Axl_Not4; # TODO: saturation
	build R45_2_stepII2_1;
	build R01_2_stepII2_0;
}
# D590h TL2 max  Axh@6, Bxh@5 || max Axl@6, Bxl@5 || mov Axh@not6, MemR01@2
#            || mov Axl@not6, MemR45@2 || vtrshr
#            || R01@2stepII2@0, R45@2stepII2@1
op:"max" Axh_6, Bxh_5 || "max" Axl_6, Bxl_5 || "mov" Axh_Not6, MemR01_2 || "mov" Axl_Not6, MemR45_2 || "vtrshr" || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_7_15=(0xD59>>3) & Axh_6 & Axl_6 & Axh_Not6 & Axl_Not6 & Bxh_5 & Bxl_5 & opcode_3_4=2 & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 & Ax_6 & Bx_5
{
	MAX_VTRSHR(Ax_6, Bx_5);
	MemR01_2 = Axh_Not6;
	MemR45_2 = Axl_Not6;
	build R45_2_stepII2_1;
	build R01_2_stepII2_0;
}
# 4A60h TL2 max  Bxh@4, Axh@3 || max Bxl@4, Axl@3 || mov Bxl@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
op:"max" Bxh_4, Axh_3 || "max" Bxl_4, Axl_3 || "mov" Bxl_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A6>>1) & Bxh_4 & Bxl_4 & Bxl_Not4 & Axh_3 & Axl_3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 & Bx_4 & Ax_3
{
	MAX_VTRSHR(Bx_4, Ax_3);
	MemR04_1 = Bxl_Not4;
	build R04_1_stepII2_0;
}
# 4A64h TL2 max  Bxh@4, Axh@3 || max Bxl@4, Axl@3 || mov Bxh@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
op:"max" Bxh_4, Axh_3 || "max" Bxl_4, Axl_3 || "mov" Bxh_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A6>>1) & Bxh_4 & Bxl_4 & Bxh_Not4 & Axh_3 & Axl_3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 & Bx_4 & Ax_3
{
	MAX_VTRSHR(Bx_4, Ax_3);
	MemR04_1 = Bxh_Not4;
	build R04_1_stepII2_0;
}
@endif
# 8060h TL  maxd NoReverse, Ax@8, MemR0, ge, Implied mixp, Implied r0
#            || R0stepZIDS@3   ;when (r0) >= aX
op:"maxd" Ax_8, MemR0, "ge", mixp || R0_stepZIDS_3 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & MemR0 & mixp {
	local other:5 = sext(MemR0);
	$(FLAG_M) = (other s>= Ax_8);
	if (!$(FLAG_M)) goto <done>;
	Ax_8 = other;
	mixp = r0;
	<done>
	build R0_stepZIDS_3;
}
# 8260h TL  maxd NoReverse, Ax@8, MemR0, gt, Implied mixp, Implied r0
#            || R0stepZIDS@3   ;when (r0) > aX
op:"maxd" Ax_8, MemR0, "gt", mixp || R0_stepZIDS_3 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & MemR0 & mixp {
	local other:5 = sext(MemR0);
	$(FLAG_M) = (other s> Ax_8);
	if (!$(FLAG_M)) goto <done>;
	Ax_8 = other;
	mixp = r0;
	<done>
	build R0_stepZIDS_3;
}
# 8860h TL  min  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, le,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY <= aX
# NOTE: matches 8460h
op:"min" Ax_8, Ax_Not8, r0, "le", mixp || R0_stepZIDS_3 is opcode_9_15=(0x88>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp {
	$(FLAG_M) = (Ax_Not8 s<= Ax_8);
	if (!$(FLAG_M)) goto <done>;
	Ax_8 = Ax_Not8;
	mixp = r0;
	<done>
	build R0_stepZIDS_3;
}
# 8A60h TL  min  NoReverse, Ax@8, Implied Ax@not8, Bogus MemR0, lt,
#            Implied mixp, Implied r0 || R0stepZIDS@3   ;when aY < aX
# NOTE: matches 8660h
op:"min" Ax_8, Ax_Not8, r0, "lt", mixp || R0_stepZIDS_3 is opcode_9_15=(0x8A>>1) & Ax_8 & Ax_Not8 & opcode_5_7=(6>>1) & R0_stepZIDS_3 & opcode_0_2=0 & r0 & mixp {
	$(FLAG_M) = (Ax_Not8 s< Ax_8);
	if (!$(FLAG_M)) goto <done>;
	Ax_8 = Ax_Not8;
	mixp = r0;
	<done>
	build R0_stepZIDS_3;
}
@ifdef TEAK_LITE_2
macro MIN_VTRSHR(a, b) {
	local a_high_tmp:5 = (a s>> 16);
	local b_high_tmp:5 = (b s>> 16);
	local a_high:3 = a_high_tmp:3;
	local b_high:3 = b_high_tmp:3;
	local a_low:2 = a:2;
	local b_low:2 = b:2;

	# NOTE: this (s<= instead of s>=) is the only difference from MAX_VTRSHR
	$(FLAG_C) = b_high s<= a_high;
	$(FLAG_C1) = b_low s<= a_low;

	local result_high:3 = b_high;
	if ($(FLAG_C)) goto <b_high_greater>;
	result_high = a_high;
	<b_high_greater>

	local result_low:2 = b_low;
	if ($(FLAG_C1)) goto <b_low_greater>;
	result_low = a_low;
	<b_low_greater>

	a = (sext(result_high) << 16) | zext(result_low);
	VTRSHR();
}
# 43C2h TL2 min  Axh@0, Axh@not0 || min Axl@0, Axl@not0 || vtrshr
op:"min" Axh_0, Axh_Not0 || "min" Axl_0, Axl_Not0 || "vtrshr" is opcode_1_15=(0x43C2>>1) & Axh_0 & Axh_Not0 & Axl_0 & Axl_Not0 & Ax_0 & Ax_Not0 {
	MIN_VTRSHR(Ax_0, Ax_Not0);
}
# D2B8h TL2 min  Axh@11, Bxh@10 || min Axl@11, Bxl@10
#            || mov Axh@not11, MemR01@2 || mov Axl@not11, MemR45@2
#            || vtrshr || R01@2stepII2@0, R45@2stepII2@1
op:"min" Axh_11, Bxh_10 || "min" Axl_11, Bxl_10 || "mov" Axh_Not11, MemR01_2 || "mov" Axl_Not11, MemR45_2 || "vtrshr" || R01_2_stepII2_0 || R45_2_stepII2_1
	is opcode_12_15=0xD & Axh_11 & Axl_11 & Axh_Not11 & Axl_Not11 & Bxh_10 & Bxl_10 & opcode_3_9=(0x2B8>>3) & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 & Ax_11 & Bx_10
{
	MIN_VTRSHR(Ax_11, Bx_10);
	MemR01_2 = Axh_Not11; # TODO: saturation
	MemR45_2 = Axl_Not11; # TODO: saturation
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 4A00h TL2 min  Axh@3, Bxh@4 || min Axl@3, Bxl@4 || mov Axl@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: bit 2 chooses between Axl_Not3 and Axh_Not3 - this could be merged
# NOTE: matches 4A40h
op:"min" Axh_3, Bxh_4 || "min" Axl_3, Bxl_4 || "mov" Axl_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A0>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axl_Not3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 & Ax_3 & Bx_4
{
	MIN_VTRSHR(Ax_3, Bx_4);
	MemR04_1 = Axl_Not3; # TODO: saturation
	build R04_1_stepII2_0;
}
# 4A04h TL2 min  Axh@3, Bxh@4 || min Axl@3, Bxl@4 || mov Axh@not3, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: matches 4A44h
op:"min" Axh_3, Bxh_4 || "min" Axl_3, Bxl_4 || "mov" Axh_Not3, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A0>>1) & Bxh_4 & Bxl_4 & Axh_3 & Axl_3 & Axh_Not3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 & Ax_3 & Bx_4
{
	MIN_VTRSHR(Ax_3, Bx_4);
	MemR04_1 = Axh_Not3; # TODO: saturation
	build R04_1_stepII2_0;
}
# 45E0h TL2 min  Axh@4, Bxh@3 || min Axl@4, Bxl@3 || mov Axh@not4, MemR45@2
#            || mov Axl@not4, MemR01@2 || vtrshr
#            || R01@2stepII2@0, R45@2stepII2@1
# NOTE: matches 45A0h
op:"min" Axh_4, Bxh_3 || "min" Axl_4, Bxl_3 || "mov" Axh_Not4, MemR45_2 || "mov" Axl_Not4, MemR01_2 || "vtrshr" || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x45E>>1) & Axh_4 & Axl_4 & Axh_Not4 & Axl_Not4 & Bxh_3 & Bxl_3 & MemR45_2 & MemR01_2 & R45_2_stepII2_1 & R01_2_stepII2_0 & Ax_4 & Bx_3
{
	MIN_VTRSHR(Ax_4, Bx_3);
	MemR45_2 = Axh_Not4; # TODO: saturation
	MemR01_2 = Axl_Not4; # TODO: saturation
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# D4BAh TL2 min  Axh@8, Bxh@0 || min Axl@8, Bxl@0 || vtrshr
op:"min" Axh_8, Bxh_0 || "min" Axl_8, Bxl_0 || "vtrshr" is opcode_9_15=(0xD4>>1) & Axh_8 & Axl_8 & opcode_1_7=(0xBA>>1) & Bxh_0 & Bxl_0 & Ax_8 & Bx_0 { MIN_VTRSHR(Ax_8, Bx_0); }
# 4A20h TL2 min  Bxh@4, Axh@3 || min Bxl@4, Axl@3 || mov Bxl@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: matches 4A60h
op:"min" Bxh_4, Axh_3 || "min" Bxl_4, Axl_3 || "mov" Bxl_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A2>>1) & Bxh_4 & Bxl_4 & Bxl_Not4 & Axh_3 & Axl_3 & opcode_2_2=0 & MemR04_1 & R04_1_stepII2_0 & Bx_4 & Ax_3
{
	MIN_VTRSHR(Bx_4, Ax_3);
	MemR04_1 = Bxl_Not4; # TODO: saturation
	build R04_1_stepII2_0;
}
# 4A24h TL2 min  Bxh@4, Axh@3 || min Bxl@4, Axl@3 || mov Bxh@not4, MemR04@1
#            || vtrshr || R04@1stepII2@0
# NOTE: matches 4A64h
op:"min" Bxh_4, Axh_3 || "min" Bxl_4, Axl_3 || "mov" Bxh_Not4, MemR04_1 || "vtrshr" || R04_1_stepII2_0
	is opcode_5_15=(0x4A2>>1) & Bxh_4 & Bxl_4 & Bxh_Not4 & Axh_3 & Axl_3 & opcode_2_2=1 & MemR04_1 & R04_1_stepII2_0 & Bx_4 & Ax_3
{
	MIN_VTRSHR(Bx_4, Ax_3);
	MemR04_1 = Bxh_Not4; # TODO: saturation
	build R04_1_stepII2_0;
}
# 47A0h TL2 mind NoReverse, Ax@3, MemR0, le, Implied mixp, Implied r0
#            || R0stepZIDS@0
op:"mind" Ax_3, MemR0, "le", mixp || R0_stepZIDS_0 is opcode_4_15=0x47A & Ax_3 & opcode_2_2=0 & R0_stepZIDS_0 & MemR0 & mixp {
	local other:5 = sext(MemR0);
	$(FLAG_M) = (other s<= Ax_3);
	if (!$(FLAG_M)) goto <done>;
	Ax_3 = other;
	mixp = r0;
	<done>
	build R0_stepZIDS_0;
}
# 47A4h TL2 mind NoReverse, Ax@3, MemR0, lt, Implied mixp, Implied r0
#            || R0stepZIDS@0
op:"mind" Ax_3, MemR0, "lt", mixp || R0_stepZIDS_0 is opcode_4_15=0x47A & Ax_3 & opcode_2_2=1 & R0_stepZIDS_0 & MemR0 & mixp {
	local other:5 = sext(MemR0);
	$(FLAG_M) = (other s< Ax_3);
	if (!$(FLAG_M)) goto <done>;
	Ax_3 = other;
	mixp = r0;
	<done>
	build R0_stepZIDS_0;
}
@endif
# 0080h TL  modr MemRn@0stepZIDS@3
op:"modr" MemRn_0_stepZIDS_3 is opcode_5_15=(0x008>>1) & MemRn_0_stepZIDS_3 & Rn_0 { build MemRn_0_stepZIDS_3; $(FLAG_R) = (Rn_0 == 0); }
# 00A0h TL  modr MemRn@0stepZIDS@3, dmod  ;Disable modulo
op:"modr" MemRn_0_stepZIDS_3,"dmod" is opcode_5_15=(0x00A>>1) & MemRn_0_stepZIDS_3 & Rn_0 { build MemRn_0_stepZIDS_3; $(FLAG_R) = (Rn_0 == 0); } # TODO: dmod
@ifdef TEAK_LITE_2
# NOTE: nocash documentation has a "modrstepII2D2S0" which is what is used here (the difference is
# that one uses stepi/stepj (unclear which) and the other uses stepi0/stepj0 (also unclear which).)
# For whatever reason nocash doesn't use modrstepII2D2S0 in the actual instruction list though.
# D294h TL2 modr MemR0123@10stepII2D2S0@0 || modr MemR4567@10stepII2D2S0@5
op:"modr" MemR0123_10_modrstepII2D2S0_0 || "modr" MemR4567_10_modrstepII2D2S0_5
	is opcode_12_15=0xD & opcode_7_9=(0x29>>3) & MemR4567_10_modrstepII2D2S0_5 & opcode_2_4=(0x14>>2) & MemR0123_10_modrstepII2D2S0_0
{
	build MemR0123_10_modrstepII2D2S0_0;
	build MemR4567_10_modrstepII2D2S0_5;
}
# 0D80h TL2 modr MemR0123@5stepII2D2S0@1  || modr MemR4567@5stepII2D2S0@3, dmod
op:"modr" MemR0123_5_modrstepII2D2S0_1 || "modr" MemR4567_5_modrstepII2D2S0_3, "dmod"
	is opcode_5_15=(0x0D8>>3) & MemR4567_5_modrstepII2D2S0_3 & MemR0123_5_modrstepII2D2S0_1 & opcode_0_0=0
{
	build MemR0123_5_modrstepII2D2S0_1;
	build MemR4567_5_modrstepII2D2S0_3;
}
# 0D81h TL2 modr MemR0123@5stepII2D2S0@1, dmod
#            || modr MemR4567@5stepII2D2S0@3, dmod
# NOTE: identical to 0D80h apart from the first dmod (TODO: which we haven't implemented yet)
op:"modr" MemR0123_5_modrstepII2D2S0_1 || "modr" MemR4567_5_modrstepII2D2S0_3, "dmod"
	is opcode_5_15=(0x0D8>>3) & MemR4567_5_modrstepII2D2S0_3 & MemR0123_5_modrstepII2D2S0_1 & opcode_0_0=1
{
	build MemR0123_5_modrstepII2D2S0_1;
	build MemR4567_5_modrstepII2D2S0_3;
}
# 8464h TL2 modr MemR0123@8stepII2D2S0@0, dmod || modr MemR4567@8stepII2D2S0@3
op:"modr" MemR0123_8_modrstepII2D2S0_0, "dmod" || "modr" MemR4567_8_modrstepII2D2S0_3
	is opcode_10_15=(0x84>>2) & opcode_5_7=(6>>1) & MemR4567_8_modrstepII2D2S0_3 & opcode_2_2=1 & MemR0123_8_modrstepII2D2S0_0
{
	build MemR0123_8_modrstepII2D2S0_0;
	build MemR4567_8_modrstepII2D2S0_3;
}
# TODO: Brackets? (See comment on MemR0123_5_modrstepII2D2S0_1)
# 5DA0h TL2 modr MemRn@0stepD2
op:"modr" MemRn_0-2 is opcode_3_15=(0x5DA0>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 - 2; $(FLAG_R) = (Rn_0 == 0); }
# 5DA8h TL2 modr MemRn@0stepD2, dmod
op:"modr" MemRn_0-2, "dmod" is opcode_3_15=(0x5DA8>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 - 2; $(FLAG_R) = (Rn_0 == 0); }  # TODO: dmod
# 4990h TL2 modr MemRn@0stepI2
op:"modr" MemRn_0+2 is opcode_3_15=(0x4990>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 + 2; $(FLAG_R) = (Rn_0 == 0); }
# 4998h TL2 modr MemRn@0stepI2, dmod
op:"modr" MemRn_0+2, "dmod" is opcode_3_15=(0x4998>>3) & MemRn_0 & Rn_0 { Rn_0 = Rn_0 + 2; $(FLAG_R) = (Rn_0 == 0); }  # TODO: dmod
@endif
# D290h TL  mov  Ab@10, Ab@5
op:"mov" Ab_10, Ab_5 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x29>>3) & Ab_5 & opcode_0_4=0x10 { Ab_5 = Ab_10; FLAGS40(Ab_5); }  # TODO: saturation
# D298h TL  mov  Abl@10, dvm
op:"mov" Abl_10, dvm is opcode_12_15=0xD & Abl_10 & opcode_0_9=0x298 & dvm { dvm = Abl_10; }  # TODO: saturation?
# D2D8h TL  mov  Abl@10, x0
op:"mov" Abl_10, x0 is opcode_12_15=0xD & Abl_10 & opcode_0_9=0x2D8 & x0 { x0 = Abl_10; }  # TODO: saturation
# 3000h TL  mov  Ablh@9, MemImm8@0
op:"mov" Ablh_9, MemImm8_0 is opcode_12_15=0x3 & Ablh_9 & opcode_8_8=0 & MemImm8_0 { MemImm8_0 = Ablh_9; }  # TODO: saturation
# D4BCh TL  mov  Axl@8, MemImm16@16
op:"mov" Axl_8, MemImm16 is opcode_9_15=(0xD4>>1) & Axl_8 & opcode_0_7=0xBC; MemImm16 { MemImm16 = Axl_8; }  # TODO: saturation
# D49Ch TL  mov  Axl@8, MemR7Imm16@16
op:"mov" Axl_8, MemR7Imm16 is opcode_9_15=(0xD4>>1) & Axl_8 & opcode_0_7=0x9C; MemR7Imm16 { MemR7Imm16 = Axl_8; }  # TODO: saturation
# DC80h TL  mov  Axl@8, MemR7Imm7s@0
op:"mov" Axl_8, MemR7Imm7s_0 is opcode_9_15=(0xDC>>1) & Axl_8 & opcode_7_7=1 & MemR7Imm7s_0 { MemR7Imm7s_0 = Axl_8; }  # TODO: saturation
# D4B8h TL  mov  MemImm16@16, Ax@8
op:"mov" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xB8; MemImm16 { Ax_8 = sext(MemImm16); FLAGS40(Ax_8); }  # TODO: saturation
# 6100h TL  mov  MemImm8@0, Ab@11
op:"mov" MemImm8_0, Ab_11 is opcode_13_15=(6>>1) & Ab_11 & opcode_8_10=1 & MemImm8_0 { Ab_11 = sext(MemImm8_0); FLAGS40(Ab_11); }  # TODO: saturation
# 6200h TL  mov  MemImm8@0, Ablh@10
op:"mov" MemImm8_0, Ablh_10 is opcode_13_15=(6>>1) & Ablh_10 & opcode_8_9=2 & MemImm8_0 & Ab_11 { Ablh_10 = MemImm8_0; FLAGS40(Ab_11); }  # TODO: saturation, and also this should clobber the whole accumulator...
# 6500h TL  mov  MemImm8@0, Axh@12, eu   ;aka Axheu
op:"mov" MemImm8_0, Axh_12, "eu" is opcode_13_15=(6>>1) & Axh_12 & opcode_8_11=5 & MemImm8_0 & Axl_12 & Ax_12 { Axh_12 = MemImm8_0; Axl_12 = 0; FLAGS40(Ax_12); }
# 6000h TL  mov  MemImm8@0, R0123457y0@10
op:"mov" MemImm8_0, R0123457y0_10 is opcode_13_15=(6>>1) & R0123457y0_10 & opcode_8_9=0 & MemImm8_0 { R0123457y0_10 = MemImm8_0; }
# 6D00h TL  mov  MemImm8@0, sv
op:"mov" MemImm8_0, sv is opcode_8_15=0x6D & MemImm8_0 & sv { sv = MemImm8_0; }
# D491h TL  mov  dvm, Ab@5
op:"mov" dvm, Ab_5 is opcode_7_15=(0xD49>>3) & Ab_5 & opcode_0_4=0x11 & dvm { Ab_5 = sext(dvm); FLAGS40(Ab_5); }  # TODO: saturation
# D492h TL  mov  icr, Ab@5
op:"mov" icr, Ab_5 is opcode_7_15=(0xD49>>3) & Ab_5 & opcode_0_4=0x12 & icr { Ab_5 = sext(icr); FLAGS40(Ab_5); }  # TODO: saturation
# 5E20h TL  mov  Imm16@16, Bx@8
op:"mov" Imm16, Bx_8 is opcode_9_15=(0x5E>>1) & Bx_8 & opcode_0_7=0x20; Imm16 { Bx_8 = sext(Imm16); FLAGS40(Bx_8); }  # TODO: saturation
# 5E00h TL  mov  Imm16@16, Register@0
op:"mov" Imm16, Register_0_Write is opcode_5_15=(0x5E0>>1) & Register_0_Write & Register_0_Write_After; Imm16 { Register_0_Write = Imm16; build Register_0_Write_After; }
# 4F80h TL  mov  Imm5u@0, icr    ;uh, but icr is 8bit wide (only 4bit are R/W)?
# TODO: comment from nocash
op:"mov" Imm5u_0, icr is opcode_5_15=(0x4F8>>1) & Imm5u_0 & icr { icr = Imm5u_0; }
# 2500h TL  mov  Imm8s@0, Axh@12         ;signed!
op:"mov" Imm8s_0, Axh_12 is opcode_13_15=(2>>1) & Axh_12 & opcode_8_11=5 & Imm8s_0 & Ax_12 { Axh_12 = Imm8s_0; FLAGS40(Ax_12); }  # TODO: saturation, clobber the rest of the accumulator
# 2900h TL  mov  Imm8s@0, ext0
# TODO: ext0 through ext3 could definitely be merged
op:"mov" Imm8s_0, ext0 is opcode_8_15=0x29 & Imm8s_0 & ext0 { ext0 = Imm8s_0; write_ext0(ext0); }
# 2D00h TL  mov  Imm8s@0, ext1
op:"mov" Imm8s_0, ext1 is opcode_8_15=0x2D & Imm8s_0 & ext1 { ext1 = Imm8s_0; write_ext1(ext1); }
# 3900h TL  mov  Imm8s@0, ext2
op:"mov" Imm8s_0, ext2 is opcode_8_15=0x39 & Imm8s_0 & ext2 { ext2 = Imm8s_0; write_ext2(ext2); }
# 3D00h TL  mov  Imm8s@0, ext3
op:"mov" Imm8s_0, ext3 is opcode_8_15=0x3D & Imm8s_0 & ext3 { ext3 = Imm8s_0; write_ext3(ext3); }
# 2300h TL  mov  Imm8s@0, R0123457y0@10  ;signed!
op:"mov" Imm8s_0, R0123457y0_10 is opcode_13_15=(2>>1) & R0123457y0_10 & opcode_8_9=3 & Imm8s_0 { R0123457y0_10 = Imm8s_0; }
# 0500h TL  mov  Imm8s@0, sv
op:"mov" Imm8s_0, sv is opcode_8_15=0x05 & Imm8s_0 & sv { sv = Imm8s_0; }
# 2100h TL  mov  Imm8u@0, Axl@12         ;unsigned!
op:"mov" Imm8u_0, Axl_12 is opcode_13_15=(2>>1) & Axl_12 & opcode_8_11=1 & Imm8u_0 & Ax_12 { Axl_12 = Imm8u_0; FLAGS40(Ax_12); }  # TODO: saturation, clobber the rest of the accumulator
# D498h TL  mov  MemR7Imm16@16, Ax@8
op:"mov" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0x98; MemR7Imm16 { Ax_8 = sext(MemR7Imm16); FLAGS40(Ax_8); }  # TODO: saturation
# D880h TL  mov  MemR7Imm7s@0, Ax@8
op:"mov" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0xD8>>1) & Ax_8 & opcode_7_7=1 & MemR7Imm7s_0 { Ax_8 = sext(MemR7Imm7s_0); FLAGS40(Ax_8); }  # TODO: saturation
# 98C0h TL  mov  MemRn@0, Bx@8 || Rn@0stepZIDS@3
op:"mov" MemRn_0, Bx_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x98>>1) & Bx_8 & opcode_5_7=(0xC>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Bx_8 = sext(MemRn_0); FLAGS40(Bx_8); build Rn_0_stepZIDS_3; }  # TODO: saturation
# 1C00h TL  mov  MemRn@0, Register@5 || Rn@0stepZIDS@3
op:"mov" MemRn_0, Register_5_Write || Rn_0_stepZIDS_3 is opcode_10_15=(0x1C>>2) & Register_5_Write & Register_5_Write_After & Rn_0_stepZIDS_3 & MemRn_0 { Register_5_Write = MemRn_0; build Register_5_Write_After; build Rn_0_stepZIDS_3; }
# 47E0h TL  mov  MemSp, Register@0
op:"mov" MemSp, Register_0_Write is opcode_5_15=(0x47E>>1) & Register_0_Write & Register_0_Write_After & MemSp { Register_0_Write = MemSp; build Register_0_Write_After; }
# 47C0h TL  mov  mixp, Register@0
op:"mov" mixp, Register_0_Write is opcode_5_15=(0x47C>>1) & Register_0_Write & Register_0_Write_After & mixp { Register_0_Write = mixp; build Register_0_Write_After; }
# 2000h TL  mov  R0123457y0@9, MemImm8@0
op:"mov" R0123457y0_9, MemImm8_0 is opcode_12_15=2 & R0123457y0_9 & opcode_8_8=0 & MemImm8_0 { MemImm8_0 = R0123457y0_9; }
# 4FC0h TL  mov  Register@0, icr
op:"mov" Register_0_Read_Saturate, icr is opcode_5_15=(0x4FC>>1) & Register_0_Read_Saturate & icr { icr = Register_0_Read_Saturate; }
# 5E80h TL  mov  Register@0, mixp
op:"mov" Register_0_Read_Saturate, mixp is opcode_5_15=(0x5E8>>1) & Register_0_Read_Saturate & mixp { mixp = Register_0_Read_Saturate; }
# 1800h TL  mov  Register@5, MemRn@0 || Rn@0stepZIDS@3
# NOTE: Register_5 = a0/a1 overridden by r6 moves (see 1B00h and 1B20h)
op:"mov" Register_5_Read_Saturate, MemRn_0 || Rn_0_stepZIDS_3 is opcode_10_15=(0x18>>2) & Register_5_Read_Saturate & Rn_0_stepZIDS_3 & MemRn_0 { MemRn_0 = Register_5_Read_Saturate; build Rn_0_stepZIDS_3; }
# 5EC0h TL  mov  RegisterP0@0, Bx@5
# TODO: teakra indicates special behavior for Register_0 = p / a0 / b0
op:"mov" Register_0_Read_Saturate, Bx_5 is opcode_6_15=(0x5EC>>2) & Bx_5 & Register_0_Read_Saturate { Bx_5 = sext(Register_0_Read_Saturate); FLAGS40(Bx_5); } # TODO: Writing Bx_5 can saturate
# 5800h TL  mov  RegisterP0@0, Register@5
# NOTE: Register_0 = a0/a1 overridden by 5818h/5838h
# TODO: teakra indicates special behavior for Register_0 = p (in which case Register_5 is reduced to only a0 and a1) and Register_0 = pc + Register_5 = a0/a1
op:"mov" Register_0_Read_Saturate, Register_5_Write is opcode_10_15=(0x58>>2) & Register_5_Write & Register_5_Write_After & Register_0_Read_Saturate { Register_5_Write = Register_0_Read_Saturate; build Register_5_Write_After; }
# D490h TL  mov  repc, Ab@5
op:"mov" repc, Ab_5 is opcode_7_15=(0xDA9>>3) & Ab_5 & opcode_0_4=0x10 & repc { Ab_5 = sext(repc); FLAGS40(Ab_5); } # TODO: saturation
# 7D00h TL  mov  sv, MemImm8@0
op:"mov" sv, MemImm8_0 is opcode_8_15=0x7D & MemImm8_0 & sv { MemImm8_0 = sv; }
# D493h TL  mov  x0, Ab@5
op:"mov" x0, Ab_5 is opcode_7_15=(0xD49>>3) & Ab_5 & opcode_0_4=0x13 & x0 { Ab_5 = sext(x0); FLAGS40(Ab_5); } # TODO: saturation
@ifdef TEAK_LITE_2
# D49Bh TL2 mov  a0h, stepi0
op:"mov" a0h, stepi0 is opcode_0_15=0xD49B & a0h & stepi0 { stepi0 = a0h; } # TODO: saturation
# D59Bh TL2 mov  a0h, stepj0
op:"mov" a0h, stepj0 is opcode_0_15=0xD59B & a0h & stepj0 { stepj0 = a0h; } # TODO: saturation
# 4390h TL2 mov  a0h, MemR0425@2 || mov y0, MemR0425@2offsZIDZ@0
#            || R0425@2stepII2D2S@0
# 43D0h TL2 mov  a1h, MemR0425@2 || mov y0, MemR0425@2offsZIDZ@0
#            || R0425@2stepII2D2S@0
# merged by teakra
op:"mov" Axh_6, MemR0425_2 || "mov" y0, MemR0425_2_offsZIDZ_0 || R0425_2_stepII2D2S_0 is opcode_4_15=0x439 & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0 & Axh_6 & y0 {
	MemR0425_2_offsZIDZ_0 = y0;
	MemR0425_2 = Axh_6; # TODO: saturation
	build R0425_2_stepII2D2S_0;
}
# 8FD4h TL2 mov  Ab@0, p0
op:"mov" Ab_0, p0 is opcode_2_15=(0x8FD4>>2) & Ab_0 & p0 { p0 = Ab_0; } # TODO: saturation
# 43A0h TL2 mov  Abh@3, MemR01@2 || mov Abl@3, MemR45@2
#            || R01@2stepII2@0, R45@2stepII2@1
op:"mov" Abh_3, MemR01_2 || "mov" Abl_3, MemR45_2 || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_5_15=(0x43A>>1) & Abh_3 & Abl_3 & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 {
	MemR01_2 = Abh_3; # TODO: saturation
	MemR45_2 = Abl_3; # TODO: saturation
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 43E0h TL2 mov  Abh@3, MemR45@2 || mov Abl@3, MemR01@2
#            || R01@2stepII2@0, R45@2stepII2@1
op:"mov" Abh_3, MemR45_2 || "mov" Abl_3, MemR01_2 || R01_2_stepII2_0, R45_2_stepII2_1 is opcode_5_15=(0x43E>>1) & Abh_3 & Abl_3 & MemR01_2 & MemR45_2 & R45_2_stepII2_1 & R01_2_stepII2_0 {
	MemR45_2 = Abh_3; # TODO: saturation
	MemR01_2 = Abl_3; # TODO: saturation
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 9D40h TL2 mov  Abh@4, MemR04@1 || mov Abh@2, MemR04@1offsZI@0
#            || R04@1stepII2@0
op:"mov" Abh_4, MemR04_1 || "mov" Abh_2, MemR04_1_offsZI_0 || R04_1_stepII2_0 is opcode_6_15=(0x9D4>>2) & Abh_4 & Abh_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 {
	MemR04_1_offsZI_0 = Abh_2; # TODO: saturation
	MemR04_1 = Abh_4; # TODO: saturation
	build R04_1_stepII2_0;
}
# 9164h TL2 mov  Abl@0, prpage
op:"mov" Abl_0, prpage is opcode_2_15=(0x9164>>2) & Abl_0 & prpage { prpage = Abl_0; }
# 9064h TL2 mov  Abl@0, repc
op:"mov" Abl_0, repc is opcode_2_15=(0x9064>>2) & Abl_0 & repc { repc = Abl_0; } # TODO: saturation
# D394h TL2 mov  Abl@0, x1
op:"mov" Abl_0, x1 is opcode_2_15=(0xD394>>2) & Abl_0 & x1 { x1 = Abl_0; }  # TODO: saturation
# D384h TL2 mov  Abl@0, y1
op:"mov" Abl_0, y1 is opcode_2_15=(0xD384>>2) & Abl_0 & y1 { y1 = Abl_0; }  # TODO: saturation
# 9540h TL2 mov  Abl@3, ArArp@0
op:"mov" Abl_3, ArArp_0 is opcode_5_15=(0x954>>1) & Abl_3 & ArArp_0 { ArArp_0 = Abl_3; } # TODO: saturation
# 9C60h TL2 mov  Abl@3, SttMod@0
op:"mov" Abl_3, SttMod_0 is opcode_5_15=(0x9C6>>1) & Abl_3 & SttMod_0 { SttMod_0 = Abl_3; } # TODO: saturation
# 9560h TL2 mov  ArArp@0, Abl@3
op:"mov" ArArp_0, Abl_3 is opcode_5_15=(0x956>>1) & Abl_3 & ArArp_0 & Ab_3 { Abl_3 = ArArp_0; FLAGS40(Ab_3); } # TODO: saturation, should clobber full accumulator
# D488h TL2 mov  ArArp@0, MemR04@8 || R04@8stepII2@5
op:"mov" ArArp_0, MemR04_8 || R04_8_stepII2_5 is opcode_9_15=(0xD4>>1) & MemR04_8 & opcode_6_7=(8>>2) & R04_8_stepII2_5 & opcode_3_4=(0x08>>3) & ArArp_0 {
	MemR04_8 = ArArp_0;
	build R04_8_stepII2_5;
}
# 5F50h TL2 mov  ArArpSttMod@0, MemR7Imm16@16
op:"mov" ArArpSttMod_0, MemR7Imm16 is opcode_4_15=0x5F5 & ArArpSttMod_0; MemR7Imm16 { MemR7Imm16 = ArArpSttMod_0; }
# 886Bh TL2 mov  Ax@8, pc
op:"mov" Ax_8, pc is opcode_9_15=(0x88>>1) & Ax_8 & opcode_0_7=0x6B & pc { local tmp:5 = Ax_8 & 0xFFFFFFFF; goto [tmp]; }
# 8C60h TL2 mov  Axh@4, MemR4567@8 || mov MemR0123@8, Axh@4
#            || R0123@8stepII2D2S@0, R4567@8stepII2D2S@2
op:"mov" Axh_4, MemR4567_8 || "mov" MemR0123_8, Axh_4_copy || R0123_8_stepII2D2S_0, R4567_8_stepII2D2S_2
	is opcode_10_15=(0x8C>>2) & MemR4567_8 & MemR0123_8 & opcode_5_7=(1>>2) & Axh_4 & Axh_4_copy & Ax_4 & R4567_8_stepII2D2S_2 & R0123_8_stepII2D2S_0
{
	MemR4567_8 = Axh_4;  # TODO: saturation
	Ax_4 = sext(MemR0123_8) << 16;
	# No flags are set
	build R0123_8_stepII2D2S_0;
	build R4567_8_stepII2D2S_2;
}
# 4800h TL2 mov  Axh@6, MemR0123@4 || movr MemR4567@4, Axh@6
#            || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mov" Axh_6, MemR0123_4 || "movr" MemR4567_4, Axh_6_copy || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_7_15=(0x480>>3) & Axh_6 & Axh_6_copy & Ax_6 & MemR0123_4 & MemR4567_4 & R4567_4_stepII2D2S_2 & R0123_4_stepII2D2S_0
{
	MemR0123_4 = Axh_6;  # TODO: saturation
	Ax_6 = (sext(MemR4567_4) << 16) | 0x8000;
	# No flags are set
	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 4900h TL2 mov  Axh@6, MemR0123@4 || mov  MemR4567@4, Axh@6
#            || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mov" Axh_6, MemR0123_4 || "mov" MemR4567_4, Axh_6_copy || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_7_15=(0x490>>3) & Axh_6 & Axh_6_copy & Ax_6 & MemR0123_4 & MemR4567_4 & R4567_4_stepII2D2S_2 & R0123_4_stepII2D2S_0
{
	MemR0123_4 = Axh_6;  # TODO: saturation
	Ax_6 = sext(MemR4567_4) << 16;
	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 7F80h TL2 mov  Axh@6, MemR4567@4 || movr MemR0123@4, Axh@6
#            || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mov" Axh_6, MemR4567_4 || "movr" MemR0123_4, Axh_6_copy || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_7_15=(0x7F8>>3) & Axh_6 & Axh_6_copy & Ax_6 & MemR0123_4 & MemR4567_4 & R4567_4_stepII2D2S_2 & R0123_4_stepII2D2S_0
{
	MemR4567_4 = Axh_6;  # TODO: saturation
	Ax_6 = (sext(MemR0123_4) << 16) | 0x8000;
	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 8863h TL2 mov  Bx@8, pc
op:"mov" Bx_8, pc is opcode_9_15=(0x88>>1) & Bx_8 & opcode_0_7=0x63 & pc { local tmp:5 = Bx_8 & 0xFFFFFFFF; goto [tmp]; }
# 0008h TL2 mov  Imm16@16, ArArp@0
op:"mov" Imm16, ArArp_0 is opcode_3_15=(0x0008>>3) & ArArp_0; Imm16 { ArArp_0 = Imm16; }
# 0023h TL2 mov  Imm16@16, r6
op:"mov" Imm16, r6 is opcode_0_15=0x0023 & r6; Imm16 { r6 = Imm16; }
# 0001h TL2 mov  Imm16@16, repc
op:"mov" Imm16, repc is opcode_0_15=0x0001 & repc; Imm16 { repc = Imm16; }
# 8971h TL2 mov  Imm16@16, stepi0
op:"mov" Imm16, stepi0 is opcode_0_15=0x8971 & stepi0; Imm16 { stepi0 = Imm16; }
# 8979h TL2 mov  Imm16@16, stepj0
op:"mov" Imm16, stepj0 is opcode_0_15=0x8979 & stepj0; Imm16 { stepj0 = Imm16; }
# 0030h TL2 mov  Imm16@16, SttMod@0
op:"mov" Imm16, SttMod_0 is opcode_3_15=(0x0030>>3) & SttMod_0; Imm16 { SttMod_0 = Imm16; }
# 5DD0h TL2 mov  Imm4u@0, prpage
op:"mov" Imm4u_0, prpage is opcode_4_15=0x5DD & Imm4u_0 & prpage { prpage = Imm4u_0; }
# 80C4h TL2 mov  MemR01@9, Abh@10 || mov MemR45@9, Abl@10
#            || R01@9stepII2@0, R45@9stepII2@8
op:"mov" MemR01_9, Abh_10 || "mov" MemR45_9, Abl_10 || R01_9_stepII2_0, R45_9_stepII2_8
	is opcode_11_15=(0x80>>3) & Abh_10 & Abl_10 & Ab_10 & MemR01_9 & MemR45_9 & R45_9_stepII2_8 & opcode_1_7=(0xC4>>1) & R01_9_stepII2_0
{
	Ab_10 = (sext(MemR01_9) << 16) | zext(MemR45_9);
	build R01_9_stepII2_0;
	build R45_9_stepII2_8;
}
# D292h TL2 mov  MemR0425@10_MemR0425@10offsZIDZ@5, Px@0
#            || R0425@10stepII2D2S@5
op:"mov" MemR0425_10^"_"^MemR0425_10_offsZIDZ_5, Px_0 || R0425_10_stepII2D2S_5
	is opcode_12_15=0xD & MemR0425_10 & opcode_7_9=(0x29>>3) & MemR0425_10_offsZIDZ_5 & R0425_10_stepII2D2S_5 & opcode_1_4=(0x12>>1) & Px_0
{
	Px_0 = (sext(MemR0425_10) << 16) | zext(MemR0425_10_offsZIDZ_5);
	build R0425_10_stepII2D2S_5;
}
# D7D4h TL2 mov  MemR04@1, repc || R04@1stepII2@0
op:"mov" MemR04_1, repc || R04_1_stepII2_0 is opcode_2_15=(0xD7D4>>2) & MemR04_1 & R04_1_stepII2_0 & repc { repc = MemR04_1; build R04_1_stepII2_0; }
# 5F4Ch TL2 mov  MemR04@1, sv || sub3 MemR04@1, p0, p1, b0 || R04@1stepII2@0
op:"mov" MemR04_1, sv || "sub3" MemR04_1_copy, p0, p1, b0 || R04_1_stepII2_0 is opcode_2_15=(0x5F4C>>2) & MemR04_1 & MemR04_1_copy & R04_1_stepII2_0 & sv & p0 & p1 & b0 {
	sv = MemR04_1;
	PRODUCT_SUB3_SV(b0, sext(sv) << 16, p0, p1);
	build R04_1_stepII2_0;
}
# D4B4h TL2 mov  MemR04@1, sv || sub3rnd MemR04@1, p0, p1, b1 || R04@1stepII2@0
op:"mov" MemR04_1, sv || "sub3rnd" MemR04_1_copy, p0, p1, b1 || R04_1_stepII2_0 is opcode_2_15=(0xD4B4>>2) & MemR04_1 & MemR04_1_copy & R04_1_stepII2_0 & sv & p0 & p1 & b1 {
	sv = MemR04_1;
	PRODUCT_SUB3_SV(b1, (sext(sv) << 16) | 0x8000, p0, p1);
	build R04_1_stepII2_0;
}
# DE9Ch TL2 mov  MemR04@1, sv || sub3rnd MemR04@1, p0, p1, b0 || R04@1stepII2@0
op:"mov" MemR04_1, sv || "sub3rnd" MemR04_1_copy, p0, p1, b0 || R04_1_stepII2_0 is opcode_2_15=(0xDE9C>>2) & MemR04_1 & MemR04_1_copy & R04_1_stepII2_0 & sv & p0 & p1 & b0 {
	sv = MemR04_1;
	PRODUCT_SUB3_SV(b0, (sext(sv) << 16) | 0x8000, p0, p1);
	build R04_1_stepII2_0;
}
# 4B40h TL2 mov  MemR04@3, sv || addsub    MemR04@3, p1, p0, Bx@0
#            || R04@3stepII2@2
op:"mov" MemR04_3, sv || "addsub"    MemR04_3_copy, p1, p0, Bx_0 || R04_3_stepII2_2
	is opcode_4_15=0x4B4 & MemR04_3 & MemR04_3_copy & R04_3_stepII2_2 & opcode_1_1=0 & Bx_0 & sv & p1 & p0
{
	sv = MemR04_3;
	PRODUCT_SUB_ADD_SV(Bx_0, sext(sv) << 16, p0, p1);
	build R04_3_stepII2_2;
}
# 4B42h TL2 mov  MemR04@3, sv || addsubrnd MemR04@3, p1, p0, Bx@0
#            || R04@3stepII2@2
op:"mov" MemR04_3, sv || "addsubrnd" MemR04_3_copy, p1, p0, Bx_0 || R04_3_stepII2_2
	is opcode_4_15=0x4B4 & MemR04_3 & MemR04_3_copy & R04_3_stepII2_2 & opcode_1_1=1 & Bx_0 & sv & p1 & p0
{
	sv = MemR04_3;
	PRODUCT_SUB_ADD_SV(Bx_0, (sext(sv) << 16) | 0x8000, p0, p1);
	build R04_3_stepII2_2;
}
# 8062h TL2 mov  MemR04@4, ArArp@8  || R04@4stepII2@3
op:"mov" MemR04_4, ArArp_8 || R04_4_stepII2_3 is opcode_11_15=(0x80>>3) & ArArp_8 & opcode_5_7=(0x6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=2 {
	ArArp_8 = MemR04_4;
	build R04_4_stepII2_3;
}
# 8063h TL2 mov  MemR04@4, SttMod@8 || R04@4stepII2@3
op:"mov" MemR04_4, SttMod_8 || R04_4_stepII2_3 is opcode_11_15=(0x80>>3) & SttMod_8 & opcode_5_7=(0x6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=3 {
	SttMod_8 = MemR04_4;
	build R04_4_stepII2_3;
}
# 9960h TL2 mov  MemR04@4, sv || addsub    MemR04@4, p1, p0, Bx@2
#            || R04@4stepD2S@3  ;<-- ordered p1, p0 here !
# NOTE: the order warning here also applies to 4B40 / 4B42. There is no move instruction where p0 is added (only options for p1 being added or subtracted)
op:"mov" MemR04_4, sv || "addsub"    MemR04_4_copy, p1, p0, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x996>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p1 & p0
{
	sv = MemR04_4;
	PRODUCT_SUB_ADD_SV(Bx_2, sext(sv) << 16, p0, p1);
	build R04_4_stepD2S_3;
}
# 99E0h TL2 mov  MemR04@4, sv || addsubrnd MemR04@4, p1, p0, Bx@2
#            || R04@4stepD2S@3  ;<-- ordered p1, p0 here !
op:"mov" MemR04_4, sv || "addsubrnd" MemR04_4_copy, p1, p0, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x99E>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p1 & p0
{
	sv = MemR04_4;
	PRODUCT_SUB_ADD_SV(Bx_2, (sext(sv) << 16) | 0x8000, p0, p1);
	build R04_4_stepD2S_3;
}
# 9860h TL2 mov  MemR04@4, sv || sub3      MemR04@4, p0, p1, Bx@2
#            || R04@4stepD2S@3
op:"mov" MemR04_4, sv || "sub3"    MemR04_4_copy, p0, p1, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x986>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p0 & p1
{
	sv = MemR04_4;
	PRODUCT_SUB3_SV(Bx_2, sext(sv) << 16, p0, p1);
	build R04_4_stepD2S_3;
}
# 98E0h TL2 mov  MemR04@4, sv || sub3rnd   MemR04@4, p0, p1, Bx@2
#            || R04@4stepD2S@3
op:"mov" MemR04_4, sv || "sub3rnd" MemR04_4_copy, p0, p1, Bx_2 || R04_4_stepD2S_3
	is opcode_5_15=(0x98E>>1) & MemR04_4 & MemR04_4_copy & R04_4_stepD2S_3 & Bx_2 & opcode_0_1=0 & sv & p0 & p1
{
	sv = MemR04_4;
	PRODUCT_SUB3_SV(Bx_2, (sext(sv) << 16) | 0x8000, p0, p1);
	build R04_4_stepD2S_3;
}
# 8873h TL2 mov  MemR04@8, sv || sub3 MemR04@8, p0, p1, b1 || R04@8stepII2@3
op:"mov" MemR04_8, sv || "sub3" MemR04_8_copy, p0, p1, b1 || R04_8_stepII2_3
	is opcode_9_15=(0x88>>1) & MemR04_8 & MemR04_8_copy & opcode_4_7=7 & R04_8_stepII2_3 & opcode_0_2=3 & sv & p0 & p1 & b1
{
	sv = MemR04_8;
	PRODUCT_SUB3_SV(b1, sext(sv) << 16, p0, p1);
	build R04_8_stepII2_3;
}

# D4C0h TL2 mov  MemR45@5, Abh@2 || mov MemR01@5, Abl@2
#            || R01@5stepII2@0, R45@5stepII2@1
op:"mov" MemR45_5, Abh_2 || "mov" MemR01_5, Abl_2 || R01_5_stepII2_0, R45_5_stepII2_1
	is opcode_6_15=(0xD4C>>2) & MemR45_5 & MemR01_5 & opcode_4_4=0 & Abh_2 & Abl_2 & R45_5_stepII2_1 & R01_5_stepII2_0
{
	Abh_2 = MemR45_5;
	Abl_2 = MemR01_5;
	build R01_5_stepII2_0;
	build R45_5_stepII2_1;
}
# 4D90h TL2 mov  MemR7Imm16@16, ArArpSttMod@0
op:"mov" MemR7Imm16, ArArpSttMod_0 is opcode_4_15=0x4D9 & ArArpSttMod_0; MemR7Imm16 { ArArpSttMod_0 = MemR7Imm16; }
# D2DCh TL2 mov  MemR7Imm16@16, repc, Unused2@0, Unused1@10
op:"mov" MemR7Imm16, repc is opcode_11_15=(0xD2>>3) & unused_10_10 & opcode_2_9=(0x2DC>>2) & unused_0_1 & repc; MemR7Imm16 { repc = MemR7Imm16; }
# 1B20h TL2 mov  MemRn@0, r6 || Rn@0stepZIDS@3 ;override 1800h (mov a1,MemRn@0)
op:"mov" MemRn_0, r6 || Rn_0_stepZIDS_3 is opcode_5_15=(0x1B2>>1) & Rn_0_stepZIDS_3 & MemRn_0 & r6 { r6 = MemRn_0; build Rn_0_stepZIDS_3; }
# D29Ch TL2 mov  MemSp, r6, Unused2@0, Unused1@10
op:"mov" MemSp, r6 is opcode_11_15=(0xD2>>3) & unused_10_10 & opcode_2_9=(0x29C>>2) & unused_0_1 & r6 & MemSp { r6 = MemSp; }
# 8A73h TL2 mov  mixp, Bx@3
op:"mov" mixp, Bx_3 is opcode_4_15=0x8A7 & Bx_3 & opcode_0_2=3 & mixp { Bx_3 = sext(mixp); FLAGS40(Bx_3); } # TODO: saturation
# 4381h TL2 mov  mixp, r6
op:"mov" mixp, r6 is opcode_0_15=0x4381 & mixp & r6 { r6 = mixp; }
# 4382h TL2 mov  p0h, Bx@0
op:"mov" p0h, Bx_0 is opcode_1_15=(0x4382>>1) & Bx_0 & p0h { Bx_0 = sext(p0h); FLAGS40(Bx_0); } # TODO: extension
# D3C2h TL2 mov  p0h, r6
op:"mov" p0h, r6 is opcode_0_15=0xD3C2 & p0h & r6 { r6 = p0h; }
# 4B60h TL2 mov  p0h, Register@0     ;<-- here "p0h" as source
# This is meaningful as 5800h (register-register move) behaves differently when the source register is p0, only allowing moving to a0 or a1.
# I'm not sure why they didn't just fix that for TL2 and instead added a whole new instruction -- maybe the assembler did something weird?
op:"mov" p0h, Register_0_Write is opcode_5_15=(0x4B6>>1) & Register_0_Write & Register_0_Write_After & p0h { Register_0_Write = p0h; build Register_0_Write_After; }
# 8FD8h TL2 mov  p1, Ab@0
op:"mov" p1, Ab_0 is opcode_2_15=(0x8FD8>>2) & Ab_0 & p1 { Ab_0 = p1; FLAGS40(Ab_0); }
# 88D0h TL2 mov  Px@1, MemR0425@8_MemR0425@8offsZIDZ@2   || R0425@8stepII2D2S@2
op:"mov" Px_1, MemR0425_8^"_"^MemR0425_8_offsZIDZ_2 || R0425_8_stepII2D2S_2
	is opcode_10_15=(0x88>>2) & MemR0425_8 & opcode_4_7=0xD & MemR0425_8_offsZIDZ_2 & R0425_8_stepII2D2S_2 & Px_1 & opcode_0_0=0
{
	# NOTE: this doesn't do any shifting, unlike most other product operations
	local high_tmp:5 = Px_1 s>> 16;
	local high:2 = high_tmp:2;
	local low:2 = Px_1:2;
	MemR0425_8_offsZIDZ_2 = low;
	MemR0425_8 = high;
	build R0425_8_stepII2D2S_2;
}
# 88D1h TL2 mov  Px@1, MemR0425@8_MemR0425@8offsZIDZ@2,s || R0425@8stepII2D2S@2
op:"mov" Px_1, MemR0425_8^"_"^MemR0425_8_offsZIDZ_2^",s" || R0425_8_stepII2D2S_2
	is opcode_10_15=(0x88>>2) & MemR0425_8 & opcode_4_7=0xD & MemR0425_8_offsZIDZ_2 & R0425_8_stepII2D2S_2 & Px_1 & opcode_0_0=1
{
	# TODO: This one does do shifting
	local high_tmp:5 = Px_1 s>> 16;
	local high:2 = high_tmp:2;
	local low:2 = Px_1:2;
	MemR0425_8_offsZIDZ_2 = low;
	MemR0425_8 = high;
	build R0425_8_stepII2D2S_2;
}
# D481h TL2 mov  r6, Bx@8
op:"mov" r6, Bx_8 is opcode_9_15=(0xD4>>1) & Bx_8 & opcode_0_7=0x81 & r6 { Bx_8 = sext(r6); FLAGS40(Bx_8); } # TODO: saturation
# 1B00h TL2 mov  r6, MemRn@0 || Rn@0stepZIDS@3 ;override 1800h (mov a0,MemRn@0)
op:"mov" r6, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x1B0>>1) & Rn_0_stepZIDS_3 & MemRn_0 & r6 { MemRn_0 = r6; build Rn_0_stepZIDS_3; }
# 43C1h TL2 mov  r6, mixp
op:"mov" r6, mixp is opcode_0_15=0x43C1 & r6 & mixp { mixp = r6; }
# 5F00h TL2 mov  r6, Register@0
op:"mov" r6, Register_0_Write is opcode_5_15=(0x5F0>>1) & Register_0_Write & Register_0_Write_After & r6 { Register_0_Write = r6; build Register_0_Write_After; }
# 5F60h TL2 mov  Register@0, r6
op:"mov" Register_0_Read_Saturate, r6 is opcode_5_15=(0x5F6>>1) & Register_0_Read_Saturate & r6 { r6 = Register_0_Read_Saturate; }
# D2D9h TL2 mov  repc, Abl@10
op:"mov" repc, Abl_10 is opcode_12_15=0xD & Abl_10 & opcode_0_9=0x2D9 & repc & Ab_10 { Abl_10 = repc; FLAGS40(Ab_10); }  # TODO: saturation, and also this should clobber the whole accumulator...
# D7D0h TL2 mov  repc, MemR04@1 || R04@1stepII2@0
op:"mov" repc, MemR04_1 || R04_1_stepII2_0 is opcode_2_15=(0xD7D0>>2) & MemR04_1 & R04_1_stepII2_0 & repc { MemR04_1 = repc; build R04_1_stepII2_0; }
# D3C8h TL2 mov  repc, MemR7Imm16@16, Unused3@0
op:"mov" repc, MemR7Imm16 is opcode_3_15=(0xD3C8>>3) & unused_0_2 & repc; MemR7Imm16 { MemR7Imm16 = repc; }
# D482h TL2 mov  stepi0, a0h
op:"mov" stepi0, a0h is opcode_0_15=0xD482 & stepi0 & a0h { a0h = stepi0; FLAGS40(a0); }  # TODO: saturation, and also this should clobber the whole accumulator...
# D582h TL2 mov  stepj0, a0h
op:"mov" stepj0, a0h is opcode_0_15=0xD582 & stepj0 & a0h { a0h = stepj0; FLAGS40(a0); }  # TODO: saturation, and also this should clobber the whole accumulator...
# D2F8h TL2 mov  SttMod@0, Abl@10
op:"mov" SttMod_0, Abl_10 is opcode_12_15=0xD & Abl_10 & opcode_3_9=(0x2F8>>3) & SttMod_0 { Abl_10 = SttMod_0; }
# 49C1h TL2 mov  x1, Ab@4
op:"mov" x1, Ab_4 is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_0_3=1 & x1 { Ab_4 = sext(x1); FLAGS40(Ab_4); }  # TODO: saturation
# D299h TL2 mov  y1, Ab@10
op:"mov" y1, Ab_10 is opcode_12_15=0xD & Ab_10 & opcode_0_9=0x299 & y1 { Ab_10 = sext(y1); FLAGS40(Ab_10); } # TODO: saturation
# 5EB0h TL2 mov  prpage, Abl@0
op:"mov" prpage, Abl_0 is opcode_2_15=(0x5EB0>>2) & Abl_0 & prpage & Ab_0 { Abl_0 = prpage; FLAGS40(Ab_0); }  # TODO: saturation, and also this should clobber the whole accumulator...
# 49A0h TL2 mov  SttMod@0, MemR04@4 || R04@4stepII2@3
op:"mov" SttMod_0, MemR04_4 || R04_4_stepII2_3 is opcode_5_15=(0x49A>>1) & MemR04_4 & R04_4_stepII2_3 & SttMod_0 { MemR04_4 = SttMod_0; build R04_4_stepII2_3; }
# 4DC0h TL2 mova Ab@4, MemR0425@2_MemR0425@2offsZIDZ@0 || R0425@2stepII2D2S@0
op:"mova" Ab_4, MemR0425_2^"_"^MemR0425_2_offsZIDZ_0 || R0425_2_stepII2D2S_0
	is opcode_6_15=(0x4DC>>2) & Ab_4 & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0 & Abh_4 & Abl_4
{
	# TODO: saturation
	# NOTE: teakra notes that the low part is overridden by the high part if the offset is 0
	MemR0425_2_offsZIDZ_0 = Abl_4;
	MemR0425_2 = Abh_4;
	build R0425_2_stepII2D2S_0;
}
# 4BC0h TL2 mova MemR0425@2_MemR0425@2offsZIDZ@0, Ab@4 || R0425@2stepII2D2S@0
op:"mova" MemR0425_2^"_"^MemR0425_2_offsZIDZ_0, Ab_4 || R0425_2_stepII2D2S_0
	is opcode_6_15=(0x4BC>>2) & Ab_4 & MemR0425_2 & MemR0425_2_offsZIDZ_0 & R0425_2_stepII2D2S_0
{
	Ab_4 = (sext(MemR0425_2) << 16) | zext(MemR0425_2_offsZIDZ_0);
	build R0425_2_stepII2D2S_0;
}
@endif
# 5F80h TL  movd MemR0123@0,ProgMemR45@2 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"movd" MemR0123_0, ProgMemR45_2 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5
	is opcode_7_15=(0x5F8>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & ProgMemR45_2 & MemR0123_0
{
	ProgMemR45_2 = MemR0123_0;
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 0040h TL  movp ProgMemAxl@5, Register@0
op:"movp" ProgMemAxl_5, Register_0_Write is opcode_6_15=(0x004>>2) & ProgMemAxl_5 & Register_0_Write & Register_0_Write_After { Register_0_Write = ProgMemAxl_5; build Register_0_Write_After; }
@ifdef TEAK_LITE_2
# 0D40h TL2 movp ProgMemAx@5, Register@0
op:"movp" ProgMemAx_5, Register_0_Write is opcode_6_15=(0x0D4>>2) & ProgMemAx_5 & Register_0_Write & Register_0_Write_After { Register_0_Write = ProgMemAx_5; build Register_0_Write_After; }
@endif
# 0600h TL  movp ProgMemRn@0, MemR0123@5 || R0123@5stepZIDS@7, Rn@0stepZIDS@3
op:"movp" ProgMemRn_0, MemR0123_5 || R0123_5_stepZIDS_7, Rn_0_stepZIDS_3
	is opcode_9_15=(0x06>>1) & R0123_5_stepZIDS_7 & MemR0123_5 & Rn_0_stepZIDS_3 & ProgMemRn_0
{
	MemR0123_5 = ProgMemRn_0;
	build R0123_5_stepZIDS_7;
	build Rn_0_stepZIDS_3;
}
@ifdef TEAK_LITE_2
# D499h TL2 movpdw ProgMemAx@8_ProgMemAx@8offsI, pc
op:"movpdw" ProgMemAx_8^"_"^ProgMemAx_8_offsI, pc is opcode_9_15=(0xD4>>1) & ProgMemAx_8 & ProgMemAx_8_offsI & opcode_0_7=0x99 & pc {
	local address:5 = (zext(ProgMemAx_8) << 16) | zext(ProgMemAx_8_offsI);
	goto [address];
}
@endif
# 8864h TL  movr MemR0425@3, Abh@8 || R0425@3stepII2D2S@0   ;op*10000h+8000h
# TODO: why does this one use Abh while the rest use Ax? In practice it seems like this needs to write to Ab anyways...
op:"movr" MemR0425_3, Abh_8 || R0425_3_stepII2D2S_0 is opcode_10_15=(0x88>>2) & Abh_8 & opcode_5_7=(6>>1) & MemR0425_3 & opcode_2_2=1 & R0425_3_stepII2D2S_0 & Ab_8 {
	ADD40_3(Ab_8, sext(MemR0425_3) << 16, 0x8000);
	build R0425_3_stepII2D2S_0;
}
# 9CE0h TL  movr MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"movr" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0xE>>1) & Rn_0_stepZIDS_3 & MemRn_0 {
	# Teakra says: "Do 16-bit arithmetic. Flag C is set according to bit 16 but Flag V is always cleared" "Looks like a hardware bug to me"
	local tmp:2 = MemRn_0;
	$(FLAG_C) = scarry(tmp, 0x8000);
	$(FLAG_V) = 0;
	tmp = tmp + 0x8000;
	Ax_8 = zext(tmp);
	FLAGS40(Ax_8);  # TODO: saturation
	build Rn_0_stepZIDS_3;
}
# 9CC0h TL  movr RegisterP0@0, Ax@8
# TODO: teakra indicates special behavior for Register_0 = a0/a1/p
op:"movr" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0xC>>1) & Register_0_Read_No_Saturate {
	# Same 16-bit arithmetic as 9CE0h
	local tmp:2 = Register_0_Read_No_Saturate;
	$(FLAG_C) = scarry(tmp, 0x8000);
	$(FLAG_V) = 0;
	tmp = tmp + 0x8000;
	Ax_8 = zext(tmp);
	FLAGS40(Ax_8);  # TODO: saturation
}
@ifdef TEAK_LITE_2
# 5DF4h TL2 movr Bx@1, Ax@0
op:"movr" Bx_1, Ax_0 is opcode_2_15=(0x5DF4>>2) & Bx_1 & Ax_0 { ADD40_3(Ax_0, Bx_1, 0x8000); }
# 8961h TL2 movr r6, Ax@3
op:"movr" r6, Ax_3 is opcode_4_15=0x896 & Ax_3 & opcode_0_2=1 & r6 {
	# Same 16-bit arithmetic as 9CE0h
	local tmp:2 = r6;
	$(FLAG_C) = scarry(tmp, 0x8000);
	$(FLAG_V) = 0;
	tmp = tmp + 0x8000;
	Ax_3 = zext(tmp);
	FLAGS40(Ax_3);  # TODO: saturation
}
@endif
# 6300h TL  movs Implied sv, MemImm8@0, Ab@11
# TODO: what does this do and what does sv do?
op:"movs" sv, MemImm8_0, Ab_11 is opcode_13_15=(6>>1) & Ab_11 & opcode_8_10=3 & MemImm8_0 & sv { SHIFT_40(Ab_11, sext(MemImm8_0), sv); }
# 0180h TL  movs Implied sv, MemRn@0, Ab@5 || Rn@0stepZIDS@3
op:"movs" sv, MemRn_0, Ab_5 || Rn_0_stepZIDS_3 is opcode_7_15=(0x018>>3) & Ab_5 & Rn_0_stepZIDS_3 & MemRn_0 & sv { SHIFT_40(Ab_5, sext(MemRn_0), sv); build Rn_0_stepZIDS_3; }
# 0100h TL  movs Implied sv, RegisterP0@0, Ab@5
op:"movs" sv, Register_0_Read_No_Saturate, Ab_5 is opcode_7_15=(0x010>>3) & Ab_5 & Register_0_Read_No_Saturate & sv { SHIFT_40(Ab_5, sext(Register_0_Read_No_Saturate), sv); }
@ifdef TEAK_LITE_2
# 5F42h TL2 movs Implied sv, r6, Ax@0
op:"movs" sv, r6, Ax_0 is opcode_1_15=(0x5F42>>1) & Ax_0 & r6 & sv { SHIFT_40(Ax_0, sext(r6), sv); }
@endif
# 4080h TL  movsi Implied Imm5s@0, R0123457y0@9, Ab@5, Bogus Imm5s@0
op:"movsi" Imm5s_0, R0123457y0_9, Ab_5 is opcode_12_15=4 & R0123457y0_9 & opcode_7_8=(0x08>>3) & Ab_5 & Imm5s_0 { SHIFT_40(Ab_5, sext(R0123457y0_9), Imm5s_0); }
# D000h TL  mpy  MemR45@2, MemR0123@0 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"mpy" MemR45_2, MemR0123_0 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_7_15=(0xD00>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8000h TL  mpy  MemRn@0, Imm16@16    || Rn@0stepZIDS@3
op:"mpy" MemRn_0, Imm16 || Rn_0_stepZIDS_3 is opcode_5_15=(0x800>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8020h TL  mpy  y0, MemRn@0          || Rn@0stepZIDS@3
op:"mpy" y0, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x802>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	x0 = MemRn_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8040h TL  mpy  y0, Register@0
op:"mpy" y0, Register_0_Read_No_Saturate is opcode_5_15=(0x804>>1) & Register_0_Read_No_Saturate & y0 & Y0_input {
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# E000h TL  mpy  y0, MemImm8@0
op:"mpy" y0, MemImm8_0 is opcode_8_15=0xE0 & MemImm8_0 & y0 & Y0_input {
	x0 = MemImm8_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 5EA0h TL2 mpy  y0, r6
op:"mpy" y0, r6 is opcode_0_15=0x5EA0 & y0 & r6 & Y0_input {
	x0 = r6;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# CB00h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
# opcode_0_0: mpysu (unsigned x1, signed y1) vs mpyus (signed x1, unsigned y1)
# opcode_1_1: sub3 vs sub3a or add3 vs add3a
# opcode_2_2: sub vs add
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB01h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB02h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=2 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB03h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=3 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB04h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=4 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB05h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3   p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=5 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB06h TL2 mpy  MemR45@5, MemR01@5 || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=6 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CB07h TL2 mpy  MemR45@5, MemR01@5 || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpy" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCB & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=7 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# D5E0h TL2 mpy  MemR04@1, x1 || mpy y1, x0 || sub3 p0, p1, Ax@3
#            || R04@1stepII2@0
macro SWAP_X0_X1() {
	local tmp:2 = x1;
	x1 = x0;
	x0 = tmp;
}
op:"mpy" MemR04_1, x1 || "mpy" y1, x0 || "sub3" p0, p1, Ax_3 || R04_1_stepII2_0
	is opcode_5_15=(0xD5E>>1) & MemR04_1 & Ax_3 & opcode_2_2=0 & R04_1_stepII2_0 & x1 & y1 & x0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_3, p0, p1);

	y0 = MemR04_1;
	SWAP_X0_X1();

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_1_stepII2_0;
}
# D5E4h TL2 mpy  MemR04@1, x1 || mpy y1, x0 || add3 p0, p1, Ax@3
#            || R04@1stepII2@0
op:"mpy" MemR04_1, x1 || "mpy" y1, x0 || "add3" p0, p1, Ax_3 || R04_1_stepII2_0
	is opcode_5_15=(0xD5E>>1) & MemR04_1 & Ax_3 & opcode_2_2=1 & R04_1_stepII2_0 & x1 & y1 & x0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_3, p0, p1);

	y0 = MemR04_1;
	SWAP_X0_X1();

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_1_stepII2_0;
}
# C800h TL2 mpy  MemR4567@4, MemR0123@4
#            || mpy MemR4567@4offsZIDZ@2, MemR0123@4offsZIDZ@0
#            || add3 p0, p1, Ab@6 || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mpy" MemR4567_4, MemR0123_4 || "mpy" MemR4567_4_offsZIDZ_2, MemR0123_4_offsZIDZ_0 || "add3" p0, p1, Ab_6 || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_8_15=0xC8 & Ab_6 & MemR4567_4 & MemR0123_4 & MemR4567_4_offsZIDZ_2 & R4567_4_stepII2D2S_2 & MemR0123_4_offsZIDZ_0 & R0123_4_stepII2D2S_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1);

	x0 = MemR0123_4;
	y0 = MemR4567_4;
	x1 = MemR0123_4_offsZIDZ_0;
	y1 = MemR4567_4_offsZIDZ_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# C900h TL2 mpy  MemR4567@4, MemR0123@4
#            || mpy MemR4567@4offsZIDZ@2, MemR0123@4offsZIDZ@0
#            || sub3 p0, p1, Ab@6 || R0123@4stepII2D2S@0, R4567@4stepII2D2S@2
op:"mpy" MemR4567_4, MemR0123_4 || "mpy" MemR4567_4_offsZIDZ_2, MemR0123_4_offsZIDZ_0 || "sub3" p0, p1, Ab_6 || R0123_4_stepII2D2S_0, R4567_4_stepII2D2S_2
	is opcode_8_15=0xC9 & Ab_6 & MemR4567_4 & MemR0123_4 & MemR4567_4_offsZIDZ_2 & R4567_4_stepII2D2S_2 & MemR0123_4_offsZIDZ_0 & R0123_4_stepII2D2S_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1);

	x0 = MemR0123_4;
	y0 = MemR4567_4;
	x1 = MemR0123_4_offsZIDZ_0;
	y1 = MemR4567_4_offsZIDZ_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R0123_4_stepII2D2S_0;
	build R4567_4_stepII2D2S_2;
}
# 80C2h TL2 mpy  MemR45@0, MemR01@0 || mpy MemR45@0offsZI@9, MemR01@0offsZI@8
#            || add3a p0, p1, Ab@10 || R01@0stepII2@8, R45@0stepII2@9
op:"mpy" MemR45_0, MemR01_0 || "mpy" MemR45_0_offsZI_9, MemR01_0_offsZI_8 || "add3a" p0, p1, Ab_10 || R01_0_stepII2_8, R45_0_stepII2_9
	is opcode_12_15=8 & Ab_10 & MemR45_0_offsZI_9 & R45_0_stepII2_9 & MemR01_0_offsZI_8 & R01_0_stepII2_8 & opcode_1_7=(0xC2>>1) & MemR45_0 & MemR01_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_10, p0, p1 s>> 16);

	x0 = MemR01_0;
	y0 = MemR45_0;
	x1 = MemR01_0_offsZI_8;
	y1 = MemR45_0_offsZI_9;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_0_stepII2_8;
	build R45_0_stepII2_9;
}
# 49C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || sub3a p0, p1, Ab@4 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "sub3a" p0, p1, Ab_4 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_6_15=(0x49C>>2) & Ab_4 & opcode_3_3=1 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_4, p0, p1 s>> 16);

	x0 = MemR01_2;
	y0 = MemR45_2;
	x1 = MemR01_2_offsZI_0;
	y1 = MemR45_2_offsZI_1;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 80C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || addsub  p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "addsub" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x0C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD_SUB(Ab_10, p0, p1);

	x0 = MemR01_2;
	y0 = MemR45_2;
	x1 = MemR01_2_offsZI_0;
	y1 = MemR45_2_offsZI_1;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 81C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || addsuba p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "addsuba" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x1C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD_SUB(Ab_10, p0, p1 s>> 16);

	x0 = MemR01_2;
	y0 = MemR45_2;
	x1 = MemR01_2_offsZI_0;
	y1 = MemR45_2_offsZI_1;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 82C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || add     p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "add" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x2C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1 & Y0_input & Y1_input
{
	ADD40_3(Ab_10, p0, p1);

	x0 = MemR01_2;
	y0 = MemR45_2;
	x1 = MemR01_2_offsZI_0;
	y1 = MemR45_2_offsZI_1;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 83C8h TL2 mpy  MemR45@2, MemR01@2 || mpy MemR45@2offsZI@1, MemR01@2offsZI@0
#            || adda    p0, p1, Ab@10 || R01@2stepII2@0, R45@2stepII2@1
op:"mpy" MemR45_2, MemR01_2 || "mpy" MemR45_2_offsZI_1, MemR01_2_offsZI_0 || "adda" p0, p1, Ab_10 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_12_15=8 & Ab_10 & opcode_3_9=(0x3C8>>3) & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0 & p0 & p1 & Y0_input & Y1_input
{
	ADD40_3(Ab_10, p0, p1 s>> 16);

	x0 = MemR01_2;
	y0 = MemR45_2;
	x1 = MemR01_2_offsZI_0;
	y1 = MemR45_2_offsZI_1;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 00C0h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || sub  p0, p1, Ab@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "sub" p0, p1, Ab_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_6_15=(0x00C>>2) & Ab_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=0 & p0 & p1 & Y0_input & Y1_input
{
	SUB40_3(Ab_4, p0, p1);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# 00C1h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || suba p0, p1, Ab@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "suba" p0, p1, Ab_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_6_15=(0x00C>>2) & Ab_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=1 & p0 & p1 & Y0_input & Y1_input
{
	SUB40_3(Ab_4, p0, p1 s>> 16);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# 0D20h TL2 mpy  MemR45@3, MemR01@3 || mpyus MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3a p0, p1, Ax@0, dmodi || R01@3stepII2@1, R45@3stepII2@2
# TODO: what do dmodi/dmodj/dmodij do? Teakra indicates it probably affects the step operations... but then why does gbatek put them next to add3?
op:"mpy" MemR45_3, MemR01_3 || "mpyus" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3a" p0, p1, Ax_0, "dmodi" || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_4_15=0x0D2 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & Ax_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_0, p0, p1 s>> 16);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# 0D30h TL2 mpy  MemR45@3, MemR01@3 || mpyus MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3a p0, p1, Ax@0, dmodj || R01@3stepII2@1, R45@3stepII2@2
# TODO: dmodj
op:"mpy" MemR45_3, MemR01_3 || "mpyus" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3a" p0, p1, Ax_0, "dmodj" || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_4_15=0x0D3 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & Ax_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_0, p0, p1 s>> 16);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# 4B50h TL2 mpy  MemR45@3, MemR01@3 || mpyus MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3a p0, p1, Ax@0, dmodij || R01@3stepII2@1, R45@3stepII2@2
# TODO: dmodij
op:"mpy" MemR45_3, MemR01_3 || "mpyus" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3a" p0, p1, Ax_0, "dmodij" || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_4_15=0x4B5 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & Ax_0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_0, p0, p1 s>> 16);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# D7A0h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3    sv, p0, p1, Ax@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3" sv, p0, p1, Ax_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_5_15=(0xD7A>>1) & Ax_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=0 & sv & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3_SV(b0, sext(sv) << 16, p0, p1);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# D7A1h TL2 mpy  MemR45@3, MemR01@3 || mpy MemR45@3offsZI@2, MemR01@3offsZI@1
#            || add3rnd sv, p0, p1, Ax@4 || R01@3stepII2@1, R45@3stepII2@2
op:"mpy" MemR45_3, MemR01_3 || "mpy" MemR45_3_offsZI_2, MemR01_3_offsZI_1 || "add3rnd" sv, p0, p1, Ax_4 || R01_3_stepII2_1, R45_3_stepII2_2
	is opcode_5_15=(0xD7A>>1) & Ax_4 & MemR45_3 & MemR01_3 & MemR45_3_offsZI_2 & R45_3_stepII2_2 & MemR01_3_offsZI_1 & R01_3_stepII2_1 & opcode_0_0=1 & sv & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3_SV(b1, (sext(sv) << 16) | 0x8000, p0, p1);

	x0 = MemR01_3;
	y0 = MemR45_3;
	x1 = MemR01_3_offsZI_1;
	y1 = MemR45_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_3_stepII2_1;
	build R45_3_stepII2_2;
}
# 9861h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3  p0, p1, Ax@8, dmodj  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3" p0, p1, Ax_8, "dmodj" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x6>>1) & MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=1 & p0 & p1 & Y0_input & Y1_input
# TODO: dmodj
{
	PRODUCT_ADD3(Ax_8, p0, p1);

	x0 = MemR01_4;
	y0 = MemR45_4;
	x1 = MemR01_4_offsZI_2;
	y1 = MemR45_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_4_stepII2_2;
	build R45_4_stepII2_3;
}
# 9862h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3  p0, p1, Ax@8, dmodi  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3" p0, p1, Ax_8, "dmodi" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x6>>1) & MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=2 & p0 & p1 & Y0_input & Y1_input
# TODO: dmodi
{
	PRODUCT_ADD3(Ax_8, p0, p1);

	x0 = MemR01_4;
	y0 = MemR45_4;
	x1 = MemR01_4_offsZI_2;
	y1 = MemR45_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_4_stepII2_2;
	build R45_4_stepII2_3;
}
# 9863h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3  p0, p1, Ax@8, dmodij || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3" p0, p1, Ax_8, "dmodij" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x6>>1) & MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=3 & p0 & p1 & Y0_input & Y1_input
# TODO: dmodij
{
	PRODUCT_ADD3(Ax_8, p0, p1);

	x0 = MemR01_4;
	y0 = MemR45_4;
	x1 = MemR01_4_offsZI_2;
	y1 = MemR45_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_4_stepII2_2;
	build R45_4_stepII2_3;
}
# 98E1h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3a p0, p1, Ax@8, dmodj  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3a" p0, p1, Ax_8, "dmodj" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=1 & p0 & p1 & Y0_input & Y1_input
# TODO: dmodj
{
	PRODUCT_ADD3(Ax_8, p0, p1 s>> 16);

	x0 = MemR01_4;
	y0 = MemR45_4;
	x1 = MemR01_4_offsZI_2;
	y1 = MemR45_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_4_stepII2_2;
	build R45_4_stepII2_3;
}
# 98E2h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3a p0, p1, Ax@8, dmodi  || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3a" p0, p1, Ax_8, "dmodi" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=2 & p0 & p1 & Y0_input & Y1_input
# TODO: dmodi
{
	PRODUCT_ADD3(Ax_8, p0, p1 s>> 16);

	x0 = MemR01_4;
	y0 = MemR45_4;
	x1 = MemR01_4_offsZI_2;
	y1 = MemR45_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_4_stepII2_2;
	build R45_4_stepII2_3;
}
# 98E3h TL2 mpy  MemR45@4, MemR01@4 || mpy MemR45@4offsZI@3, MemR01@4offsZI@2
#            || add3a p0, p1, Ax@8, dmodij || R01@4stepII2@2, R45@4stepII2@3
op:"mpy" MemR45_4, MemR01_4 || "mpy" MemR45_4_offsZI_3, MemR01_4_offsZI_2 || "add3a" p0, p1, Ax_8, "dmodij" || R01_4_stepII2_2, R45_4_stepII2_3
	is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR45_4 & MemR01_4 & MemR45_4_offsZI_3 & R45_4_stepII2_3 & MemR01_4_offsZI_2 & R01_4_stepII2_2 & opcode_0_1=3 & p0 & p1 & Y0_input & Y1_input
# TODO: dmodij
{
	PRODUCT_ADD3(Ax_8, p0, p1 s>> 16);

	x0 = MemR01_4;
	y0 = MemR45_4;
	x1 = MemR01_4_offsZI_2;
	y1 = MemR45_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R01_4_stepII2_2;
	build R45_4_stepII2_3;
}
# 4DA0h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || sub3  p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "sub3" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=0 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_4, p0, p1);

	x0 = MemR04_3;
	x1 = MemR04_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R04_3_stepII2_2;
}
# 4DA1h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || sub3a p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "sub3a" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_4, p0, p1 s>> 16);

	x0 = MemR04_3;
	x1 = MemR04_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R04_3_stepII2_2;
}
# 4DA2h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || add3  p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "add3" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=2 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_4, p0, p1);

	x0 = MemR04_3;
	x1 = MemR04_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R04_3_stepII2_2;
}
# 4DA3h TL2 mpy  y0, MemR04@3 || mpyus y1, MemR04@3offsZI@2
#            || add3a p0, p1, Ax@4 || R04@3stepII2@2
op:"mpy" y0, MemR04_3 || "mpyus" y1, MemR04_3_offsZI_2 || "add3a" p0, p1, Ax_4 || R04_3_stepII2_2
	is opcode_5_15=(0x4DA>>1) & Ax_4 & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=3 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_4, p0, p1 s>> 16);

	x0 = MemR04_3;
	x1 = MemR04_3_offsZI_2;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R04_3_stepII2_2;
}
# 94E0h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || sub3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "sub3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=0 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_8, p0, p1);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E2h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || sub3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "sub3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=2 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_8, p0, p1 s>> 16);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E4h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || add3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "add3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=4 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_8, p0, p1);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E6h TL2 mpy  y0, MemR04@4 || mpy   y1, MemR04@4offsZI@3
#            || add3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpy" y1, MemR04_4_offsZI_3 || "add3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=6 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_8, p0, p1 s>> 16);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E1h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || sub3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "sub3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_8, p0, p1);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E3h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || sub3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "sub3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=3 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_8, p0, p1 s>> 16);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E5h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || add3  p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "add3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=5 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_8, p0, p1);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 94E7h TL2 mpy  y0, MemR04@4 || mpysu y1, MemR04@4offsZI@3
#            || add3a p0, p1, Ax@8 || R04@4stepII2@3
op:"mpy" y0, MemR04_4 || "mpysu" y1, MemR04_4_offsZI_3 || "add3a" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xE>>1) & MemR04_4 & MemR04_4_offsZI_3 & R04_4_stepII2_3 & opcode_0_2=7 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_8, p0, p1 s>> 16);

	x0 = MemR04_4;
	x1 = MemR04_4_offsZI_3;

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 8862h TL2 mpy  y0, x1 || mpy   MemR04@4, x0 || sub3  p0, p1, Ax@8
#            || R04@4stepII2@3
op:"mpy" y0, x1 || "mpy" MemR04_4, x0 || "sub3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x88>>1) & Ax_8 & opcode_5_7=(6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=2 & y0 & x1 & x0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ax_8, p0, p1);

	y1 = MemR04_4;
	SWAP_X0_X1();

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 8A62h TL2 mpy  y0, x1 || mpy   MemR04@4, x0 || add3  p0, p1, Ax@8
#            || R04@4stepII2@3
op:"mpy" y0, x1 || "mpy" MemR04_4, x0 || "add3" p0, p1, Ax_8 || R04_4_stepII2_3
	is opcode_9_15=(0x8A>>1) & Ax_8 & opcode_5_7=(6>>1) & MemR04_4 & R04_4_stepII2_3 & opcode_0_2=2 & y0 & x1 & x0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ax_8, p0, p1);

	y1 = MemR04_4;
	SWAP_X0_X1();

	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);

	build R04_4_stepII2_3;
}
# 4D88h TL2 mpy  y0, x1 || mpy   y1, x0 || sub p0, p1, Ax@1
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub" p0, p1, Ax_1 is opcode_2_15=(0x4D88>>2) & Ax_1 & opcode_0_0=0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	SUB40_3(Ax_1, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# 5E24h TL2 mpy  y0, x1 || mpy   y1, x0 || add p0, p1, Ab@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "add" p0, p1, Ab_0 is opcode_2_15=(0x5E24>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	ADD40_3(Ab_0, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# 8061h TL2 mpy  y0, x1 || mpy   y1, x0 || add3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x61 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD3(Ab_8, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# 8071h TL2 mpy  y0, x1 || mpy   y1, x0 || add3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3a" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x71 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD3(Ab_8, p0, p1 s>> 16);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# 8461h TL2 mpy  y0, x1 || mpy   y1, x0 || sub3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub3" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x61 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_SUB3(Ab_8, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# 8471h TL2 mpy  y0, x1 || mpy   y1, x0 || sub3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub3a" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x71 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_SUB3(Ab_8, p0, p1 s>> 16);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# D484h TL2 mpy  y0, x1 || mpy   y1, x0 || add3aa p0, p1, Ab@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3aa" p0, p1, Ab_0 is opcode_2_15=(0xD484>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD3(Ab_0, p0 s>> 16, p1 s>> 16);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# D49Dh TL2 mpy  y0, x1 || mpy   y1, x0 || sub p0, p1, Bx@5
op:"mpy" y0, x1 || "mpy" y1, x0 || "sub" p0, p1, Bx_5 is opcode_6_15=(0xD49>>2) & Bx_5 & opcode_0_4=0x1D & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_SUB3(Bx_5, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# D4A0h TL2 mpy  y0, x1 || mpy   y1, x0 || addsub p0, p1, Ab@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" p0, p1, Ab_0 is opcode_2_15=(0xD4A0>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD_SUB(Ab_0, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# 4FA0h TL2 mpy  y0, x1 || mpy y1, x0 || add3 p0, p1, Ab@3
#            || mov Axh@6, MemR04@1 || mov Bxh@2, MemR04@1offsZI@0
#            || R04@1stepII2@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3" p0, p1, Ab_3 || "mov" Axh_6, MemR04_1 || "mov" Bxh_2, MemR04_1_offsZI_0 || R04_1_stepII2_0
	is opcode_7_15=(0x4FA>>3) & Axh_6 & opcode_5_5=(2>>1) & Ab_3 & Bxh_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	MemR04_1_offsZI_0 = Bxh_2; # TODO: saturation
	MemR04_1 = Axh_6; # TODO: saturation
	PRODUCT_ADD3(Ab_3, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R04_1_stepII2_0;
}
# 5818h TL2 mpy  y0, x1 || mpy y1, x0 || addsub    sv, p0, p1, Ax@0
#            || mov Axh@0, MemR0425@7 || mov Axh@not0, MemR0425@7offsZI@6
#            || R0425@7stepII2@6  ;override 5800h+18h (mov a0, Register)
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" sv, p0, p1, Ax_0 || "mov" Axh_0, MemR0425_7 || "mov" Axh_Not0, MemR0425_7_offsZI_6 || R0425_7_stepII2_6
	is opcode_9_15=(0x58>>1) & MemR0425_7 & MemR0425_7_offsZI_6 & R0425_7_stepII2_6 & opcode_1_5=(0x18>>1) & Ax_0 & Axh_0 & Axh_Not0 & x0 & x1 & y0 & y1 & sv & p0 & p1 & Y0_input & Y1_input
{
	MemR0425_7_offsZI_6 = Axh_Not0; # TODO: saturation
	MemR0425_7 = Axh_0; # TODO: saturation
	PRODUCT_ADD_SUB_SV(Ax_0, sext(sv) << 16, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R0425_7_stepII2_6;
}
# 5838h TL2 mpy  y0, x1 || mpy y1, x0 || addsubrnd sv, p0, p1, Ax@0
#            || mov Axh@0, MemR0425@7 || mov Axh@not0, MemR0425@7offsZI@6
#            || R0425@7stepII2@6  ;override 5800h+38h (mov a1, Register)
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsubrnd" sv, p0, p1, Ax_0 || "mov" Axh_0, MemR0425_7 || "mov" Axh_Not0, MemR0425_7_offsZI_6 || R0425_7_stepII2_6
	is opcode_9_15=(0x58>>1) & MemR0425_7 & MemR0425_7_offsZI_6 & R0425_7_stepII2_6 & opcode_1_5=(0x38>>1) & Ax_0 & Axh_0 & Axh_Not0 & x0 & x1 & y0 & y1 & sv & p0 & p1 & Y0_input & Y1_input
{
	MemR0425_7_offsZI_6 = Axh_Not0; # TODO: saturation
	MemR0425_7 = Axh_0; # TODO: saturation
	PRODUCT_ADD_SUB_SV(Ax_0, (sext(sv) << 16) | 0x8000, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R0425_7_stepII2_6;
}
# 80D0h TL2 mpy  y0, x1 || mpy y1, x0 || addsub    sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=0 & x0 & x1 & y0 & y1 & sv & p0 & p1 & Y0_input & Y1_input
{
	MemR04_3_offsZI_2 = Bxh_8; # TODO: saturation
	MemR04_3 = Axh_9; # TODO: saturation
	PRODUCT_ADD_SUB_SV(Ax_10, sext(sv) << 16, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R04_3_stepII2_2;
}
# 80D1h TL2 mpy  y0, x1 || mpy y1, x0 || addsubrnd sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsubrnd" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=1 & x0 & x1 & y0 & y1 & sv & p0 & p1 & Y0_input & Y1_input
{
	MemR04_3_offsZI_2 = Bxh_8; # TODO: saturation
	MemR04_3 = Axh_9; # TODO: saturation
	PRODUCT_ADD_SUB_SV(Ax_10, (sext(sv) << 16) | 0x8000, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R04_3_stepII2_2;
}
# 80D2h TL2 mpy  y0, x1 || mpy y1, x0 || add3      sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=2 & x0 & x1 & y0 & y1 & sv & p0 & p1 & Y0_input & Y1_input
{
	MemR04_3_offsZI_2 = Bxh_8; # TODO: saturation
	MemR04_3 = Axh_9; # TODO: saturation
	PRODUCT_ADD3_SV(Ax_10, sext(sv) << 16, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R04_3_stepII2_2;
}
# 80D3h TL2 mpy  y0, x1 || mpy y1, x0 || add3rnd   sv, p0, p1, Ax@10
#            || mov Axh@9, MemR04@3 || mov Bxh@8, MemR04@3offsZI@2
#            || R04@3stepII2@2
op:"mpy" y0, x1 || "mpy" y1, x0 || "add3rnd" sv, p0, p1, Ax_10 || "mov" Axh_9, MemR04_3 || "mov" Bxh_8, MemR04_3_offsZI_2 || R04_3_stepII2_2
	is opcode_11_15=(0x80>>3) & Ax_10 & Axh_9 & Bxh_8 & opcode_4_7=0xD & MemR04_3 & MemR04_3_offsZI_2 & R04_3_stepII2_2 & opcode_0_1=3 & x0 & x1 & y0 & y1 & sv & p0 & p1 & Y0_input & Y1_input
{
	MemR04_3_offsZI_2 = Bxh_8; # TODO: saturation
	MemR04_3 = Axh_9; # TODO: saturation
	PRODUCT_ADD3_SV(Ax_10, (sext(sv) << 16) | 0x8000, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R04_3_stepII2_2;
}
# D3A0h TL2 mpy  y0, x1 || mpy y1, x0 || addsub p0, p1, Ab@3
#            || mov Axh@6, MemR04@1 || mov Bxh@2, MemR04@1offsZI@0
#            || R04@1stepII2@0
op:"mpy" y0, x1 || "mpy" y1, x0 || "addsub" p0, p1, Ab_3 || "mov" Axh_6, MemR04_1 || "mov" Bxh_2, MemR04_1_offsZI_0 || R04_1_stepII2_0
	is opcode_7_15=(0xD3A>>3) & Axh_6 & opcode_5_5=(2>>1) & Ab_3 & Bxh_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input
{
	MemR04_1_offsZI_0 = Bxh_2; # TODO: saturation
	MemR04_1 = Axh_6; # TODO: saturation
	PRODUCT_ADD_SUB(Ab_3, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
	build R04_1_stepII2_0;
}
# 4D89h TL2 mpy  y0, x1 || mpyus y1, x0 || sub p0, p1, Ax@1
op:"mpy" y0, x1 || "mpyus" y1, x0 || "sub" p0, p1, Ax_1 is opcode_2_15=(0x4D89>>2) & Ax_1 & opcode_0_0=1 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	SUB40_3(Ax_1, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# 5F24h TL2 mpy  y0, x1 || mpyus y1, x0 || add p0, p1, Ab@0
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add" p0, p1, Ab_0 is opcode_2_15=(0x5F24>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	ADD40_3(Ab_0, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# 8069h TL2 mpy  y0, x1 || mpyus y1, x0 || add3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x69 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD3(Ab_8, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# 8079h TL2 mpy  y0, x1 || mpyus y1, x0 || add3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x80>>2) & Ab_8 & opcode_0_7=0x79 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD3(Ab_8, p0, p1 s>> 16);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# 8469h TL2 mpy  y0, x1 || mpyus y1, x0 || sub3  p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x69 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_SUB3(Ab_8, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# 8479h TL2 mpy  y0, x1 || mpyus y1, x0 || sub3a p0, p1, Ab@8
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3" p0, p1, Ab_8 is opcode_10_15=(0x84>>2) & Ab_8 & opcode_0_7=0x79 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_SUB3(Ab_8, p0, p1 s>> 16);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# D584h TL2 mpy  y0, x1 || mpyus y1, x0 || add3aa p0, p1, Ab@0
op:"mpy" y0, x1 || "mpyus" y1, x0 || "add3aa" p0, p1, Ab_0 is opcode_2_15=(0xD584>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD3(Ab_0, p0 s>> 16, p1 s>> 16);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);
}
# D59Dh TL2 mpy  y0, x1 || mpyus y1, x0 || sub p0, p1, Bx@5
op:"mpy" y0, x1 || "mpyus" y1, x0 || "sub" p0, p1, Bx_5 is opcode_6_15=(0xD59>>2) & Bx_5 & opcode_0_4=(0x1D) & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_SUB3(Bx_5, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
# D5A0h TL2 mpy  y0, x1 || mpyus y1, x0 || addsub p0, p1, Ab@0
op:"mpy" y0, x1 || "mpyus" y1, x0 || "addsub" p0, p1, Ab_0 is opcode_2_15=(0xD5A0>>2) & Ab_0 & x0 & x1 & y0 & y1 & p0 & p1 & Y0_input & Y1_input {
	PRODUCT_ADD_SUB(Ab_0, p0, p1);
	SWAP_X0_X1();
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), sext(Y1_input), p1);
}
@endif
# 0800h TL  mpyi NoReverse, Implied p0, y0, Imm8s@0   ;multiply  ;aka "mpys"
op:"mpyi" y0, Imm8s_0 is opcode_8_15=0x08 & Imm8s_0 & y0 & Y0_input {
	x0 = Imm8s_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# D100h TL  mpysu MemR45@2, MemR0123@0 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"mpysu" MemR45_2, MemR0123_0 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_7_15=(0xD10>>3) & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	y0 = MemR45_2;
	x0 = MemR0123_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 8100h TL  mpysu MemRn@0, Imm16@16    || Rn@0stepZIDS@3
op:"mpysu" MemRn_0, Imm16 || Rn_0_stepZIDS_3 is opcode_5_15=(0x810>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	y0 = MemRn_0;
	x0 = Imm16;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8120h TL  mpysu y0, MemRn@0          || Rn@0stepZIDS@3
op:"mpysu" y0, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x812>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	x0 = MemRn_0;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 8140h TL  mpysu y0, Register@0
op:"mpysu" y0, Register_0_Read_No_Saturate is opcode_5_15=(0x814>>1) & Register_0_Read_No_Saturate & y0 & Y0_input {
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# CA00h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
# Similar pattern as CB00h
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=0 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA01h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=1 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA02h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=2 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0 s>> 16, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA03h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || sub3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "sub3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=3 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_SUB3(Ab_6, p0 s>> 16, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA04h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=4 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA05h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3a  p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3a" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=5 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA06h TL2 mpysu MemR45@5, MemR01@5
#            || mpysu MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpysu" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=6 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0 s>> 16, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(zext(x1), sext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# CA07h TL2 mpysu MemR45@5, MemR01@5
#            || mpyus MemR45@5offsZI@4, MemR01@5offsZI@3
#            || add3aa p0, p1, Ab@6 || R01@5stepII2@3, R45@5stepII2@4
op:"mpysu" MemR45_5, MemR01_5 || "mpyus" MemR45_5_offsZI_4, MemR01_5_offsZI_3 || "add3aa" p0, p1, Ab_6 || R01_5_stepII2_3, R45_5_stepII2_4
	is opcode_8_15=0xCA & Ab_6 & MemR45_5 & MemR01_5 & MemR45_5_offsZI_4 & R45_5_stepII2_4 & MemR01_5_offsZI_3 & R01_5_stepII2_3 & opcode_0_2=7 & p0 & p1 & Y0_input & Y1_input
{
	PRODUCT_ADD3(Ab_6, p0 s>> 16, p1 s>> 16);

	x0 = MemR01_5;
	y0 = MemR45_5;
	x1 = MemR01_5_offsZI_3;
	y1 = MemR45_5_offsZI_4;

	MULTIPLY(zext(x0), sext(Y0_input), p0);
	MULTIPLY(sext(x1), zext(Y1_input), p1);

	build R01_5_stepII2_3;
	build R45_5_stepII2_4;
}
# 5EA2h TL2 mpysu y0, r6
op:"mpysu" y0, r6 is opcode_0_15=0x5EA2 & y0 & r6 & Y0_input {
	x0 = r6;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
@endif
# D080h TL  msu  MemR45@2,MemR0123@0,Ax@8 || R0123@0stepZIDS@3, R45@2stepZIDS@5
op:"msu" MemR45_2, MemR0123_0, Ax_8 || R0123_0_stepZIDS_3, R45_2_stepZIDS_5 is opcode_9_15=(0xD0>>1) & Ax_8 & opcode_7_7=1 & R45_2_stepZIDS_5 & R0123_0_stepZIDS_3 & MemR45_2 & MemR0123_0 & Y0_input {
	ADD40(Ax_8, p0);
	x0 = MemR0123_0;
	y0 = MemR45_2;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build R0123_0_stepZIDS_3;
	build R45_2_stepZIDS_5;
}
# 90C0h TL  msu  MemRn@0, Imm16@16,  Ax@8 || Rn@0stepZIDS@3 ;multiply, subtract
op:"msu" MemRn_0, Imm16, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0xC>>1) & Rn_0_stepZIDS_3 & MemRn_0 & Y0_input; Imm16 {
	ADD40(Ax_8, p0);
	x0 = Imm16;
	y0 = MemRn_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 9080h TL  msu  y0, MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"msu" y0, MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 & y0 & Y0_input {
	ADD40(Ax_8, p0);
	x0 = MemRn_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
	build Rn_0_stepZIDS_3;
}
# 90A0h TL  msu  y0, Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"msu" y0, Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate & y0 & Y0_input {
	ADD40(Ax_8, p0);
	x0 = Register_0_Read_No_Saturate;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# B000h TL  msu  y0,MemImm8@0, Ax@8
op:"msu" y0, MemImm8_0, Ax_8 is opcode_9_15=(0xB0>>1) & Ax_8 & MemImm8_0 & y0 & Y0_input {
	ADD40(Ax_8, p0);
	x0 = MemImm8_0;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
@ifdef TEAK_LITE_2
# 9462h TL2 msu  y0, r6, Ax@0
op:"msu" y0, r6, Ax_0 is opcode_1_15=(0x9462>>1) & Ax_0 & r6 & y0 & Y0_input {
	ADD40(Ax_0, p0);
	x0 = r6;
	MULTIPLY(sext(x0), sext(Y0_input), p0);
}
# 8264h TL2 msusu y0, MemR0425@3, Ax@8 || R0425@3stepII2D2S@0
op:"msusu" y0, MemR0425_3, Ax_8 || R0425_3_stepII2D2S_0 is opcode_9_15=(0x82>>1) & Ax_8 & opcode_5_7=(0x6>>1) & MemR0425_3 & opcode_2_2=1 & R0425_3_stepII2D2S_0 & y0 & Y0_input {
	ADD40(Ax_8, p0);
	x0 = MemR0425_3;
	MULTIPLY(zext(x0), sext(Y0_input), p0);
	build R0425_3_stepII2D2S_0;
}
@endif
# 6790h TL  neg  Ax@12, Cond@0 ;aX=0-aX
op:"neg" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x79 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SUB40_3(Ax_12, 0, Ax_12);
}
op:"neg" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x79 & cond_0=0 { SUB40_3(Ax_12, 0, Ax_12); }
# 0000h TL  nop
op:"nop" is opcode_0_15=0x0000 {}
# 94C0h TL  norm Ax@8, Bogus MemRn@0 || Rn@0stepZIDS@3  ;if N=0 (aX=aX*2,rN+/-)
op:"norm" Ax_8, MemRn_0 || Rn_0_stepZIDS_3 is opcode_9_15=(0x94>>1) & Ax_8 & opcode_5_7=(0xC>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 6780h TL  not  Ax@12, Cond@0 ;aX=not aX
op:"not" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x78 & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = ~Ax_12;
	FLAGS40(Ax_12);
}
op:"not" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x78 & cond_0=0 { Ax_12 = ~Ax_12; FLAGS40(Ax_12); }
# D4F8h TL  or   MemImm16@16, Ax@8
# per teakra's ExtendOperandForAlm + AlmGeneric, or doesn't experience sign-extension, nor does it experience saturation
op:"or" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xF8; MemImm16 { Ax_8 = Ax_8 | zext(MemImm16); FLAGS40(Ax_8); }
# A000h TL  or   MemImm8@0, Ax@8
op:"or" MemImm8_0, Ax_8 is opcode_9_15=(0xA0>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 | zext(MemImm8_0); FLAGS40(Ax_8); }
# 80C0h TL  or   Imm16@16, Ax@8
op:"or" Imm16, Ax_8 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 | zext(Imm16); FLAGS40(Ax_8); }
# C000h TL  or   Imm8u@0, Ax@8
op:"or" Imm8u_0, Ax_8 is opcode_9_15=(0xC0>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 | zext(Imm8u_0); FLAGS40(Ax_8); }
# D4D8h TL  or   MemR7Imm16@16, Ax@8
op:"or" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xD8; MemR7Imm16 { Ax_8 = Ax_8 | zext(MemR7Imm16); FLAGS40(Ax_8); }
# 4000h TL  or   MemR7Imm7s@0, Ax@8
op:"or" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x40>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 | zext(MemR7Imm7s_0); FLAGS40(Ax_8); }
# 8080h TL  or   MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"or" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_5_7=(8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 | zext(MemRn_0); FLAGS40(Ax_8); build Rn_0_stepZIDS_3; }
# 80A0h TL  or   RegisterP0@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"or" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x80>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { Ax_8 = Ax_8 | zext(Register_0_Read_No_Saturate); FLAGS40(Ax_8); }
@ifdef TEAK_LITE_2
# D291h TL2 or   Ab@10, Ax@6, Ax@5
op:"or" Ab_10, Ax_6, Ax_5 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x29>>3) & Ax_6 & Ax_5 & opcode_0_4=0x11 { Ax_5 = Ab_10 | Ax_6; FLAGS40(Ax_5); }
# D4A4h TL2 or   Ax@8, Bx@1, Ax@0
op:"or" Ax_8, Bx_1, Ax_0 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_2_7=(0xA4>>2) & Bx_1 & Ax_0 { Ax_0 = Ax_8 | Bx_1; FLAGS40(Ax_0); }
# D3C4h TL2 or   b0, Bx@1, Ax@0
# D7C4h TL2 or   b1, Bx@1, Ax@0
# NOTE: teakra merges this to use Bx@10, which I've done here
op:"or" Bx_10, Bx_1, Ax_0 is opcode_11_15=(0xD3>>3) & Bx_10 & opcode_2_9=(0x3C4>>2) & Bx_1 & Ax_0 { Ax_0 = Bx_10 | Bx_1; FLAGS40(Ax_0); }
# D388h TL2 or   r6, Ax@4
op:"or" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=8 & r6 { Ax_4 = Ax_4 | zext(r6); FLAGS40(Ax_4); }
@endif
# 67B0h TL  pacr Implied Const8000h, Implied p0, Ax@12, Cond@0 ;aX=shfP+8000h
op:"pacr" p0, Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7B & Cond_0 & p0 {
	if (!Cond_0) goto inst_next;
	ADD40_3(Ax_12, p0, 0x8000);
}
op:"pacr" p0, Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x7B & cond_0=0 & p0 { ADD40_3(Ax_12, p0, 0x8000); }
@ifdef TEAK_LITE_2
# D7C2h TL2 pacr1 Implied Const8000h, Implied p1, Ax@0
op:"pacr1" p1, Ax_0 is opcode_1_15=(0xD7C2>>1) & Ax_0 & p1 { ADD40_3(Ax_0, p1, 0x8000); }
@endif
# 5E60h TL  pop  Register@0
op:"pop" Register_0_Write is opcode_5_15=(0x5E60>>5) & Register_0_Write & Register_0_Write_After {
	Register_0_Write = *[data]:2 sp;
	build Register_0_Write_After;
	sp = sp + 1;
}
@ifdef TEAK_LITE_2
# 47B4h TL2 pop  Abe@0
op:"pop" Abe_0 is opcode_2_15=(0x47B4>>2) & Abe_0 & Ab_0 {
	Abe_0 = *[data]:2 sp;
	sp = sp + 1;
	FLAGS40(Ab_0);
}
# 80C7h TL2 pop  ArArpSttMod@8
op:"pop" ArArpSttMod_8 is opcode_12_15=0x8 & ArArpSttMod_8 & opcode_0_7=0xc7 {
	ArArpSttMod_8 = *[data]:2 sp;
	sp = sp + 1;
}
# 0006h TL2 pop  Bx@5, Unused1@0
op:"pop" Bx_5 is opcode_6_15=0 & Bx_5 & opcode_1_4=(6>>1) & unused_0_0 {
	Bx_5 = *[data]:2 sp;
	sp = sp + 1;
}
# D7F4h TL2 pop  prpage, Unused2@0
op:"pop" prpage is opcode_2_15=(0xD7F4>>2) & unused_0_1 & prpage {
	prpage = *[data]:2 sp;
	sp = sp + 1;
}
# D496h TL2 pop  Px@0
op:"pop" Px_0 is opcode_1_15=(0xD496>>1) & Px_0 {
	Px_0 = *[data]:2 sp;
	sp = sp + 1;
}
# 0024h TL2 pop  r6, Unused1@0
op:"pop" r6 is opcode_1_15=(0x0024>>1) & unused_0_0 & r6 {
	r6 = *[data]:2 sp;
	sp = sp + 1;
}
# D7F0h TL2 pop  repc, Unused2@0
op:"pop" repc is opcode_2_15=(0xD7F0>>2) & unused_0_1 & repc {
	repc = *[data]:2 sp;
	sp = sp + 1;
}
# D494h TL2 pop  x0
op:"pop" x0 is opcode_0_15=0xD494 & x0 {
	x0 = *[data]:2 sp;
	sp = sp + 1;
}
# D495h TL2 pop  x1
op:"pop" x1 is opcode_0_15=0xD495 & x1 {
	x1 = *[data]:2 sp;
	sp = sp + 1;
}
# 0004h TL2 pop  y1, Unused1@0
op:"pop" y1 is opcode_1_15=(4>>1) & unused_0_0 & y1 {
	y1 = *[data]:2 sp;
	sp = sp + 1;
}
# 47B0h TL2 popa Ab@0
op:"popa" Ab_0 is opcode_2_15=(0x47B0>>2) & Ab_0 {
	local h:2 = *[data]:2 sp;
	sp = sp + 1;
	local l:2 = *[data]:2 sp;
	sp = sp + 1;
	local full:4 = (zext(h) << 16) | zext(l);
	Ab_0 = sext(full);
	FLAGS40(Ab_0);
}
@endif
# 5F40h TL  push Imm16@16
op:"push" Imm16 is opcode_0_15=0x5F40; Imm16 {
	sp = sp - 1;
	*[data]:2 sp = Imm16;
}
# 5E40h TL  push Register@0
op:"push" Register_0_Read_Saturate is opcode_5_15=(0x5E40>>5) & Register_0_Read_Saturate {
	sp = sp - 1;
	*[data]:2 sp = Register_0_Read_Saturate;
}
@ifdef TEAK_LITE_2
# D7C8h TL2 push Abe@1, Unused1@0
op:"push" Abe_1 is opcode_3_15=(0xD7C8>>3) & Abe_1 & unused_0_0 {
	# TODO: saturation
	sp = sp - 1;
	*[data]:2 sp = Abe_1;
}
# D3D0h TL2 push ArArpSttMod@0
op:"push" ArArpSttMod_0 is opcode_4_15=0xD3D & ArArpSttMod_0 {
	sp = sp - 1;
	*[data]:2 sp = ArArpSttMod_0;
}
# D7FCh TL2 push prpage, Unused2@0
op:"push" prpage is opcode_2_15=(0xD7FC>>2) & unused_0_1 & prpage {
	sp = sp - 1;
	*[data]:2 sp = prpage;
}
# D78Ch TL2 push Px@1, Unused1@0
op:"push" Px_1 is opcode_2_15=(0xD78C>>2) & Px_1 & unused_0_0 {
	sp = sp - 1;
	*[data]:2 sp = Px_1;
}
# D4D7h TL2 push r6, Unused1@5
op:"push" r6 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x17 & r6 {
	sp = sp - 1;
	*[data]:2 sp = r6;
}
# D7F8h TL2 push repc, Unused2@0
op:"push" repc is opcode_2_15=(0xD7F8>>2) & unused_0_1 & repc {
	sp = sp - 1;
	*[data]:2 sp = repc;
}
# D4D4h TL2 push x0, Unused1@5
op:"push" x0 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x14 & x0 {
	sp = sp - 1;
	*[data]:2 sp = x0;
}
# D4D5h TL2 push x1, Unused1@5
op:"push" x1 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x15 & x1 {
	sp = sp - 1;
	*[data]:2 sp = x1;
}
# D4D6h TL2 push y1, Unused1@5
op:"push" y1 is opcode_6_15=(0xD4D>>2) & unused_5_5 & opcode_0_4=0x16 & y1 {
	sp = sp - 1;
	*[data]:2 sp = y1;
}
# 4384h TL2 pusha Ax@6, Unused2@0
op:"pusha" Ax_6 is opcode_7_15=(0x438>>3) & Ax_6 & opcode_2_5=(4>>2) & unused_0_1 & Axh_6 & Axl_6 {
	# TODO: saturation
	sp = sp - 1;
	*[data]:2 sp = Axl_6;
	sp = sp - 1;
	*[data]:2 sp = Axh_6;
}
# D788h TL2 pusha Bx@1, Unused1@0
op:"pusha" Bx_1 is opcode_2_15=(0xD788>>2) & Bx_1 & unused_0_0 & Bxh_1 & Bxl_1 {
	# TODO: saturation
	sp = sp - 1;
	*[data]:2 sp = Bxl_1;
	sp = sp - 1;
	*[data]:2 sp = Bxh_1;
}
@endif
AfterLoopWrapper:tmp is epsilon [ tmp = inst_start + 2; ] { export *[code]:2 tmp; }
# 0C00h TL  rep  Imm8u@0    ;repeat next opcode N+1 times
# Note: these should use repc instead of the same system as bkrep, but I don't think there's any
# way to actually observe this in a single-instruction loop.
op:"rep" Imm8u_0 is opcode_8_15=0x0C & Imm8u_0 & AfterLoopWrapper & CurLC [
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Imm8u_0;
}
# 0D00h TL  rep  Register@0 ;repeat next opcode N+1 times
op:"rep" Register_0_Read_No_Saturate is opcode_5_15=(0x0D0>>1) & Register_0_Read_No_Saturate & AfterLoopWrapper & CurLC [
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = Register_0_Read_No_Saturate;
}
@ifdef TEAK_LITE_2
# 0002h TL2 rep  r6, Unused1@0
op:"rep" r6 is opcode_1_15=(0x0002>>1) & unused_0_0 & r6 & AfterLoopWrapper & CurLC [
	hasloopjumpback = 1;
	loopjumpbackaddr = inst_start + 1;
	globalset(AfterLoopWrapper, loopstackdepth);
	loopstackdepth = loopstackdepth + 1;
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopjumpbackaddr);
	globalset(inst_next, loopstackdepth);
	# Reset the addresses for this instruction - no looping should happen on this instruction, only the next one.
	hasloopjumpback = 0;
	loopjumpbackaddr = 0;
] {
	CurLC = r6;
}
@endif
# 4580h TL  ret  Cond@0      ;=pop pc
op:"ret" Cond_0 is opcode_4_15=0x458 & Cond_0 {
	if (!Cond_0) goto inst_next;
	# TODO: proper stack
	return [sp];
}
op:"ret" is opcode_4_15=0x458 & cond_0=0 {
	# TODO: proper stack
	return [sp];
}
# D780h TL  retd    ;delayed return (after 2 clks)
# TODO: This assumes every instruction is 1 clock, but http://problemkaputt.de/gbatek-dsi-teak-misc.htm says there are a few exceptions
op:"retd" is opcode_0_15=0xD780 {
	delayslot(2);
	# TODO: proper stack
	return [sp];
}
# 45C0h TL  reti Cond@0          ;Don't context switch
op:"reti" Cond_0 is opcode_4_15=0x45C & Cond_0 {
	if (!Cond_0) goto inst_next;
	# TODO: proper stack
	return [sp];
}
op:"reti" is opcode_4_15=0x45C & cond_0=0 {
	# TODO: proper stack
	return [sp];
}
# 45D0h TL  reti Cond@0, context ;Do context switch
op:"reti" Cond_0, "context" is opcode_4_15=0x45D & Cond_0 {
	if (!Cond_0) goto inst_next;
	# TODO: proper stack
	return [sp];
}
op:"reti" "context" is opcode_4_15=0x45D & cond_0=0 {
	# TODO: proper stack
	return [sp];
}
# D7C0h TL  retid   ;delayed, from interrupt
op:"retid" is opcode_0_15=0xD7C0 {
	delayslot(2);
	# TODO: proper stack
	return [sp];
}
@ifdef TEAK_LITE_2
# D3C3h TL2 retid context
op:"retid" "context" is opcode_0_15=0xD3C3 {
	delayslot(2);
	# TODO: proper stack
	return [sp];
}
@endif
# 0900h TL  rets Imm8u@0          ;ret+dealloc sp (for INCOMING pushed params)
op:"rets" Imm8u_0 is opcode_8_15=0x09 & Imm8u_0 {
	# TODO: proper stack
	return [sp];
}
# 67A0h TL  rnd  Implied Const8000h, Ax@12, Cond@0 ;aX=aX+8000h
op:"rnd" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x7A) & Cond_0 {
	if (!Cond_0) goto inst_next;
	ADD40(Ax_12, 0x8000);
}
op:"rnd" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x7A) & cond_0=0  { ADD40(Ax_12, 0x8000); }
# 6750h TL  rol  Implied Const1,     Ax@12, Cond@0 ;aX=aX rcl 1 (37bit rotate)
op:"rol" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x75) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = (Ax_12 << 1) | ((Ax_12 >> 37) & 1);
}
op:"rol" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x75) & cond_0=0 {
	Ax_12 = (Ax_12 << 1) | ((Ax_12 >> 37) & 1);
}
# 6F50h TL  rol  Implied Const1,     Bx@12, Cond@0 ;bX=bX rcl 1 (37bit rotate)
op:"rol" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF5) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = (Bx_12 << 1) | ((Bx_12 >> 37) & 1);
}
op:"rol" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF5) & cond_0=0 {
	Bx_12 = (Bx_12 << 1) | ((Bx_12 >> 37) & 1);
}
# 6740h TL  ror  Implied Const1,     Ax@12, Cond@0 ;aX=aX rcr 1 (37bit rotate)
op:"ror" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x74) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Ax_12 = (Ax_12 >> 1) | ((Ax_12 & 1) << 37);
}
op:"ror" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=(0x74) & cond_0=0 {
	Ax_12 = (Ax_12 >> 1) | ((Ax_12 & 1) << 37);
}
# 6F40h TL  ror  Implied Const1,     Bx@12, Cond@0 ;bX=bX rcr 1 (37bit rotate)
op:"ror" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF4) & Cond_0 {
	if (!Cond_0) goto inst_next;
	Bx_12 = (Bx_12 >> 1) | ((Bx_12 & 1) << 37);
}
op:"ror" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=(0xF4) & cond_0=0 {
	Bx_12 = (Bx_12 >> 1) | ((Bx_12 & 1) << 37);
}
# E300h TL  rst  Imm16@16, MemImm8@0
macro RST(dest, a, b) {
	local result:2 = a & ~b;
	FLAGS16(result);
	dest = result;
}
op:"rst" Imm16, MemImm8_0 is opcode_8_15=0xE3 & MemImm8_0; Imm16 { RST(MemImm8_0, MemImm8_0, Imm16); }
# 82E0h TL  rst  Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"rst" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x82E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { RST(MemRn_0, MemRn_0, Imm16); build Rn_0_stepZIDS_3; }
# 83E0h TL  rst  Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 AND also weird behavior for writing to [ab][01][lh], not currently implemented
op:"rst" Imm16, Register_0_Write is opcode_5_15=(0x83E>>1) & Register_0_Read_No_Saturate & Register_0_Write & Register_0_Write_After; Imm16 { RST(Register_0_Write, Register_0_Read_No_Saturate, Imm16); build Register_0_Write_After; }
@ifdef TEAK_LITE_2
# 47B9h TL2 rst  Imm16@16, r6
op:"rst" Imm16, r6 is opcode_0_15=0x47B9 & r6; Imm16 { RST(r6, r6, Imm16); }
# 4388h TL2 rst  Imm16@16, SttMod@0
op:"rst" Imm16, SttMod_0 is opcode_3_15=(0x4388>>3) & SttMod_0; Imm16 { RST(SttMod_0, SttMod_0, Imm16); }
@endif
# E100h TL  set  Imm16@16, MemImm8@0
macro SET(dest, a, b) {
	local result:2 = a | b;
	FLAGS16(result);
	dest = result;
}
op:"set" Imm16, MemImm8_0 is opcode_8_15=0xE1 & MemImm8_0; Imm16 { SET(MemImm8_0, MemImm8_0, Imm16); }
# 80E0h TL  set  Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"set" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x80E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { SET(MemRn_0, MemRn_0, Imm16); build Rn_0_stepZIDS_3; }
# 81E0h TL  set  Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 AND also weird behavior for writing to [ab][01][lh], not currently implemented
op:"set" Imm16, Register_0_Write is opcode_5_15=(0x81E>>1) & Register_0_Read_No_Saturate & Register_0_Write & Register_0_Write_After; Imm16 { SET(Register_0_Write, Register_0_Read_No_Saturate, Imm16); build Register_0_Write_After; }
@ifdef TEAK_LITE_2
# 47B8h TL2 set  Imm16@16, r6
op:"set" Imm16, r6 is opcode_0_15=0x47B8 & r6; Imm16 { SET(r6, r6, Imm16); }
# 43C8h TL2 set  Imm16@16, SttMod@0
op:"set" Imm16, SttMod_0 is opcode_3_15=(0x43C8>>3) & SttMod_0; Imm16 { SET(SttMod_0, SttMod_0, Imm16); }
@endif
# D280h TL  shfc Implied sv, Ab@10, Ab@5, Cond@0
op:"shfc" sv, Ab_10, Ab_5, Cond_0 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x28>>3) & Ab_5 & opcode_4_4=0 & Cond_0 & sv {
	if (!Cond_0) goto inst_next;
	SHIFT_40(Ab_5, Ab_10, sv);
}
op:"shfc" sv, Ab_10, Ab_5 is opcode_12_15=0xD & Ab_10 & opcode_7_9=(0x28>>3) & Ab_5 & opcode_4_4=0 & cond_0=0 & sv { SHIFT_40(Ab_5, Ab_10, sv); }
# 9240h TL  shfi Implied Imm6s@0, Ab@10, Ab@7, Bogus Imm6s@0
op:"shfi" Imm6s_0, Ab_10, Ab_7 is opcode_12_15=9 & Ab_10 & opcode_9_9=1 & Ab_7 & opcode_6_6=1 & Imm6s_0 { SHIFT_40(Ab_7, Ab_10, Imm6s_0); }
# 6720h TL  shl  Implied Const1,     Ax@12, Cond@0 ;aX=aX*2
op:"shl" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x72 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Ax_12, 1);
	Ax_12 = Ax_12 << 1;
	FLAGS40(Ax_12);
}
op:"shl" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x72 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Ax_12, 1);
	Ax_12 = Ax_12 << 1;
	FLAGS40(Ax_12);
}
# 6F20h TL  shl  Implied Const1,     Bx@12, Cond@0 ;bX=bX*2
op:"shl" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF2 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Bx_12, 1);
	Bx_12 = Bx_12 << 1;
	FLAGS40(Bx_12);
}
op:"shl" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF2 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Bx_12, 1);
	Bx_12 = Bx_12 << 1;
	FLAGS40(Bx_12);
}
# 6730h TL  shl4 Implied Const4,     Ax@12, Cond@0 ;aX=aX*10h
op:"shl4" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x73 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Ax_12, 4);
	Ax_12 = Ax_12 << 4;
	FLAGS40(Ax_12);
}
op:"shl4" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x73 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Ax_12, 4);
	Ax_12 = Ax_12 << 4;
	FLAGS40(Ax_12);
}
# 6F30h TL  shl4 Implied Const4,     Bx@12, Cond@0 ;bX=bX*10h
op:"shl4" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF3 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Bx_12, 4);
	Bx_12 = Bx_12 << 4;
	FLAGS40(Bx_12);
}
op:"shl4" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF3 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Bx_12, 4);
	Bx_12 = Bx_12 << 4;
	FLAGS40(Bx_12);
}
# 6700h TL  shr  Implied Const1,     Ax@12, Cond@0 ;aX=aX/2
# TODO: handle signed vs unsigned shift based on s flag
op:"shr" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x70 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Ax_12, -1);
	Ax_12 = Ax_12 >> 1;
	FLAGS40(Ax_12);
}
op:"shl" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x70 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Ax_12, -1);
	Ax_12 = Ax_12 >> 1;
	FLAGS40(Ax_12);
}
# 6F00h TL  shr  Implied Const1,     Bx@12, Cond@0 ;bX=bX/2
op:"shl" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF0 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Bx_12, -1);
	Bx_12 = Bx_12 >> 1;
	FLAGS40(Bx_12);
}
op:"shl" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF0 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Bx_12, -1);
	Bx_12 = Bx_12 >> 1;
	FLAGS40(Bx_12);
}
# 6710h TL  shr4 Implied Const4,     Ax@12, Cond@0 ;aX=aX/10h
op:"shl4" Ax_12, Cond_0 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x71 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Ax_12, -4);
	Ax_12 = Ax_12 >> 4;
	FLAGS40(Ax_12);
}
op:"shl4" Ax_12 is opcode_13_15=(6>>1) & Ax_12 & opcode_4_11=0x71 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Ax_12, -4);
	Ax_12 = Ax_12 >> 4;
	FLAGS40(Ax_12);
}
# 6F10h TL  shr4 Implied Const4,     Bx@12, Cond@0 ;bX=bX/10h
op:"shl4" Bx_12, Cond_0 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF1 & Cond_0 {
	if (!Cond_0) goto inst_next;
	SHIFT_OVERFLOW_FLAGS(Bx_12, -4);
	Bx_12 = Bx_12 >> 4;
	FLAGS40(Bx_12);
}
op:"shl4" Bx_12 is opcode_13_15=(6>>1) & Bx_12 & opcode_4_11=0xF1 & cond_0=0 {
	SHIFT_OVERFLOW_FLAGS(Bx_12, -4);
	Bx_12 = Bx_12 >> 4;
	FLAGS40(Bx_12);
}
# BA00h TL  sqr  MemImm8@0
op:"sqr" MemImm8_0 is opcode_8_15=0xBA & MemImm8_0 unimpl
# 9A80h TL  sqr  MemRn@0 || Rn@0stepZIDS@3
op:"sqr" MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x9A8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9AA0h TL  sqr  Register@0
# TODO: this is alm but the second parameter is ignored; should this have an Unused@8?
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"sqr" Register_0_Read_No_Saturate is opcode_5_15=(0x9AA>>1) & Register_0_Read_No_Saturate unimpl
@ifdef TEAK_LITE_2
# D790h TL2 sqr  Abh@2 || sqr Abl@2 || add3 p0, p1, Ab@0
op:"sqr" Abh_2 || "sqr" Abl_2 || "add3" p0, p1, Ab_0 is opcode_4_15=0xD79 & Abh_2 & Abl_2 & Ab_0 & p0 & p1 unimpl
# 49C4h TL2 sqr  Abh@4 || mpysu Abh@4, Abl@4 || add3a p0, p1, Ab@0
op:"sqr" Abh_4 || "mpysu" Abh_4_copy, Abl_4 || "add3a" p0, p1, Ab_0 is opcode_6_15=(0x49C>>2) & Abh_4 & Abh_4_copy & Abl_4 & opcode_2_3=(4>>2) & Ab_0 & p0 & p1 unimpl
# 4B00h TL2 sqr  MemR0425@4 || sqr MemR0425@4offsZIDZ@2 || add3 p0, p1, Ab@0
#            || R0425@4stepII2D2S@2
op:"sqr" MemR0425_4 || "sqr" MemR0425_4_offsZIDZ_2 || "add3" p0, p1, Ab_0 || R0425_4_stepII2D2S_2
	is opcode_6_15=(0x4B0>>2) & MemR0425_4 & MemR0425_4_offsZIDZ_2 & R0425_4_stepII2D2S_2 & Ab_0 & p0 & p1
unimpl
# 5F41h TL2 sqr  r6
op:"sqr" r6 is opcode_0_15=0x5F41 & r6 unimpl
@endif
# BC00h TL  sqra MemImm8@0, Ax@8
op:"sqra" MemImm8_0, Ax_8 is opcode_9_15=(0xBC>>1) & Ax_8 & MemImm8_0 unimpl
# 9C80h TL  sqra MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"sqra" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9CA0h TL  sqra Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"sqra" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x9C>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate unimpl
@ifdef TEAK_LITE_2
# 9062h TL2 sqra r6, Ax@8, Unused1@0
op:"sqra" r6, Ax_8 is opcode_9_15=(0x90>>1) & Ax_8 & opcode_1_7=(0x62>>1) & unused_0_0 & r6 unimpl
@endif
# D4FFh TL  sub  MemImm16@16, Ax@8
op:"sub" MemImm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xFF; MemImm16 { SUB40(Ax_8, sext(MemImm16)); }
# AE00h TL  sub  MemImm8@0, Ax@8
op:"sub" MemImm8_0, Ax_8 is opcode_9_15=(0xAE>>1) & Ax_8 & MemImm8_0 { SUB40(Ax_8, sext(MemImm8_0)); }
# 8EC0h TL  sub  Imm16@16, Ax@8
op:"sub" Imm16, Ax_8 is opcode_9_15=(0x8E>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { SUB40(Ax_8, sext(Imm16)); }
# CE00h TL  sub  Imm8u@0, Ax@8
op:"sub" Imm8u_0, Ax_8 is opcode_9_15=(0xCE>>1) & Ax_8 & Imm8u_0 { SUB40(Ax_8, zext(Imm8u_0)); }
# D4DFh TL  sub  MemR7Imm16@16, Ax@8
op:"sub" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDF; MemR7Imm16 { SUB40(Ax_8, sext(MemR7Imm16)); }
# 4E00h TL  sub  MemR7Imm7s@0, Ax@8
op:"sub" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x4E>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { SUB40(Ax_8, sext(MemR7Imm7s_0)); }
# 8E80h TL  sub  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"sub" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x8E>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { SUB40(Ax_8, sext(MemRn_0)); build Rn_0_stepZIDS_3; }
# 8EA0h TL  sub  RegisterP0@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"sub" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x8E>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { SUB40(Ax_8, sext(Register_0_Read_No_Saturate)); }
@ifdef TEAK_LITE_2
# 8A61h TL2 sub  Ab@3, Bx@8
op:"sub" Ab_3, Bx_8 is opcode_9_15=(0x8A>>1) & Bx_8 & opcode_5_7=(6>>1) & Ab_3 & opcode_0_2=1 { SUB40(Bx_8, Ab_3); }
# 8861h TL2 sub  Bx@4, Ax@3
op:"sub" Bx_4, Ax_3 is opcode_5_15=(0x886>>1) & Bx_4 & Ax_3 & opcode_0_2=1 { SUB40(Ax_3, Bx_4); }
# 8064h TL2 sub  MemR01@8, sv, Abh@3 || add MemR01@8offsZI@0, sv, Abl@3
#            || mov MemR45@8, sv || R01@8stepII2@0, R45@8stepII2@1
op:"sub" MemR01_8, sv, Abh_3 || "add" MemR01_8_offsZI_0, sv_copy, Abl_3 || "mov" MemR45_8, sv_copy_2 || R01_8_stepII2_0, R45_8_stepII2_1
	is opcode_9_15=(0x80>>1) & MemR01_8 & MemR45_8 & opcode_4_7=6 & Abh_3 & Abl_3 & Ab_3 & opcode_2_2=1 & MemR01_8_offsZI_0 & R01_8_stepII2_0 & R45_8_stepII2_1 & sv & sv_copy & sv_copy_2
{
	# teakra sub_add_i_mov_j_sv - no flags
	local high:5 = sext(MemR01_8) - sext(sv);
	local low:5 = zext(MemR01_8_offsZI_0 + sv);
	Ab_3 = (high << 16) | low;
	sv = MemR45_8;
	build R01_8_stepII2_0;
	build R45_8_stepII2_1;
}
# 5DE0h TL2 sub  MemR04@1, sv, Abh@2 || add MemR04@1offsZI@0, sv, Abl@2
#            || R04@1stepII2@0
op:"sub" MemR04_1, sv, Abh_2 || "add" MemR04_1_offsZI_0, sv_copy, Abl_2 || R04_1_stepII2_0
	is opcode_4_15=0x5DE & Abh_2 & Abl_2 & Ab_2 & MemR04_1 & MemR04_1_offsZI_0 & R04_1_stepII2_0 & sv & sv_copy
{
	# teakra sub_add_sv - no flags
	local high:5 = sext(MemR04_1) - sext(sv);
	local low:5 = zext(MemR04_1_offsZI_0 + sv);
	Ab_2 = (high << 16) | low;
	build R04_1_stepII2_0;
}
# 6FC0h TL2 sub  MemR45@2, MemR01@2, Abh@3
#            || add MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"sub" MemR45_2, MemR01_2, Abh_3 || "add" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x6FC>>1) & Abh_3 & Abl_3 & Ab_3 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0
{
	# teakra sub_add - no flags
	local high:5 = sext(MemR45_2) - sext(MemR01_2);
	local low:5 = zext(MemR45_2_offsZI_1 + MemR01_2_offsZI_0);
	Ab_3 = (high << 16) | low;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 6FE0h TL2 sub  MemR45@2, MemR01@2, Abh@3
#            || sub MemR45@2offsZI@1, MemR01@2offsZI@0, Abl@3
#            || R01@2stepII2@0, R45@2stepII2@1
op:"sub" MemR45_2, MemR01_2, Abh_3 || "sub" MemR45_2_offsZI_1, MemR01_2_offsZI_0, Abl_3 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x6FE>>1) & Abh_3 & Abl_3 & Ab_3 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & MemR01_2_offsZI_0 & R01_2_stepII2_0
{
	# teakra sub_sub - no flags
	local high:5 = sext(MemR45_2) - sext(MemR01_2);
	local low:5 = zext(MemR45_2_offsZI_1 - MemR01_2_offsZI_0);
	Ab_3 = (high << 16) | low;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 5D80h TL2 sub  MemR45@2, sv, Abh@3 || add MemR45@2offsZI@1, sv, Abl@3
#            || mov MemR01@2, sv || R01@2stepII2@0, R45@2stepII2@1
op:"sub" MemR45_2, sv, Abh_3 || "add" MemR45_2_offsZI_1, sv_copy, Abl_3 || "mov" MemR01_2, sv_copy_2 || R01_2_stepII2_0, R45_2_stepII2_1
	is opcode_5_15=(0x5D8>>1) & Abh_3 & Abl_3 & Ab_3 & MemR45_2 & MemR01_2 & MemR45_2_offsZI_1 & R45_2_stepII2_1 & R01_2_stepII2_0 & sv & sv_copy & sv_copy_2
{
	# teakra sub_add_j_mov_i_sv - no flags
	local high:5 = sext(MemR45_2) - sext(sv);
	local low:5 = zext(MemR45_2_offsZI_1 + sv);
	Ab_3 = (high << 16) | low;
	sv = MemR01_2;
	build R01_2_stepII2_0;
	build R45_2_stepII2_1;
}
# 5DC2h TL2 sub  p0, p1, Ab@2
# TODO: better handling of product registers - there's some additional shift stuff that needs to happen
# NOTE: we don't need to do an ADD40(0, p0) call as that will never set FLAG_C or FLAG_V
# (teakra's ProductSum is just too generalized)
op:"sub" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=2 & p0 & p1 { SUB40_3(Ab_2, p0, p1); }
# D4B9h TL2 sub  p1, Ax@8
op:"sub" p1, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xB9 & p1 { SUB40(Ax_8, p1); }
# 8FD0h TL2 sub  Px@1, Bx@0
op:"sub" Px_1, Bx_0 is opcode_2_15=(0x8FD0>>2) & Px_1 & Bx_0 { SUB40(Bx_0, Px_1); }
# D38Fh TL2 sub  r6, Ax@4
op:"sub" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xF & r6 { SUB40(Ax_4, sext(r6)); }
# 80C6h TL2 sub3 p0, p1, Ab@10
op:"sub3" p0, p1, Ab_10 is opcode_12_15=8 & Ab_10 & opcode_0_9=0x0C6 & p0 & p1 { PRODUCT_SUB3(Ab_10, p0, p1); }
# 82C6h TL2 sub3a p0, p1, Ab@10
op:"sub3a" p0, p1, Ab_10 is opcode_12_15=8 & Ab_10 & opcode_0_9=0x2C6 & p0 & p1 { PRODUCT_SUB3(Ab_10, p0, p1 s>> 16); }
# 83C6h TL2 sub3aa p0, p1, Ab@10
op:"sub3aa" p0, p1, Ab_10 is opcode_12_15=8 & Ab_10 & opcode_0_9=0x3C6 & p0 & p1 { PRODUCT_SUB3(Ab_10, p0 s>> 16, p1 s>> 16); }
# 5DC3h TL2 suba p0, p1, Ab@2
op:"suba" p0, p1, Ab_2 is opcode_4_15=0x5DC & Ab_2 & opcode_0_1=3 & p0 & p1 { SUB40_3(Ab_2, p0, p1 s>> 16); }
@endif
# B600h TL  subh MemImm8@0, Ax@8
# per teakra ExtendOperandForAlm, subh shifts its operand by 16
op:"subh" MemImm8_0, Ax_8 is opcode_9_15=(0xB6>>1) & Ax_8 & MemImm8_0 { SUB40(Ax_8, sext(MemImm8_0) << 16); }
# 9680h TL  subh MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"subh" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x96>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { SUB40(Ax_8, sext(MemRn_0) << 16); build Rn_0_stepZIDS_3; }
# 96A0h TL  subh Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"subh" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x96>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { SUB40(Ax_8, sext(Register_0_Read_No_Saturate) << 16); }
@ifdef TEAK_LITE_2
# 5E23h TL2 subh r6, Ax@8
op:"subh" r6, Ax_8 is opcode_9_15=(0x5E>>2) & Ax_8 & opcode_0_7=0x23 & r6 { SUB40(Ax_8, sext(r6) << 16); }
@endif
# B800h TL  subl MemImm8@0, Ax@8
# per teakra ExtendOperandForAlm (not having anything), subl zero-extends instead of sign-extending
op:"subl" MemImm8_0, Ax_8 is opcode_9_15=(0xB8>>1) & Ax_8 & MemImm8_0 { SUB40(Ax_8, zext(MemImm8_0)); }
# 9880h TL  subl MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"subl" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { SUB40(Ax_8, zext(MemRn_0)); build Rn_0_stepZIDS_3; }
# 98A0h TL  subl Register@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"subl" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x98>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { SUB40(Ax_8, zext(Register_0_Read_No_Saturate)); }
@ifdef TEAK_LITE_2
# 5E22h TL2 subl r6, Ax@8
op:"subl" r6, Ax_8 is opcode_9_15=(0x5E>>2) & Ax_8 & opcode_0_7=0x22 & r6 { SUB40(Ax_8, zext(r6)); }
@endif
# EF00h TL  subv Imm16@16, MemImm8@0
op:"subv" Imm16, MemImm8_0 is opcode_8_15=0xEF & MemImm8_0; Imm16 { SUB16(MemImm8_0, MemImm8_0, Imm16); }
# 8EE0h TL  subv Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"subv" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x8EE>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { SUB16(MemRn_0, MemRn_0, Imm16); build Rn_0_stepZIDS_3; }
# 8FE0h TL  subv Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 AND also weird behavior for writing to [ab][01][lh], not currently implemented
op:"subv" Imm16, Register_0_Write is opcode_5_15=(0x8FE>>1) & Register_0_Read_No_Saturate & Register_0_Write & Register_0_Write_After; Imm16 { SUB16(Register_0_Write, Register_0_Read_No_Saturate, Imm16); build Register_0_Write_After; }
@ifdef TEAK_LITE_2
# 47BFh TL2 subv Imm16@16, r6
op:"subv" Imm16, r6 is opcode_0_15=0x47BF & r6; Imm16 { SUB16(r6, r6, Imm16); }
@endif
# 4980h TL  swap SwapTypes4@0
#
# SwapTypes:
# val native           nocash         ;meaning
# 0:  (a0,b0)          a0,b0          ;a0 <--> b0                ;flags(a0)
# 1:  (a0,b1)          a0,b1          ;a0 <--> b1                ;flags(a0)
# 2:  (a1,b0)          a1,b0          ;a1 <--> b0                ;flags(a1)
# 3:  (a1,b1)          a1,b1          ;a1 <--> b1                ;flags(a1)
# 4:  (a0,b0),(a1,b1)  a0:a1,b0:b1    ;a0 <--> b0 and a1 <--> b1 ;flags(a0)
# 5:  (a0,b1),(a1,b0)  a0:a1,b1:b0    ;a0 <--> b1 and a1 <--> b0 ;flags(a0)
# 6:  (a0,b0,a1)       a1,b0,a0       ;a0 --> b0 --> a1          ;flags(a1)
# 7:  (a0,b1,a1)       a1,b1,a0       ;a0 --> b1 --> a1          ;flags(a1)
# 8:  (a1,b0,a0)       a0,b0,a1       ;a1 --> b0 --> a0          ;flags(a0)
# 9:  (a1,b1,a0)       a0,b1,a1       ;a1 --> b1 --> a0          ;flags(a0)
# A:  (b0,a0,b1)       b1,a0,b0       ;b0 --> a0 --> b1          ;flags(a0)!
# B:  (b0,a1,b1)       b1,a1,b0       ;b0 --> a1 --> b1          ;flags(a1)!
# C:  (b1,a0,b0)       b0,a0,b1       ;b1 --> a0 --> b0          ;flags(a0)!
# D:  (b1,a1,b0)       b0,a1,b1       ;b1 --> a1 --> b0          ;flags(a1)!
# E:  reserved         reserved       ;-                         ;-
# F:  reserved         reserved       ;-                         ;-
#
# Note that nocash vs native is not just a punctuation difference; it reorders things too.

macro swap_2(x, y) { # x <--> y
	local tmp = x;
	x = y;
	y = tmp;
}
macro swap_3(x, y, z) { # x --> y --> z
	local tmp = z;
	z = y;
	y = x;
	x = tmp;
}
macro swap_flags(register) {} # TODO

# 0:  (a0,b0)          a0,b0          ;a0 <--> b0                ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b0) is SwapTypes_0=0 & a0 & b0
@else
SwapTypes:a0,b0 is SwapTypes_0=0 & a0 & b0
@endif
{ swap_2(a0, b0); swap_flags(a0); }
# 1:  (a0,b1)          a0,b1          ;a0 <--> b1                ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b1) is SwapTypes_0=1 & a0 & b1
@else
SwapTypes:a0,b1 is SwapTypes_0=1 & a0 & b1
@endif
{ swap_2(a0, b1); swap_flags(a0); }
# 2:  (a1,b0)          a1,b0          ;a1 <--> b0                ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b0) is SwapTypes_0=2 & a1 & b0
@else
SwapTypes:a1,b0 is SwapTypes_0=2 & a1 & b0
@endif
{ swap_2(a1, b0); swap_flags(a1); }
# 3:  (a1,b1)          a1,b1          ;a1 <--> b1                ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b1) is SwapTypes_0=3 & a1 & b1
@else
SwapTypes:a1,b1 is SwapTypes_0=3 & a1 & b1
@endif
{ swap_2(a1, b1); swap_flags(a1); }
# 4:  (a0,b0),(a1,b1)  a0:a1,b0:b1    ;a0 <--> b0 and a1 <--> b1 ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b0),(a1,b1) is SwapTypes_0=4 & a0 & a1 & b0 & b1
@else
SwapTypes:a0:a1,b0:b1 is SwapTypes_0=4 & a0 & a1 & b0 & b1
@endif
{ swap_2(a0, b0); swap_2(a1, b1); swap_flags(a0); }
# 5:  (a0,b1),(a1,b0)  a0:a1,b1:b0    ;a0 <--> b1 and a1 <--> b0 ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b1),(a1,b0) is SwapTypes_0=5 & a0 & a1 & b0 & b1
@else
SwapTypes:a0:a1,b1:b0 is SwapTypes_0=5 & a0 & a1 & b0 & b1
@endif
{ swap_2(a0, b1); swap_2(a1, b0); swap_flags(a0); }
# 6:  (a0,b0,a1)       a1,b0,a0       ;a0 --> b0 --> a1          ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b0,a1) is SwapTypes_0=6 & a0 & b0 & a1
@else
SwapTypes:a1,b0,a0 is SwapTypes_0=6 & a0 & b0 & a1
@endif
{ swap_3(a0, b0, a1); swap_flags(a1); }
# 7:  (a0,b1,a1)       a1,b1,a0       ;a0 --> b1 --> a1          ;flags(a1)
@ifndef NOCASH_SYNTAX
SwapTypes:(a0,b1,a1) is SwapTypes_0=7 & a0 & b1 & a1
@else
SwapTypes:a1,b1,a0 is SwapTypes_0=7 & a0 & b1 & a1
@endif
{ swap_3(a0, b1, a1); swap_flags(a1); }
# 8:  (a1,b0,a0)       a0,b0,a1       ;a1 --> b0 --> a0          ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b0,a0) is SwapTypes_0=8 & a0 & b0 & a1
@else
SwapTypes:a0,b0,a1 is SwapTypes_0=8 & a0 & b0 & a1
@endif
{ swap_3(a1, b0, a0); swap_flags(a0); }
# 9:  (a1,b1,a0)       a0,b1,a1       ;a1 --> b1 --> a0          ;flags(a0)
@ifndef NOCASH_SYNTAX
SwapTypes:(a1,b1,a0) is SwapTypes_0=9 & a0 & b1 & a1
@else
SwapTypes:a0,b1,a1 is SwapTypes_0=9 & a0 & b1 & a1
@endif
{ swap_3(a1, b1, a0); swap_flags(a0); }
# A:  (b0,a0,b1)       b1,a0,b0       ;b0 --> a0 --> b1          ;flags(a0)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b0,a0,b1) is SwapTypes_0=0xA & b0 & b1 & a0
@else
SwapTypes:b1,a0,b0 is SwapTypes_0=0xA & b0 & b1 & a0
@endif
{ swap_3(b0, a0, b1); swap_flags(a0); }
# B:  (b0,a1,b1)       b1,a1,b0       ;b0 --> a1 --> b1          ;flags(a1)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b0,a1,b1) is SwapTypes_0=0xB & b0 & b1 & a1
@else
SwapTypes:b1,a1,b0 is SwapTypes_0=0xB & b0 & b1 & a1
@endif
{ swap_3(b0, a1, b1); swap_flags(a1); }
# C:  (b1,a0,b0)       b0,a0,b1       ;b1 --> a0 --> b0          ;flags(a0)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b1,a0,b0) is SwapTypes_0=0xC & b0 & b1 & a0
@else
SwapTypes:b0,a0,b1 is SwapTypes_0=0xC & b0 & b1 & a0
@endif
{ swap_3(b1, a0, b0); swap_flags(a0); }
# D:  (b1,a1,b0)       b0,a1,b1       ;b1 --> a1 --> b0          ;flags(a1)!
@ifndef NOCASH_SYNTAX
SwapTypes:(b1,a1,b0) is SwapTypes_0=0xD & b0 & b1 & a1
@else
SwapTypes:b0,a1,b1 is SwapTypes_0=0xD & b0 & b1 & a1
@endif
{ swap_3(b1, a1, b0); swap_flags(a1); }

op:"swap" SwapTypes is opcode_4_15=0x498 & SwapTypes { build SwapTypes; }
# 0020h TL  trap                  ;software interrupt
define pcodeop software_interrupt;
op:"trap" is opcode_0_15=0x0020 { software_interrupt(); }
# A800h TL  tst0 Axl@8, MemImm8@0
op:"tst0" is opcode_9_15=(0xA8>>1) & Axl_8 & MemImm8_0 { $(FLAG_Z) = (Axl_8 & MemImm8_0) == 0; }
# 8880h TL  tst0 Axl@8, MemRn@0 || Rn@0stepZIDS@3
op:"tst0" Axl_8, MemRn_0 || Rn_0_stepZIDS_3 is opcode_9_15=(0x88>>1) & Axl_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { $(FLAG_Z) = (Axl_8 & MemRn_0) == 0; build Rn_0_stepZIDS_3; }
# 88A0h TL  tst0 Axl@8, Register@0
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"tst0" Axl_8, Register_0_Read_No_Saturate is opcode_9_15=(0x88>>1) & Axl_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { $(FLAG_Z) = (Axl_8 & Register_0_Read_No_Saturate) == 0; }
# E900h TL  tst0 Imm16@16, MemImm8@0
op:"tst0" Imm16, MemImm8_0 is opcode_8_15=0xE9 & MemImm8_0; Imm16 { $(FLAG_Z) = (Imm16 & MemImm8_0) == 0; }
# 88E0h TL  tst0 Imm16@16, MemRn@0 || Rn@0stepZIDS@3
op:"tst0" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x88E>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { $(FLAG_Z) = (Imm16 & MemRn_0) == 0; build Rn_0_stepZIDS_3; }
# 89E0h TL  tst0 Imm16@16, Register@0
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 (tst0 does not write, so that behavior does not apply)
op:"tst0" Imm16, Register_0_Read_No_Saturate is opcode_5_15=(0x89E>>1) & Register_0_Read_No_Saturate; Imm16 { $(FLAG_Z) = (Imm16 & Register_0_Read_No_Saturate) == 0; }
@ifdef TEAK_LITE_2
# D38Ch TL2 tst0 Axl@4, r6
op:"tst0" Axl_4, r6 is opcode_5_15=(0xD38>>1) & Axl_4 & opcode_0_3=0xC & r6 { $(FLAG_Z) = (Axl_4 & r6) == 0; }
# 47BCh TL2 tst0 Imm16@16, r6
op:"tst0" Imm16, r6 is opcode_0_15=0x47BC & r6; Imm16 { $(FLAG_Z) = (Imm16 & r6) == 0; }
# 9470h TL2 tst0 Imm16@16, SttMod@0
op:"tst0" Imm16, SttMod_0 is opcode_3_15=(0x9470>>3) & SttMod_0; Imm16 { $(FLAG_Z) = (Imm16 & SttMod_0) == 0; }
@endif
# AA00h TL  tst1 Axl@8, MemImm8@0 Implied Not
op:"tst1" is opcode_9_15=(0xAA>>1) & Axl_8 & MemImm8_0 { $(FLAG_Z) = (Axl_8 & ~MemImm8_0) == 0; }
# 8A80h TL  tst1 Axl@8, MemRn@0 Implied Not || Rn@0stepZIDS@3
op:"tst1" Axl_8, MemRn_0 || Rn_0_stepZIDS_3 is opcode_9_15=(0x8A>>1) & Axl_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { $(FLAG_Z) = (Axl_8 & ~MemRn_0) == 0; build Rn_0_stepZIDS_3; }
# 8AA0h TL  tst1 Axl@8, Register@0 Implied Not
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"tst1" Axl_8, Register_0_Read_No_Saturate is opcode_9_15=(0x8A>>1) & Axl_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { $(FLAG_Z) = (Axl_8 & ~Register_0_Read_No_Saturate) == 0; }
# EB00h TL  tst1 Imm16@16, MemImm8@0 Implied Not
op:"tst1" Imm16, MemImm8_0 is opcode_8_15=0xEB & MemImm8_0; Imm16 { $(FLAG_Z) = (Imm16 & ~MemImm8_0) == 0; }
# 8AE0h TL  tst1 Imm16@16, MemRn@0 Implied Not || Rn@0stepZIDS@3
op:"tst1" Imm16, MemRn_0 || Rn_0_stepZIDS_3 is opcode_5_15=(0x8AE>>1) & Rn_0_stepZIDS_3 & MemRn_0; Imm16 { $(FLAG_Z) = (Imm16 & ~MemRn_0) == 0; build Rn_0_stepZIDS_3; }
# 8BE0h TL  tst1 Imm16@16, Register@0 Implied Not
# TODO: teakra alb indicates special behavior for Register_0 p, a0, and a1 (tst1 does not write, so that behavior does not apply)
op:"tst1" Imm16, Register_0_Read_No_Saturate is opcode_5_15=(0x8BE>>1) & Register_0_Read_No_Saturate; Imm16 { $(FLAG_Z) = (Imm16 & ~Register_0_Read_No_Saturate) == 0; }
@ifdef TEAK_LITE_2
# D38Dh TL2 tst1 Axl@4, r6 Implied Not
op:"tst1" Axl_4, r6 is opcode_5_15=(0xD38>>1) & Axl_4 & opcode_0_3=0xD & r6 { $(FLAG_Z) = (Axl_4 & ~r6) == 0; }
# 47BDh TL2 tst1 Imm16@16, r6 Implied Not
op:"tst1" Imm16, r6 is opcode_0_15=0x47BD & r6; Imm16 { $(FLAG_Z) = (Imm16 & ~r6) == 0; }
# 9478h TL2 tst1 Imm16@16, SttMod@0 Implied Not
op:"tst1" Imm16, SttMod_0 is opcode_3_15=(0x9478>>3) & SttMod_0; Imm16 { $(FLAG_Z) = (Imm16 & ~SttMod_0) == 0; }
# 80C1h TL2 tst4b a0l, MemR0425@10 || R0425@10stepII2D2S@8
op:"tst4b" a0l, MemR0425_10 || R0425_10_stepII2D2S_8 is opcode_12_15=8 & MemR0425_10 & R0425_10_stepII2D2S_8 & opcode_0_7=0xC1 & a0l unimpl
# 4780h TL2 tst4b a0l, MemR0425@2, Ax@4 || R0425@2stepII2D2S@0
op:"tst4b" a0l, MemR0425_2, Ax_4 || R0425_2_stepII2D2S_0 is opcode_5_15=(0x478>>1) & Ax_4 & MemR0425_2 & R0425_2_stepII2D2S_0 & a0l unimpl
@endif
# F000h TL  tstb NoReverse, Implied Not MemImm8@0, Imm4bitno@8
op:"tstb" MemImm8_0, Imm4bitno_8 is opcode_12_15=0xF & Imm4bitno_8 & MemImm8_0 unimpl
# 9020h TL  tstb NoReverse, Implied Not MemRn@0, Imm4bitno@8 || Rn@0stepZIDS@3
op:"tstb" MemRn_0, Imm4bitno_8 || Rn_0_stepZIDS_3 is opcode_12_15=9 & Imm4bitno_8 & opcode_5_7=(2>>1) & Rn_0_stepZIDS_3 & MemRn_0 unimpl
# 9000h TL  tstb NoReverse, Implied Not Register@0, Imm4bitno@8
op:"tstb" Register_0_Read_No_Saturate, Imm4bitno_8 is opcode_12_15=9 & Imm4bitno_8 & opcode_5_7=0 & Register_0_Read_No_Saturate unimpl
@ifdef TEAK_LITE_2
# 9018h TL2 tstb NoReverse, Implied Not r6, Imm4bitno@8  ;override tstb a0,Imm4
op:"tstb" r6, Imm4bitno_8 is opcode_12_15=9 & Imm4bitno_8 & opcode_0_7=0x18 & r6 unimpl
# 0028h TL2 tstb NoReverse, Implied Not SttMod@0, Imm4bitno@16, Unused12@20
op:"tstb" SttMod_0, Imm4bitno_16 is opcode_3_15=(0x0028>>3) & SttMod_0; Imm4bitno_16 & expanded_unused_20_31 unimpl
# 5F45h TL2 vtrclr vtr0         ;vtr0=0           ;for Viterbi decoding...
op:"vtrclr" vtr0 is opcode_0_15=0x5F45 & vtr0 { vtr0 = 0; }
# 5F47h TL2 vtrclr vtr0, vtr1   ;vtr0=0, vtr1=0   ;(saved C/C1 carry flags)
# TODO: C/C1 carry flags?
op:"vtrclr" vtr0, vtr1 is opcode_0_15=0x5F47 & vtr0 & vtr1 { vtr0 = 0; vtr1 = 0; }
# 5F46h TL2 vtrclr vtr1         ;vtr1=0
op:"vtrclr" vtr1 is opcode_0_15=0x5F46 & vtr1 { vtr1 = 0; }
# D383h TL2 vtrmov Axl@4        ;Axl=(vtr1 and FF00h)+(vtr0/100h)
op:"vtrmov" Axl_4 is opcode_5_15=(0xD38>>1) & Axl_4 & opcode_0_3=3 { Axl_4 = (vtr1 & 0xFF00) | ((vtr0 & 0xFF00) >> 8); }
# D29Ah TL2 vtrmov vtr0, Axl@0  ;Axl=vtr0
op:"vtrmov" vtr0, Axl_0 is opcode_1_15=(0xD29A>>1) & Axl_0 & vtr0 { Axl_0 = vtr0; }
# D69Ah TL2 vtrmov vtr1, Axl@0  ;Axl=vtr1
op:"vtrmov" vtr1, Axl_0 is opcode_1_15=(0xD69A>>1) & Axl_0 & vtr1 { Axl_0 = vtr1; }
# D781h TL2 vtrshr              ;vtr0=vtr0/2+C*8000h, vtr1=vtr1/2+C1*8000h
op:"vtrshr" is opcode_0_15=0xD781 unimpl
@endif
# D4FAh TL  xor  MemImm16@16, Ax@8
# per teakra's ExtendOperandForAlm + AlmGeneric, xor doesn't experience sign-extension, nor does it experience saturation
op:"xor" MemImm16, Ax_8 is opcode_9_15=(0xDA>>1) & Ax_8 & opcode_0_7=0xFA; MemImm16 { Ax_8 = Ax_8 ^ zext(MemImm16); FLAGS40(Ax_8); }
# A400h TL  xor  MemImm8@0, Ax@8
op:"xor" MemImm8_0, Ax_8 is opcode_9_15=(0xA4>>1) & Ax_8 & MemImm8_0 { Ax_8 = Ax_8 ^ zext(MemImm8_0); FLAGS40(Ax_8); }
# 84C0h TL  xor  Imm16@16, Ax@8
op:"xor" Imm16, Ax_8 is opcode_9_15=(0x84>>1) & Ax_8 & opcode_0_7=0xC0; Imm16 { Ax_8 = Ax_8 ^ zext(Imm16); FLAGS40(Ax_8); }
# C400h TL  xor  Imm8u@0, Ax@8
op:"xor" Imm8u_0, Ax_8 is opcode_9_15=(0xC4>>1) & Ax_8 & Imm8u_0 { Ax_8 = Ax_8 ^ zext(Imm8u_0); FLAGS40(Ax_8); }
# D4DAh TL  xor  MemR7Imm16@16, Ax@8
op:"xor" MemR7Imm16, Ax_8 is opcode_9_15=(0xD4>>1) & Ax_8 & opcode_0_7=0xDA; MemR7Imm16 { Ax_8 = Ax_8 ^ zext(MemR7Imm16); FLAGS40(Ax_8); }
# 4400h TL  xor  MemR7Imm7s@0, Ax@8
op:"xor" MemR7Imm7s_0, Ax_8 is opcode_9_15=(0x44>>1) & Ax_8 & opcode_7_7=0 & MemR7Imm7s_0 { Ax_8 = Ax_8 ^ zext(MemR7Imm7s_0); FLAGS40(Ax_8); }
# 8480h TL  xor  MemRn@0, Ax@8 || Rn@0stepZIDS@3
op:"xor" MemRn_0, Ax_8 || Rn_0_stepZIDS_3 is opcode_9_15=(0x84>>1) & Ax_8 & opcode_5_7=(0x8>>1) & Rn_0_stepZIDS_3 & MemRn_0 { Ax_8 = Ax_8 ^ zext(MemRn_0); build Rn_0_stepZIDS_3; FLAGS40(Ax_8); }
# 84A0h TL  xor  RegisterP0@0, Ax@8
# TODO: teakra alm indicates special behavior for Register_0 p, a0, and a1
op:"xor" Register_0_Read_No_Saturate, Ax_8 is opcode_9_15=(0x84>>1) & Ax_8 & opcode_5_7=(0xA>>1) & Register_0_Read_No_Saturate { Ax_8 = Ax_8 ^ zext(Register_0_Read_No_Saturate); FLAGS40(Ax_8); }
@ifdef TEAK_LITE_2
# D38Ah TL2 xor  r6, Ax@4
op:"xor" r6, Ax_4 is opcode_5_15=(0xD38>>1) & Ax_4 & opcode_0_3=0xA & r6 { Ax_4 = Ax_4 ^ zext(r6); FLAGS40(Ax_4); }
@endif
# 8800h TL  undefined Unused5@0, Unused1@8 ;(mpy/mpys without A in bit11)
# 8820h TL  undefined Unused5@0, Unused1@8 ;(mpy/mpys without A in bit11)
# 8840h TL  undefined Unused5@0, Unused1@8 ;(mpy/mpys without A in bit11)
# D800h TL  undefined Unused7@0, Unused1@8 ;(mpy/mpys without A in bit11)
# 9B80h TL  undefined Unused6@0  ;(sqr without A in bit8)
# BB00h TL  undefined Unused8@0  ;(sqr without A in bit8)
# E800h TL  undefined Unused8@0  ;(mpy without A in bit11)
@ifdef TEAK_LITE_2
# 5EA1h TL2 undefined Unused1@1  ;(mpy/mpys without A in bit11)
# 5DFCh TL2 undefined - would be clrp clearing neither p0 nor p1
# 8CDEh TL2 undefined
# D3C1h TL2 undefined
# 5EB4h TL2 undefined Unused2@0
@endif

# Handle looping logic:
LoopJumpBackAddrWrapper: " =>"^loopjumpbackaddr is loopjumpbackaddr { export *[code]:2 loopjumpbackaddr; }

# Note: unlike GCDSP, a rep 0 or bkrep 0 instruction still runs the loop once. So we don't need
# to check to skip a loop, and instead can handle everything in the jumpback.
# Also, teakra checks this at the start of the instruction, instead of the end of the previous one:
# https://github.com/wwylele/teakra/blob/01db7cdd00aabcce559a8dddce8798dabb71949b/src/interpreter.h#L102-L112
# I guess this would make a difference with jumps, but it seems weird.
loopjumpback:"" is hasloopjumpback=0 {}
loopjumpback:LoopJumpBackAddrWrapper is hasloopjumpback=1 & LoopJumpBackAddrWrapper & CurLC {
	if (CurLC == 0) goto inst_next;
	CurLC = CurLC - 1;
	goto LoopJumpBackAddrWrapper;
}

# Now populate the root instruction table.
:^op is op & hasloopjumpback=0 {
	build op;
}
:^" "^op^loopjumpback is op & hasloopjumpback=1 & loopjumpback {
	build op;
	build loopjumpback;
}
